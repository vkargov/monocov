<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - mono.info - mini/mini.h</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">mini</a> - mini.h<span style="font-size: 80%;"> (source / <a href="mini.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">mono.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">29</td>
            <td class="headerCovTableEntry">30</td>
            <td class="headerCovTableEntryHi">96.7 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-01-18 17:24:17</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">8</td>
            <td class="headerCovTableEntry">8</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :  * Copyright 2002-2003 Ximian Inc
<span class="lineNum">       3 </span>            :  * Copyright 2003-2011 Novell Inc
<span class="lineNum">       4 </span>            :  * Copyright 2011 Xamarin Inc
<span class="lineNum">       5 </span>            :  * Licensed under the MIT license. See LICENSE file in the project root for full license information.
<span class="lineNum">       6 </span>            :  */
<span class="lineNum">       7 </span>            : #ifndef __MONO_MINI_H__
<span class="lineNum">       8 </span>            : #define __MONO_MINI_H__
<span class="lineNum">       9 </span>            : 
<span class="lineNum">      10 </span>            : #include &quot;config.h&quot;
<span class="lineNum">      11 </span>            : #include &lt;glib.h&gt;
<span class="lineNum">      12 </span>            : #ifdef HAVE_SIGNAL_H
<span class="lineNum">      13 </span>            : #include &lt;signal.h&gt;
<span class="lineNum">      14 </span>            : #endif
<span class="lineNum">      15 </span>            : #ifdef HAVE_SYS_TYPES_H
<span class="lineNum">      16 </span>            : #include &lt;sys/types.h&gt;
<span class="lineNum">      17 </span>            : #endif
<span class="lineNum">      18 </span>            : #include &lt;mono/metadata/loader.h&gt;
<span class="lineNum">      19 </span>            : #include &lt;mono/metadata/mempool.h&gt;
<span class="lineNum">      20 </span>            : #include &lt;mono/utils/monobitset.h&gt;
<span class="lineNum">      21 </span>            : #include &lt;mono/metadata/class.h&gt;
<span class="lineNum">      22 </span>            : #include &lt;mono/metadata/object.h&gt;
<span class="lineNum">      23 </span>            : #include &lt;mono/metadata/opcodes.h&gt;
<span class="lineNum">      24 </span>            : #include &lt;mono/metadata/tabledefs.h&gt;
<span class="lineNum">      25 </span>            : #include &lt;mono/metadata/domain-internals.h&gt;
<span class="lineNum">      26 </span>            : #include &quot;mono/metadata/class-internals.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;mono/metadata/object-internals.h&quot;
<span class="lineNum">      28 </span>            : #include &lt;mono/metadata/profiler-private.h&gt;
<span class="lineNum">      29 </span>            : #include &lt;mono/metadata/debug-helpers.h&gt;
<span class="lineNum">      30 </span>            : #include &lt;mono/utils/mono-compiler.h&gt;
<span class="lineNum">      31 </span>            : #include &lt;mono/utils/mono-machine.h&gt;
<span class="lineNum">      32 </span>            : #include &lt;mono/utils/mono-stack-unwinding.h&gt;
<span class="lineNum">      33 </span>            : #include &lt;mono/utils/mono-threads.h&gt;
<span class="lineNum">      34 </span>            : #include &lt;mono/utils/mono-threads-coop.h&gt;
<span class="lineNum">      35 </span>            : #include &lt;mono/utils/mono-tls.h&gt;
<span class="lineNum">      36 </span>            : #include &lt;mono/utils/atomic.h&gt;
<span class="lineNum">      37 </span>            : #include &lt;mono/utils/mono-conc-hashtable.h&gt;
<span class="lineNum">      38 </span>            : #include &lt;mono/utils/mono-signal-handler.h&gt;
<span class="lineNum">      39 </span>            : 
<span class="lineNum">      40 </span>            : #include &quot;mini-arch.h&quot;
<span class="lineNum">      41 </span>            : #include &quot;regalloc.h&quot;
<span class="lineNum">      42 </span>            : #include &quot;mini-unwind.h&quot;
<span class="lineNum">      43 </span>            : #include &quot;jit.h&quot;
<span class="lineNum">      44 </span>            : #include &quot;cfgdump.h&quot;
<span class="lineNum">      45 </span>            : 
<span class="lineNum">      46 </span>            : #include &quot;mono/metadata/class-internals.h&quot;
<span class="lineNum">      47 </span>            : #include &quot;mono/metadata/domain-internals.h&quot;
<span class="lineNum">      48 </span>            : #include &quot;mono/metadata/object.h&quot;
<span class="lineNum">      49 </span>            : #include &quot;mono/metadata/tabledefs.h&quot;
<span class="lineNum">      50 </span>            : #include &quot;mono/metadata/marshal.h&quot;
<span class="lineNum">      51 </span>            : #include &quot;mono/metadata/security-manager.h&quot;
<span class="lineNum">      52 </span>            : #include &quot;mono/metadata/exception.h&quot;
<span class="lineNum">      53 </span>            : #include &quot;mono/utils/mono-compiler.h&quot;
<span class="lineNum">      54 </span>            : 
<span class="lineNum">      55 </span>            : #ifdef __native_client_codegen__
<span class="lineNum">      56 </span>            : #include &lt;nacl/nacl_dyncode.h&gt;
<span class="lineNum">      57 </span>            : #endif
<span class="lineNum">      58 </span>            : 
<span class="lineNum">      59 </span>            : 
<span class="lineNum">      60 </span>            : /*
<span class="lineNum">      61 </span>            :  * The mini code should not have any compile time dependencies on the GC being used, so the same object file from mini/
<span class="lineNum">      62 </span>            :  * can be linked into both mono and mono-sgen.
<span class="lineNum">      63 </span>            :  */
<span class="lineNum">      64 </span>            : #if defined(HAVE_BOEHM_GC) || defined(HAVE_SGEN_GC)
<span class="lineNum">      65 </span>            : #error &quot;The code in mini/ should not depend on these defines.&quot;
<span class="lineNum">      66 </span>            : #endif
<span class="lineNum">      67 </span>            : 
<span class="lineNum">      68 </span>            : #ifndef __GNUC__
<span class="lineNum">      69 </span>            : /*#define __alignof__(a) sizeof(a)*/
<span class="lineNum">      70 </span>            : #define __alignof__(type) G_STRUCT_OFFSET(struct { char c; type x; }, x)
<span class="lineNum">      71 </span>            : #endif
<span class="lineNum">      72 </span>            : 
<span class="lineNum">      73 </span>            : #if DISABLE_LOGGING
<span class="lineNum">      74 </span>            : #define MINI_DEBUG(level,limit,code)
<span class="lineNum">      75 </span>            : #else
<span class="lineNum">      76 </span>            : #define MINI_DEBUG(level,limit,code) do {if (G_UNLIKELY ((level) &gt;= (limit))) code} while (0)
<span class="lineNum">      77 </span>            : #endif
<span class="lineNum">      78 </span>            : 
<span class="lineNum">      79 </span>            : #if !defined(DISABLE_TASKLETS) &amp;&amp; defined(MONO_ARCH_SUPPORT_TASKLETS)
<span class="lineNum">      80 </span>            : #if defined(__GNUC__)
<span class="lineNum">      81 </span>            : #define MONO_SUPPORT_TASKLETS 1
<span class="lineNum">      82 </span>            : #elif defined(HOST_WIN32)
<span class="lineNum">      83 </span>            : #define MONO_SUPPORT_TASKLETS 1
<span class="lineNum">      84 </span>            : // Replace some gnu intrinsics needed for tasklets with MSVC equivalents.
<span class="lineNum">      85 </span>            : #define __builtin_extract_return_addr(x) x
<span class="lineNum">      86 </span>            : #define __builtin_return_address(x) _ReturnAddress()
<span class="lineNum">      87 </span>            : #define __builtin_frame_address(x) _AddressOfReturnAddress()
<span class="lineNum">      88 </span>            : #endif
<span class="lineNum">      89 </span>            : #endif
<span class="lineNum">      90 </span>            : 
<span class="lineNum">      91 </span>            : #if ENABLE_LLVM
<span class="lineNum">      92 </span>            : #define COMPILE_LLVM(cfg) ((cfg)-&gt;compile_llvm)
<span class="lineNum">      93 </span>            : #define LLVM_ENABLED TRUE
<span class="lineNum">      94 </span>            : #else
<span class="lineNum">      95 </span>            : #define COMPILE_LLVM(cfg) (0)
<span class="lineNum">      96 </span>            : #define LLVM_ENABLED FALSE
<span class="lineNum">      97 </span>            : #endif
<span class="lineNum">      98 </span>            : 
<span class="lineNum">      99 </span>            : #ifdef MONO_ARCH_SOFT_FLOAT_FALLBACK
<span class="lineNum">     100 </span>            : #define COMPILE_SOFT_FLOAT(cfg) (!COMPILE_LLVM ((cfg)) &amp;&amp; mono_arch_is_soft_float ())
<span class="lineNum">     101 </span>            : #else
<span class="lineNum">     102 </span>            : #define COMPILE_SOFT_FLOAT(cfg) (0)
<span class="lineNum">     103 </span>            : #endif
<span class="lineNum">     104 </span>            : 
<span class="lineNum">     105 </span>            : #define NOT_IMPLEMENTED do { g_assert_not_reached (); } while (0)
<span class="lineNum">     106 </span>            : 
<span class="lineNum">     107 </span>            : /* for 32 bit systems */
<span class="lineNum">     108 </span>            : #if G_BYTE_ORDER == G_LITTLE_ENDIAN
<span class="lineNum">     109 </span>            : #define MINI_LS_WORD_IDX 0
<span class="lineNum">     110 </span>            : #define MINI_MS_WORD_IDX 1
<span class="lineNum">     111 </span>            : #else
<span class="lineNum">     112 </span>            : #define MINI_LS_WORD_IDX 1
<span class="lineNum">     113 </span>            : #define MINI_MS_WORD_IDX 0
<span class="lineNum">     114 </span>            : #endif
<span class="lineNum">     115 </span>            : #define MINI_LS_WORD_OFFSET (MINI_LS_WORD_IDX * 4)
<span class="lineNum">     116 </span>            : #define MINI_MS_WORD_OFFSET (MINI_MS_WORD_IDX * 4)
<span class="lineNum">     117 </span>            : #define inst_ls_word data.op[MINI_LS_WORD_IDX].const_val
<span class="lineNum">     118 </span>            : #define inst_ms_word data.op[MINI_MS_WORD_IDX].const_val
<span class="lineNum">     119 </span>            : 
<span class="lineNum">     120 </span>            : #define MONO_LVREG_LS(lvreg)    ((lvreg) + 1)
<span class="lineNum">     121 </span>            : #define MONO_LVREG_MS(lvreg)    ((lvreg) + 2)
<span class="lineNum">     122 </span>            : 
<span class="lineNum">     123 </span>            : #ifndef DISABLE_AOT
<span class="lineNum">     124 </span>            : #define MONO_USE_AOT_COMPILER
<span class="lineNum">     125 </span>            : #endif
<span class="lineNum">     126 </span>            : 
<span class="lineNum">     127 </span>            : /* Version number of the AOT file format */
<span class="lineNum">     128 </span>            : #define MONO_AOT_FILE_VERSION 139
<span class="lineNum">     129 </span>            : 
<span class="lineNum">     130 </span>            : //TODO: This is x86/amd64 specific.
<span class="lineNum">     131 </span>            : #define mono_simd_shuffle_mask(a,b,c,d) ((a) | ((b) &lt;&lt; 2) | ((c) &lt;&lt; 4) | ((d) &lt;&lt; 6))
<span class="lineNum">     132 </span>            : 
<span class="lineNum">     133 </span>            : /* Remap printf to g_print (we use a mix of these in the mini code) */
<span class="lineNum">     134 </span>            : #ifdef PLATFORM_ANDROID
<span class="lineNum">     135 </span>            : #define printf g_print
<span class="lineNum">     136 </span>            : #endif
<span class="lineNum">     137 </span>            : 
<span class="lineNum">     138 </span>            : #define MONO_TYPE_IS_PRIMITIVE(t) ((!(t)-&gt;byref &amp;&amp; ((((t)-&gt;type &gt;= MONO_TYPE_BOOLEAN &amp;&amp; (t)-&gt;type &lt;= MONO_TYPE_R8) || ((t)-&gt;type &gt;= MONO_TYPE_I &amp;&amp; (t)-&gt;type &lt;= MONO_TYPE_U)))))
<span class="lineNum">     139 </span>            : 
<span class="lineNum">     140 </span>            : #define MONO_AOT_TRAMP_PAGE_SIZE 16384
<span class="lineNum">     141 </span>            : 
<span class="lineNum">     142 </span>            : /* Constants used to encode different types of methods in AOT */
<span class="lineNum">     143 </span>            : enum {
<span class="lineNum">     144 </span>            :         MONO_AOT_METHODREF_MIN = 240,
<span class="lineNum">     145 </span>            :         /* Image index bigger than METHODREF_MIN */
<span class="lineNum">     146 </span>            :         MONO_AOT_METHODREF_LARGE_IMAGE_INDEX = 249,
<span class="lineNum">     147 </span>            :         /* Runtime provided methods on arrays */
<span class="lineNum">     148 </span>            :         MONO_AOT_METHODREF_ARRAY = 250,
<span class="lineNum">     149 </span>            :         MONO_AOT_METHODREF_NO_AOT_TRAMPOLINE = 251,
<span class="lineNum">     150 </span>            :         /* Wrappers */
<span class="lineNum">     151 </span>            :         MONO_AOT_METHODREF_WRAPPER = 252,
<span class="lineNum">     152 </span>            :         /* Methods on generic instances */
<span class="lineNum">     153 </span>            :         MONO_AOT_METHODREF_GINST = 253,
<span class="lineNum">     154 </span>            :         /* Methods resolve using a METHODSPEC token */
<span class="lineNum">     155 </span>            :         MONO_AOT_METHODREF_METHODSPEC = 254,
<span class="lineNum">     156 </span>            : };
<span class="lineNum">     157 </span>            : 
<span class="lineNum">     158 </span>            : /* Constants used to encode different types of types in AOT */
<span class="lineNum">     159 </span>            : enum {
<span class="lineNum">     160 </span>            :         /* typedef index */
<span class="lineNum">     161 </span>            :         MONO_AOT_TYPEREF_TYPEDEF_INDEX = 1,
<span class="lineNum">     162 </span>            :         /* typedef index + image index */
<span class="lineNum">     163 </span>            :         MONO_AOT_TYPEREF_TYPEDEF_INDEX_IMAGE = 2,
<span class="lineNum">     164 </span>            :         /* typespec token */
<span class="lineNum">     165 </span>            :         MONO_AOT_TYPEREF_TYPESPEC_TOKEN = 3,
<span class="lineNum">     166 </span>            :         /* generic inst */
<span class="lineNum">     167 </span>            :         MONO_AOT_TYPEREF_GINST = 4,
<span class="lineNum">     168 </span>            :         /* type/method variable */
<span class="lineNum">     169 </span>            :         MONO_AOT_TYPEREF_VAR = 5,
<span class="lineNum">     170 </span>            :         /* array */
<span class="lineNum">     171 </span>            :         MONO_AOT_TYPEREF_ARRAY = 6,
<span class="lineNum">     172 </span>            :         /* blob index of the type encoding */
<span class="lineNum">     173 </span>            :         MONO_AOT_TYPEREF_BLOB_INDEX = 7,
<span class="lineNum">     174 </span>            :         /* ptr */
<span class="lineNum">     175 </span>            :         MONO_AOT_TYPEREF_PTR = 8
<span class="lineNum">     176 </span>            : };
<span class="lineNum">     177 </span>            : 
<span class="lineNum">     178 </span>            : /* Trampolines which we have a lot of */
<span class="lineNum">     179 </span>            : typedef enum {
<span class="lineNum">     180 </span>            :         MONO_AOT_TRAMP_SPECIFIC = 0,
<span class="lineNum">     181 </span>            :         MONO_AOT_TRAMP_STATIC_RGCTX = 1,
<span class="lineNum">     182 </span>            :         MONO_AOT_TRAMP_IMT = 2,
<span class="lineNum">     183 </span>            :         MONO_AOT_TRAMP_GSHAREDVT_ARG = 3,
<span class="lineNum">     184 </span>            :         MONO_AOT_TRAMP_NUM = 4
<span class="lineNum">     185 </span>            : } MonoAotTrampoline;
<span class="lineNum">     186 </span>            : 
<span class="lineNum">     187 </span>            : typedef enum {
<span class="lineNum">     188 </span>            :         MONO_AOT_FILE_FLAG_WITH_LLVM = 1,
<span class="lineNum">     189 </span>            :         MONO_AOT_FILE_FLAG_FULL_AOT = 2,
<span class="lineNum">     190 </span>            :         MONO_AOT_FILE_FLAG_DEBUG = 4,
<span class="lineNum">     191 </span>            :         MONO_AOT_FILE_FLAG_LLVM_THUMB = 8,
<span class="lineNum">     192 </span>            :         MONO_AOT_FILE_FLAG_LLVM_ONLY = 16,
<span class="lineNum">     193 </span>            :         MONO_AOT_FILE_FLAG_SAFEPOINTS = 32,
<span class="lineNum">     194 </span>            :         MONO_AOT_FILE_FLAG_SEPARATE_DATA = 64,
<span class="lineNum">     195 </span>            : } MonoAotFileFlags;
<span class="lineNum">     196 </span>            : 
<span class="lineNum">     197 </span>            : typedef enum {
<span class="lineNum">     198 </span>            :         MONO_AOT_TABLE_BLOB,
<span class="lineNum">     199 </span>            :         MONO_AOT_TABLE_IMAGE_TABLE,
<span class="lineNum">     200 </span>            :         MONO_AOT_TABLE_CLASS_NAME,
<span class="lineNum">     201 </span>            :         MONO_AOT_TABLE_METHOD_INFO_OFFSETS,
<span class="lineNum">     202 </span>            :         MONO_AOT_TABLE_EX_INFO_OFFSETS,
<span class="lineNum">     203 </span>            :         MONO_AOT_TABLE_CLASS_INFO_OFFSETS,
<span class="lineNum">     204 </span>            :         MONO_AOT_TABLE_GOT_INFO_OFFSETS,
<span class="lineNum">     205 </span>            :         MONO_AOT_TABLE_LLVM_GOT_INFO_OFFSETS,
<span class="lineNum">     206 </span>            :         MONO_AOT_TABLE_EXTRA_METHOD_INFO_OFFSETS,
<span class="lineNum">     207 </span>            :         MONO_AOT_TABLE_EXTRA_METHOD_TABLE,
<span class="lineNum">     208 </span>            :         MONO_AOT_TABLE_NUM
<span class="lineNum">     209 </span>            : } MonoAotFileTable;
<span class="lineNum">     210 </span>            : 
<span class="lineNum">     211 </span>            : /* This structure is stored in the AOT file */
<span class="lineNum">     212 </span>            : typedef struct MonoAotFileInfo
<span class="lineNum">     213 </span>            : {
<span class="lineNum">     214 </span>            :         /* The version number of the AOT file format, should match MONO_AOT_FILE_VERSION */
<span class="lineNum">     215 </span>            :         guint32 version;
<span class="lineNum">     216 </span>            :         /* For alignment */
<span class="lineNum">     217 </span>            :         guint32 dummy;
<span class="lineNum">     218 </span>            : 
<span class="lineNum">     219 </span>            :         /* All the pointers should be at the start to avoid alignment problems */
<span class="lineNum">     220 </span>            :         /* Symbols */
<span class="lineNum">     221 </span>            : #define MONO_AOT_FILE_INFO_FIRST_SYMBOL jit_got
<span class="lineNum">     222 </span>            :         /* Global Offset Table for JITted code */
<span class="lineNum">     223 </span>            :         gpointer jit_got;
<span class="lineNum">     224 </span>            :         /* Global Offset Table for LLVM code */
<span class="lineNum">     225 </span>            :         gpointer llvm_got;
<span class="lineNum">     226 </span>            :         /* Mono EH Frame created by llc when using LLVM */
<span class="lineNum">     227 </span>            :         gpointer mono_eh_frame;
<span class="lineNum">     228 </span>            :         /* Points to the get_method () function in the LLVM image or NULL */
<span class="lineNum">     229 </span>            :         gpointer llvm_get_method;
<span class="lineNum">     230 </span>            :         /* Points to the get_unbox_tramp () function in the LLVM image or NULL */
<span class="lineNum">     231 </span>            :         gpointer llvm_get_unbox_tramp;
<span class="lineNum">     232 </span>            :         gpointer jit_code_start;
<span class="lineNum">     233 </span>            :         gpointer jit_code_end;
<span class="lineNum">     234 </span>            :         gpointer method_addresses;
<span class="lineNum">     235 </span>            :         /* Data blob */
<span class="lineNum">     236 </span>            :         gpointer blob;
<span class="lineNum">     237 </span>            :         gpointer class_name_table;
<span class="lineNum">     238 </span>            :         gpointer class_info_offsets;
<span class="lineNum">     239 </span>            :         gpointer method_info_offsets;
<span class="lineNum">     240 </span>            :         gpointer ex_info_offsets;
<span class="lineNum">     241 </span>            :         gpointer extra_method_info_offsets;
<span class="lineNum">     242 </span>            :         gpointer extra_method_table;
<span class="lineNum">     243 </span>            :         gpointer got_info_offsets;
<span class="lineNum">     244 </span>            :         gpointer llvm_got_info_offsets;
<span class="lineNum">     245 </span>            :         gpointer image_table;
<span class="lineNum">     246 </span>            :         gpointer mem_end;
<span class="lineNum">     247 </span>            :         /* The GUID of the assembly which the AOT image was generated from */
<span class="lineNum">     248 </span>            :         gpointer assembly_guid;
<span class="lineNum">     249 </span>            :         /*
<span class="lineNum">     250 </span>            :          * The runtime version string for AOT images generated using 'bind-to-runtime-version',
<span class="lineNum">     251 </span>            :          * NULL otherwise.
<span class="lineNum">     252 </span>            :          */
<span class="lineNum">     253 </span>            :         gpointer runtime_version;
<span class="lineNum">     254 </span>            :         /* Blocks of various kinds of trampolines */
<span class="lineNum">     255 </span>            :         gpointer specific_trampolines;
<span class="lineNum">     256 </span>            :         gpointer static_rgctx_trampolines;
<span class="lineNum">     257 </span>            :         gpointer imt_trampolines;
<span class="lineNum">     258 </span>            :         gpointer gsharedvt_arg_trampolines;
<span class="lineNum">     259 </span>            :         /* In static mode, points to a table of global symbols for trampolines etc */
<span class="lineNum">     260 </span>            :         gpointer globals;
<span class="lineNum">     261 </span>            :         /* Points to a string containing the assembly name*/
<span class="lineNum">     262 </span>            :         gpointer assembly_name;
<span class="lineNum">     263 </span>            :         /* Start of Mono's Program Linkage Table */
<span class="lineNum">     264 </span>            :         gpointer plt;
<span class="lineNum">     265 </span>            :         /* End of Mono's Program Linkage Table */
<span class="lineNum">     266 </span>            :         gpointer plt_end;
<span class="lineNum">     267 </span>            :         gpointer unwind_info;
<span class="lineNum">     268 </span>            :         /* Points to a table mapping methods to their unbox trampolines */
<span class="lineNum">     269 </span>            :         gpointer unbox_trampolines;
<span class="lineNum">     270 </span>            :         /* Points to the end of the previous table */
<span class="lineNum">     271 </span>            :         gpointer unbox_trampolines_end;
<span class="lineNum">     272 </span>            :         /* Points to a table of unbox trampoline addresses/offsets */
<span class="lineNum">     273 </span>            :         gpointer unbox_trampoline_addresses;
<span class="lineNum">     274 </span>            : #define MONO_AOT_FILE_INFO_LAST_SYMBOL unbox_trampoline_addresses
<span class="lineNum">     275 </span>            : 
<span class="lineNum">     276 </span>            :         /* Scalars */
<span class="lineNum">     277 </span>            :         /* The index of the first GOT slot used by the PLT */
<span class="lineNum">     278 </span>            :         guint32 plt_got_offset_base;
<span class="lineNum">     279 </span>            :         /* Number of entries in the GOT */
<span class="lineNum">     280 </span>            :         guint32 got_size;
<span class="lineNum">     281 </span>            :         /* Number of entries in the PLT */
<span class="lineNum">     282 </span>            :         guint32 plt_size;
<span class="lineNum">     283 </span>            :         /* Number of methods */
<span class="lineNum">     284 </span>            :         guint32 nmethods;
<span class="lineNum">     285 </span>            :         /* A union of MonoAotFileFlags */
<span class="lineNum">     286 </span>            :         guint32 flags;
<span class="lineNum">     287 </span>            :         /* Optimization flags used to compile the module */
<span class="lineNum">     288 </span>            :         guint32 opts;
<span class="lineNum">     289 </span>            :         /* SIMD flags used to compile the module */
<span class="lineNum">     290 </span>            :         guint32 simd_opts;
<span class="lineNum">     291 </span>            :         /* Index of the blob entry holding the GC used by this module */
<span class="lineNum">     292 </span>            :         gint32 gc_name_index;
<span class="lineNum">     293 </span>            :         guint32 num_rgctx_fetch_trampolines;
<span class="lineNum">     294 </span>            :         /* These are used for sanity checking object layout problems when cross-compiling */
<span class="lineNum">     295 </span>            :         guint32 double_align, long_align, generic_tramp_num;
<span class="lineNum">     296 </span>            :         /* The page size used by trampoline pages */
<span class="lineNum">     297 </span>            :         guint32 tramp_page_size;
<span class="lineNum">     298 </span>            :         /*
<span class="lineNum">     299 </span>            :          * The number of GOT entries which need to be preinitialized when the
<span class="lineNum">     300 </span>            :          * module is loaded.
<span class="lineNum">     301 </span>            :          */
<span class="lineNum">     302 </span>            :         guint32 nshared_got_entries;
<span class="lineNum">     303 </span>            :         /* The size of the data file, if MONO_AOT_FILE_FLAG_SEPARATE_DATA is set */
<span class="lineNum">     304 </span>            :         guint32 datafile_size;
<span class="lineNum">     305 </span>            : 
<span class="lineNum">     306 </span>            :         /* Arrays */
<span class="lineNum">     307 </span>            :         /* Offsets for tables inside the data file if MONO_AOT_FILE_FLAG_SEPARATE_DATA is set */
<span class="lineNum">     308 </span>            :         // FIXME: Sync with AOT
<span class="lineNum">     309 </span>            :         guint32 table_offsets [MONO_AOT_TABLE_NUM];
<span class="lineNum">     310 </span>            :         /* Number of trampolines */
<span class="lineNum">     311 </span>            :         guint32 num_trampolines [MONO_AOT_TRAMP_NUM];
<span class="lineNum">     312 </span>            :         /* The indexes of the first GOT slots used by the trampolines */
<span class="lineNum">     313 </span>            :         guint32 trampoline_got_offset_base [MONO_AOT_TRAMP_NUM];
<span class="lineNum">     314 </span>            :         /* The size of one trampoline */
<span class="lineNum">     315 </span>            :         guint32 trampoline_size [MONO_AOT_TRAMP_NUM];
<span class="lineNum">     316 </span>            :         /* The offset where the trampolines begin on a trampoline page */
<span class="lineNum">     317 </span>            :         guint32 tramp_page_code_offsets [MONO_AOT_TRAMP_NUM];
<span class="lineNum">     318 </span>            :         /* GUID of aot compilation */
<span class="lineNum">     319 </span>            :         guint8 aotid[16];
<span class="lineNum">     320 </span>            : } MonoAotFileInfo;
<span class="lineNum">     321 </span>            : 
<span class="lineNum">     322 </span>            : /* Number of symbols in the MonoAotFileInfo structure */
<span class="lineNum">     323 </span>            : #define MONO_AOT_FILE_INFO_NUM_SYMBOLS (((G_STRUCT_OFFSET (MonoAotFileInfo, MONO_AOT_FILE_INFO_LAST_SYMBOL) - G_STRUCT_OFFSET (MonoAotFileInfo, MONO_AOT_FILE_INFO_FIRST_SYMBOL)) / sizeof (gpointer)) + 1)
<span class="lineNum">     324 </span>            : 
<span class="lineNum">     325 </span>            : typedef struct
<span class="lineNum">     326 </span>            : {
<span class="lineNum">     327 </span>            :         MonoClass *klass;
<span class="lineNum">     328 </span>            :         MonoMethod *method;
<span class="lineNum">     329 </span>            : } MonoClassMethodPair;
<span class="lineNum">     330 </span>            : 
<span class="lineNum">     331 </span>            : typedef struct
<span class="lineNum">     332 </span>            : {
<span class="lineNum">     333 </span>            :         MonoClass *klass;
<span class="lineNum">     334 </span>            :         MonoMethod *method;
<span class="lineNum">     335 </span>            :         gboolean is_virtual;
<span class="lineNum">     336 </span>            : } MonoDelegateClassMethodPair;
<span class="lineNum">     337 </span>            : 
<span class="lineNum">     338 </span>            : /* Per-domain information maintained by the JIT */
<span class="lineNum">     339 </span>            : typedef struct
<span class="lineNum">     340 </span>            : {
<span class="lineNum">     341 </span>            :         /* Maps MonoMethod's to a GSList of GOT slot addresses pointing to its code */
<span class="lineNum">     342 </span>            :         GHashTable *jump_target_got_slot_hash;
<span class="lineNum">     343 </span>            :         GHashTable *jump_target_hash;
<span class="lineNum">     344 </span>            :         /* Maps methods/klasses to the address of the given type of trampoline */
<span class="lineNum">     345 </span>            :         GHashTable *class_init_trampoline_hash;
<span class="lineNum">     346 </span>            :         GHashTable *jump_trampoline_hash;
<span class="lineNum">     347 </span>            :         GHashTable *jit_trampoline_hash;
<span class="lineNum">     348 </span>            :         GHashTable *delegate_trampoline_hash;
<span class="lineNum">     349 </span>            :         /* Maps ClassMethodPair -&gt; MonoDelegateTrampInfo */
<span class="lineNum">     350 </span>            :         GHashTable *static_rgctx_trampoline_hash;
<span class="lineNum">     351 </span>            :         GHashTable *llvm_vcall_trampoline_hash;
<span class="lineNum">     352 </span>            :         /* maps MonoMethod -&gt; MonoJitDynamicMethodInfo */
<span class="lineNum">     353 </span>            :         GHashTable *dynamic_code_hash;
<span class="lineNum">     354 </span>            :         GHashTable *method_code_hash;
<span class="lineNum">     355 </span>            :         /* Maps methods to a RuntimeInvokeInfo structure, protected by the associated MonoDomain lock */
<span class="lineNum">     356 </span>            :         MonoConcurrentHashTable *runtime_invoke_hash;
<span class="lineNum">     357 </span>            :         /* Maps MonoMethod to a GPtrArray containing sequence point locations */
<span class="lineNum">     358 </span>            :         /* Protected by the domain lock */
<span class="lineNum">     359 </span>            :         GHashTable *seq_points;
<span class="lineNum">     360 </span>            :         /* Debugger agent data */
<span class="lineNum">     361 </span>            :         gpointer agent_info;
<span class="lineNum">     362 </span>            :         /* Maps MonoMethod to an arch-specific structure */
<span class="lineNum">     363 </span>            :         GHashTable *arch_seq_points;
<span class="lineNum">     364 </span>            :         /* Maps a GSharedVtTrampInfo structure to a trampoline address */
<span class="lineNum">     365 </span>            :         GHashTable *gsharedvt_arg_tramp_hash;
<span class="lineNum">     366 </span>            :         /* memcpy/bzero methods specialized for small constant sizes */
<span class="lineNum">     367 </span>            :         gpointer *memcpy_addr [17];
<span class="lineNum">     368 </span>            :         gpointer *bzero_addr [17];
<span class="lineNum">     369 </span>            :         gpointer llvm_module;
<span class="lineNum">     370 </span>            :         /* Maps MonoMethod -&gt; GSlist of addresses */
<span class="lineNum">     371 </span>            :         GHashTable *llvm_jit_callees;
<span class="lineNum">     372 </span>            : } MonoJitDomainInfo;
<span class="lineNum">     373 </span>            : 
<span class="lineNum">     374 </span>            : typedef struct {
<span class="lineNum">     375 </span>            :         MonoJitInfo *ji;
<span class="lineNum">     376 </span>            :         MonoCodeManager *code_mp;
<span class="lineNum">     377 </span>            : } MonoJitDynamicMethodInfo;
<span class="lineNum">     378 </span>            : 
<span class="lineNum">     379 </span>            : /* An extension of MonoGenericParamFull used in generic sharing */
<span class="lineNum">     380 </span>            : typedef struct {
<span class="lineNum">     381 </span>            :         MonoGenericParamFull param;
<span class="lineNum">     382 </span>            :         MonoGenericParam *parent;
<span class="lineNum">     383 </span>            : } MonoGSharedGenericParam;
<span class="lineNum">     384 </span>            : 
<span class="lineNum">     385 </span>            : #define domain_jit_info(domain) ((MonoJitDomainInfo*)((domain)-&gt;runtime_info))
<span class="lineNum">     386 </span>            : 
<span class="lineNum">     387 </span>            : /* Contains a list of ips which needs to be patched when a method is compiled */
<span class="lineNum">     388 </span>            : typedef struct {
<span class="lineNum">     389 </span>            :         GSList *list;
<span class="lineNum">     390 </span>            : } MonoJumpList;
<span class="lineNum">     391 </span>            : 
<span class="lineNum">     392 </span>            : /* Arch-specific */
<span class="lineNum">     393 </span>            : typedef struct {
<span class="lineNum">     394 </span>            :         int dummy;
<span class="lineNum">     395 </span>            : } MonoDynCallInfo;
<span class="lineNum">     396 </span>            : 
<span class="lineNum">     397 </span>            : /*
<span class="lineNum">     398 </span>            :  * Information about a stack frame.
<span class="lineNum">     399 </span>            :  * FIXME This typedef exists only to avoid tons of code rewriting
<span class="lineNum">     400 </span>            :  */
<span class="lineNum">     401 </span>            : typedef MonoStackFrameInfo StackFrameInfo;
<span class="lineNum">     402 </span>            : 
<span class="lineNum">     403 </span>            : #if 0
<span class="lineNum">     404 </span>            : #define mono_bitset_foreach_bit(set,b,n) \
<span class="lineNum">     405 </span>            :         for (b = 0; b &lt; n; b++)\
<span class="lineNum">     406 </span>            :                 if (mono_bitset_test_fast(set,b))
<span class="lineNum">     407 </span>            : #else
<span class="lineNum">     408 </span>            : #define mono_bitset_foreach_bit(set,b,n) \
<span class="lineNum">     409 </span>            :         for (b = mono_bitset_find_start (set); b &lt; n &amp;&amp; b &gt;= 0; b = mono_bitset_find_first (set, b))
<span class="lineNum">     410 </span>            : #endif
<span class="lineNum">     411 </span>            : 
<span class="lineNum">     412 </span>            : /*
<span class="lineNum">     413 </span>            :  * Pull the list of opcodes
<span class="lineNum">     414 </span>            :  */
<span class="lineNum">     415 </span>            : #define OPDEF(a,b,c,d,e,f,g,h,i,j) \
<span class="lineNum">     416 </span>            :         a = i,
<span class="lineNum">     417 </span>            : 
<span class="lineNum">     418 </span>            : enum {
<span class="lineNum">     419 </span>            : #include &quot;mono/cil/opcode.def&quot;
<span class="lineNum">     420 </span>            :         CEE_LASTOP
<span class="lineNum">     421 </span>            : };
<span class="lineNum">     422 </span>            : #undef OPDEF
<span class="lineNum">     423 </span>            : 
<span class="lineNum">     424 </span>            : #define MONO_VARINFO(cfg,varnum) (&amp;(cfg)-&gt;vars [varnum])
<span class="lineNum">     425 </span>            : 
<span class="lineNum">     426 </span>            : #define MONO_INST_NULLIFY_SREGS(dest) do {                              \
<span class="lineNum">     427 </span>            :                 (dest)-&gt;sreg1 = (dest)-&gt;sreg2 = (dest)-&gt;sreg3 = -1;    \
<span class="lineNum">     428 </span>            :         } while (0)
<span class="lineNum">     429 </span>            : 
<span class="lineNum">     430 </span>            : #define MONO_INST_NEW(cfg,dest,op) do { \
<span class="lineNum">     431 </span>            :                 (dest) = (MonoInst *)mono_mempool_alloc0 ((cfg)-&gt;mempool, sizeof (MonoInst));        \
<span class="lineNum">     432 </span>            :                 (dest)-&gt;opcode = (op);       \
<span class="lineNum">     433 </span>            :                 (dest)-&gt;dreg = -1;                       \
<span class="lineNum">     434 </span>            :                 MONO_INST_NULLIFY_SREGS ((dest));           \
<span class="lineNum">     435 </span>            :         (dest)-&gt;cil_code = (cfg)-&gt;ip;  \
<span class="lineNum">     436 </span>            :         } while (0)
<span class="lineNum">     437 </span>            : 
<span class="lineNum">     438 </span>            : #define MONO_INST_NEW_CALL(cfg,dest,op) do {    \
<span class="lineNum">     439 </span>            :                 (dest) = (MonoCallInst *)mono_mempool_alloc0 ((cfg)-&gt;mempool, sizeof (MonoCallInst));        \
<span class="lineNum">     440 </span>            :                 (dest)-&gt;inst.opcode = (op);  \
<span class="lineNum">     441 </span>            :                 (dest)-&gt;inst.dreg = -1;                                      \
<span class="lineNum">     442 </span>            :                 MONO_INST_NULLIFY_SREGS (&amp;(dest)-&gt;inst);         \
<span class="lineNum">     443 </span>            :         (dest)-&gt;inst.cil_code = (cfg)-&gt;ip;  \
<span class="lineNum">     444 </span>            :         } while (0)
<span class="lineNum">     445 </span>            : 
<span class="lineNum">     446 </span>            : #define MONO_ADD_INS(b,inst) do {       \
<span class="lineNum">     447 </span>            :                 if ((b)-&gt;last_ins) { \
<span class="lineNum">     448 </span>            :                         (b)-&gt;last_ins-&gt;next = (inst);     \
<span class="lineNum">     449 </span>            :             (inst)-&gt;prev = (b)-&gt;last_ins;   \
<span class="lineNum">     450 </span>            :                         (b)-&gt;last_ins = (inst);      \
<span class="lineNum">     451 </span>            :                 } else {        \
<span class="lineNum">     452 </span>            :                         (b)-&gt;code = (b)-&gt;last_ins = (inst);       \
<span class="lineNum">     453 </span>            :                 }       \
<span class="lineNum">     454 </span>            :         } while (0)
<span class="lineNum">     455 </span>            : 
<span class="lineNum">     456 </span>            : #define NULLIFY_INS(ins) do { \
<span class="lineNum">     457 </span>            :         (ins)-&gt;opcode = OP_NOP; \
<span class="lineNum">     458 </span>            :         (ins)-&gt;dreg = -1;                            \
<span class="lineNum">     459 </span>            :         MONO_INST_NULLIFY_SREGS ((ins));                \
<span class="lineNum">     460 </span>            :     } while (0)
<span class="lineNum">     461 </span>            : 
<span class="lineNum">     462 </span>            : /* Remove INS from BB */
<span class="lineNum">     463 </span>            : #define MONO_REMOVE_INS(bb,ins) do { \
<span class="lineNum">     464 </span>            :         if ((ins)-&gt;prev) \
<span class="lineNum">     465 </span>            :             (ins)-&gt;prev-&gt;next = (ins)-&gt;next; \
<span class="lineNum">     466 </span>            :         if ((ins)-&gt;next) \
<span class="lineNum">     467 </span>            :             (ins)-&gt;next-&gt;prev = (ins)-&gt;prev; \
<span class="lineNum">     468 </span>            :         if ((bb)-&gt;code == (ins)) \
<span class="lineNum">     469 </span>            :             (bb)-&gt;code = (ins)-&gt;next; \
<span class="lineNum">     470 </span>            :         if ((bb)-&gt;last_ins == (ins)) \
<span class="lineNum">     471 </span>            :             (bb)-&gt;last_ins = (ins)-&gt;prev; \
<span class="lineNum">     472 </span>            :     } while (0)
<span class="lineNum">     473 </span>            : 
<span class="lineNum">     474 </span>            : /* Remove INS from BB and nullify it */
<span class="lineNum">     475 </span>            : #define MONO_DELETE_INS(bb,ins) do { \
<span class="lineNum">     476 </span>            :         MONO_REMOVE_INS ((bb), (ins)); \
<span class="lineNum">     477 </span>            :         NULLIFY_INS ((ins)); \
<span class="lineNum">     478 </span>            :     } while (0)
<span class="lineNum">     479 </span>            : 
<span class="lineNum">     480 </span>            : /* 
<span class="lineNum">     481 </span>            :  * this is used to determine when some branch optimizations are possible: we exclude FP compares
<span class="lineNum">     482 </span>            :  * because they have weird semantics with NaNs.
<span class="lineNum">     483 </span>            :  */
<span class="lineNum">     484 </span>            : #define MONO_IS_COND_BRANCH_OP(ins) (((ins)-&gt;opcode &gt;= OP_LBEQ &amp;&amp; (ins)-&gt;opcode &lt;= OP_LBLT_UN) || ((ins)-&gt;opcode &gt;= OP_FBEQ &amp;&amp; (ins)-&gt;opcode &lt;= OP_FBLT_UN) || ((ins)-&gt;opcode &gt;= OP_IBEQ &amp;&amp; (ins)-&gt;opcode &lt;= OP_IBLT_UN))
<span class="lineNum">     485 </span>            : #define MONO_IS_COND_BRANCH_NOFP(ins) (MONO_IS_COND_BRANCH_OP(ins) &amp;&amp; !(((ins)-&gt;opcode &gt;= OP_FBEQ) &amp;&amp; ((ins)-&gt;opcode &lt;= OP_FBLT_UN)) &amp;&amp; (!(ins)-&gt;inst_left || (ins)-&gt;inst_left-&gt;inst_left-&gt;type != STACK_R8))
<span class="lineNum">     486 </span>            : 
<span class="lineNum">     487 </span>            : #define MONO_IS_BRANCH_OP(ins) (MONO_IS_COND_BRANCH_OP(ins) || ((ins)-&gt;opcode == OP_BR) || ((ins)-&gt;opcode == OP_BR_REG) || ((ins)-&gt;opcode == OP_SWITCH))
<span class="lineNum">     488 </span>            : 
<span class="lineNum">     489 </span>            : #define MONO_IS_COND_EXC(ins) ((((ins)-&gt;opcode &gt;= OP_COND_EXC_EQ) &amp;&amp; ((ins)-&gt;opcode &lt;= OP_COND_EXC_LT_UN)) || (((ins)-&gt;opcode &gt;= OP_COND_EXC_IEQ) &amp;&amp; ((ins)-&gt;opcode &lt;= OP_COND_EXC_ILT_UN)))
<span class="lineNum">     490 </span>            : 
<span class="lineNum">     491 </span>            : #define MONO_IS_SETCC(ins) ((((ins)-&gt;opcode &gt;= OP_CEQ) &amp;&amp; ((ins)-&gt;opcode &lt;= OP_CLT_UN)) || (((ins)-&gt;opcode &gt;= OP_ICEQ) &amp;&amp; ((ins)-&gt;opcode &lt;= OP_ICLE_UN)) || (((ins)-&gt;opcode &gt;= OP_LCEQ) &amp;&amp; ((ins)-&gt;opcode &lt;= OP_LCLT_UN)) || (((ins)-&gt;opcode &gt;= OP_FCEQ) &amp;&amp; ((ins)-&gt;opcode &lt;= OP_FCLT_UN)))
<span class="lineNum">     492 </span>            : 
<span class="lineNum">     493 </span>            : #define MONO_HAS_CUSTOM_EMULATION(ins) (((ins)-&gt;opcode &gt;= OP_FBEQ &amp;&amp; (ins)-&gt;opcode &lt;= OP_FBLT_UN) || ((ins)-&gt;opcode &gt;= OP_FCEQ &amp;&amp; (ins)-&gt;opcode &lt;= OP_FCLT_UN))
<span class="lineNum">     494 </span>            : 
<span class="lineNum">     495 </span>            : #define MONO_IS_LOAD_MEMBASE(ins) (((ins)-&gt;opcode &gt;= OP_LOAD_MEMBASE &amp;&amp; (ins)-&gt;opcode &lt;= OP_LOADV_MEMBASE) || ((ins)-&gt;opcode &gt;= OP_ATOMIC_LOAD_I1 &amp;&amp; (ins)-&gt;opcode &lt;= OP_ATOMIC_LOAD_R8))
<span class="lineNum">     496 </span>            : #define MONO_IS_STORE_MEMBASE(ins) (((ins)-&gt;opcode &gt;= OP_STORE_MEMBASE_REG &amp;&amp; (ins)-&gt;opcode &lt;= OP_STOREV_MEMBASE) || ((ins)-&gt;opcode &gt;= OP_ATOMIC_STORE_I1 &amp;&amp; (ins)-&gt;opcode &lt;= OP_ATOMIC_STORE_R8))
<span class="lineNum">     497 </span>            : #define MONO_IS_STORE_MEMINDEX(ins) (((ins)-&gt;opcode &gt;= OP_STORE_MEMINDEX) &amp;&amp; ((ins)-&gt;opcode &lt;= OP_STORER8_MEMINDEX))
<span class="lineNum">     498 </span>            : 
<span class="lineNum">     499 </span>            : // OP_DYN_CALL is not a MonoCallInst
<span class="lineNum">     500 </span>            : #define MONO_IS_CALL(ins) (((ins-&gt;opcode &gt;= OP_VOIDCALL) &amp;&amp; (ins-&gt;opcode &lt;= OP_VCALL2_MEMBASE)) || (ins-&gt;opcode == OP_TAILCALL))
<span class="lineNum">     501 </span>            : 
<span class="lineNum">     502 </span>            : #define MONO_IS_JUMP_TABLE(ins) (((ins)-&gt;opcode == OP_JUMP_TABLE) ? TRUE : ((((ins)-&gt;opcode == OP_AOTCONST) &amp;&amp; (ins-&gt;inst_i1 == (gpointer)MONO_PATCH_INFO_SWITCH)) ? TRUE : ((ins)-&gt;opcode == OP_SWITCH) ? TRUE : ((((ins)-&gt;opcode == OP_GOT_ENTRY) &amp;&amp; ((ins)-&gt;inst_right-&gt;inst_i1 == (gpointer)MONO_PATCH_INFO_SWITCH)) ? TRUE : FALSE)))
<span class="lineNum">     503 </span>            : 
<span class="lineNum">     504 </span>            : #define MONO_JUMP_TABLE_FROM_INS(ins) (((ins)-&gt;opcode == OP_JUMP_TABLE) ? (ins)-&gt;inst_p0 : (((ins)-&gt;opcode == OP_AOTCONST) &amp;&amp; (ins-&gt;inst_i1 == (gpointer)MONO_PATCH_INFO_SWITCH) ? (ins)-&gt;inst_p0 : (((ins)-&gt;opcode == OP_SWITCH) ? (ins)-&gt;inst_p0 : ((((ins)-&gt;opcode == OP_GOT_ENTRY) &amp;&amp; ((ins)-&gt;inst_right-&gt;inst_i1 == (gpointer)MONO_PATCH_INFO_SWITCH)) ? (ins)-&gt;inst_right-&gt;inst_p0 : NULL))))
<span class="lineNum">     505 </span>            : 
<span class="lineNum">     506 </span>            : /* FIXME: Add more instructions */
<span class="lineNum">     507 </span>            : /* INEG sets the condition codes, and the OP_LNEG decomposition depends on this on x86 */
<span class="lineNum">     508 </span>            : #define MONO_INS_HAS_NO_SIDE_EFFECT(ins) (MONO_IS_MOVE (ins) || (ins-&gt;opcode == OP_ICONST) || (ins-&gt;opcode == OP_I8CONST) || MONO_IS_ZERO (ins) || (ins-&gt;opcode == OP_ADD_IMM) || (ins-&gt;opcode == OP_R8CONST) || (ins-&gt;opcode == OP_LADD_IMM) || (ins-&gt;opcode == OP_ISUB_IMM) || (ins-&gt;opcode == OP_IADD_IMM) || (ins-&gt;opcode == OP_LNEG) || (ins-&gt;opcode == OP_ISUB) || (ins-&gt;opcode == OP_CMOV_IGE) || (ins-&gt;opcode == OP_ISHL_IMM) || (ins-&gt;opcode == OP_ISHR_IMM) || (ins-&gt;opcode == OP_ISHR_UN_IMM) || (ins-&gt;opcode == OP_IAND_IMM) || (ins-&gt;opcode == OP_ICONV_TO_U1) || (ins-&gt;opcode == OP_ICONV_TO_I1) || (ins-&gt;opcode == OP_SEXT_I4) || (ins-&gt;opcode == OP_LCONV_TO_U1) || (ins-&gt;opcode == OP_ICONV_TO_U2) || (ins-&gt;opcode == OP_ICONV_TO_I2) || (ins-&gt;opcode == OP_LCONV_TO_I2) || (ins-&gt;opcode == OP_LDADDR) || (ins-&gt;opcode == OP_PHI) || (ins-&gt;opcode == OP_NOP) || (ins-&gt;opcode == OP_ZEXT_I4) || (ins-&gt;opcode == OP_NOT_NULL) || (ins-&gt;opcode == OP_IL_SEQ_POINT) || (ins-&gt;opcode == OP_XZERO))
<span class="lineNum">     509 </span>            : 
<span class="lineNum">     510 </span>            : #define MONO_INS_IS_PCONST_NULL(ins) ((ins)-&gt;opcode == OP_PCONST &amp;&amp; (ins)-&gt;inst_p0 == 0)
<span class="lineNum">     511 </span>            : 
<span class="lineNum">     512 </span>            : #define MONO_METHOD_IS_FINAL(m) (((m)-&gt;flags &amp; METHOD_ATTRIBUTE_FINAL) || ((m)-&gt;klass &amp;&amp; (mono_class_get_flags ((m)-&gt;klass) &amp; TYPE_ATTRIBUTE_SEALED)))
<span class="lineNum">     513 </span>            : 
<span class="lineNum">     514 </span>            : 
<span class="lineNum">     515 </span>            : #ifdef MONO_ARCH_SIMD_INTRINSICS
<span class="lineNum">     516 </span>            : 
<span class="lineNum">     517 </span>            : #define MONO_IS_PHI(ins) (((ins)-&gt;opcode == OP_PHI) || ((ins)-&gt;opcode == OP_FPHI) || ((ins)-&gt;opcode == OP_VPHI)  || ((ins)-&gt;opcode == OP_XPHI))
<span class="lineNum">     518 </span>            : #define MONO_IS_MOVE(ins) (((ins)-&gt;opcode == OP_MOVE) || ((ins)-&gt;opcode == OP_FMOVE) || ((ins)-&gt;opcode == OP_VMOVE) || ((ins)-&gt;opcode == OP_XMOVE) || ((ins)-&gt;opcode == OP_RMOVE))
<span class="lineNum">     519 </span>            : #define MONO_IS_NON_FP_MOVE(ins) (((ins)-&gt;opcode == OP_MOVE) || ((ins)-&gt;opcode == OP_VMOVE) || ((ins)-&gt;opcode == OP_XMOVE))
<span class="lineNum">     520 </span>            : #define MONO_IS_REAL_MOVE(ins) (((ins)-&gt;opcode == OP_MOVE) || ((ins)-&gt;opcode == OP_FMOVE) || ((ins)-&gt;opcode == OP_XMOVE) || ((ins)-&gt;opcode == OP_RMOVE))
<span class="lineNum">     521 </span>            : #define MONO_IS_ZERO(ins) (((ins)-&gt;opcode == OP_VZERO) || ((ins)-&gt;opcode == OP_XZERO))
<span class="lineNum">     522 </span>            : 
<span class="lineNum">     523 </span>            : #define MONO_CLASS_IS_SIMD(cfg, klass) (((cfg)-&gt;opt &amp; MONO_OPT_SIMD) &amp;&amp; (klass)-&gt;simd_type)
<span class="lineNum">     524 </span>            : 
<span class="lineNum">     525 </span>            : #else
<span class="lineNum">     526 </span>            : 
<span class="lineNum">     527 </span>            : #define MONO_IS_PHI(ins) (((ins)-&gt;opcode == OP_PHI) || ((ins)-&gt;opcode == OP_FPHI) || ((ins)-&gt;opcode == OP_VPHI))
<span class="lineNum">     528 </span>            : #define MONO_IS_MOVE(ins) (((ins)-&gt;opcode == OP_MOVE) || ((ins)-&gt;opcode == OP_FMOVE) || ((ins)-&gt;opcode == OP_VMOVE) || ((ins)-&gt;opcode == OP_RMOVE))
<span class="lineNum">     529 </span>            : #define MONO_IS_NON_FP_MOVE(ins) (((ins)-&gt;opcode == OP_MOVE) || ((ins)-&gt;opcode == OP_VMOVE))
<span class="lineNum">     530 </span>            : /*A real MOVE is one that isn't decomposed such as a VMOVE or LMOVE*/
<span class="lineNum">     531 </span>            : #define MONO_IS_REAL_MOVE(ins) (((ins)-&gt;opcode == OP_MOVE) || ((ins)-&gt;opcode == OP_FMOVE) || ((ins)-&gt;opcode == OP_RMOVE))
<span class="lineNum">     532 </span>            : #define MONO_IS_ZERO(ins) ((ins)-&gt;opcode == OP_VZERO)
<span class="lineNum">     533 </span>            : 
<span class="lineNum">     534 </span>            : #define MONO_CLASS_IS_SIMD(cfg, klass) (0)
<span class="lineNum">     535 </span>            : 
<span class="lineNum">     536 </span>            : #endif
<span class="lineNum">     537 </span>            : 
<span class="lineNum">     538 </span>            : typedef struct MonoInstList MonoInstList;
<span class="lineNum">     539 </span>            : typedef struct MonoInst MonoInst;
<span class="lineNum">     540 </span>            : typedef struct MonoCallInst MonoCallInst;
<span class="lineNum">     541 </span>            : typedef struct MonoCallArgParm MonoCallArgParm;
<span class="lineNum">     542 </span>            : typedef struct MonoMethodVar MonoMethodVar;
<span class="lineNum">     543 </span>            : typedef struct MonoBasicBlock MonoBasicBlock;
<span class="lineNum">     544 </span>            : typedef struct MonoLMF MonoLMF;
<span class="lineNum">     545 </span>            : typedef struct MonoSpillInfo MonoSpillInfo;
<span class="lineNum">     546 </span>            : typedef struct MonoTraceSpec MonoTraceSpec;
<span class="lineNum">     547 </span>            : 
<span class="lineNum">     548 </span>            : extern MonoTraceSpec *mono_jit_trace_calls;
<span class="lineNum">     549 </span>            : extern gboolean mono_break_on_exc;
<span class="lineNum">     550 </span>            : extern int mono_exc_esp_offset;
<span class="lineNum">     551 </span>            : extern gboolean mono_compile_aot;
<span class="lineNum">     552 </span>            : extern gboolean mono_aot_only;
<span class="lineNum">     553 </span>            : extern gboolean mono_llvm_only;
<span class="lineNum">     554 </span>            : extern MonoAotMode mono_aot_mode;
<span class="lineNum">     555 </span>            : extern MonoMethodDesc *mono_inject_async_exc_method;
<span class="lineNum">     556 </span>            : extern int mono_inject_async_exc_pos;
<span class="lineNum">     557 </span>            : extern MonoMethodDesc *mono_break_at_bb_method;
<span class="lineNum">     558 </span>            : extern int mono_break_at_bb_bb_num;
<span class="lineNum">     559 </span>            : extern gboolean mono_verify_all;
<span class="lineNum">     560 </span>            : extern gboolean mono_do_x86_stack_align;
<span class="lineNum">     561 </span>            : extern const char *mono_build_date;
<span class="lineNum">     562 </span>            : extern gboolean mono_do_signal_chaining;
<span class="lineNum">     563 </span>            : extern gboolean mono_do_crash_chaining;
<span class="lineNum">     564 </span>            : extern MONO_API gboolean mono_use_llvm;
<span class="lineNum">     565 </span>            : extern MONO_API gboolean mono_use_interpreter;
<span class="lineNum">     566 </span>            : extern gboolean mono_do_single_method_regression;
<span class="lineNum">     567 </span>            : extern guint32 mono_single_method_regression_opt;
<span class="lineNum">     568 </span>            : extern MonoMethod *mono_current_single_method;
<span class="lineNum">     569 </span>            : extern GSList *mono_single_method_list;
<span class="lineNum">     570 </span>            : extern GHashTable *mono_single_method_hash;
<span class="lineNum">     571 </span>            : extern gboolean mono_using_xdebug;
<span class="lineNum">     572 </span>            : extern int mini_verbose;
<span class="lineNum">     573 </span>            : extern int valgrind_register;
<span class="lineNum">     574 </span>            : extern GList* mono_aot_paths;
<span class="lineNum">     575 </span>            : 
<span class="lineNum">     576 </span>            : #define INS_INFO(opcode) (&amp;ins_info [((opcode) - OP_START - 1) * 4])
<span class="lineNum">     577 </span>            : 
<span class="lineNum">     578 </span>            : extern const char ins_info[];
<span class="lineNum">     579 </span>            : extern const gint8 ins_sreg_counts [];
<span class="lineNum">     580 </span>            : 
<span class="lineNum">     581 </span>            : #ifndef DISABLE_JIT
<span class="lineNum">     582 </span>            : #define mono_inst_get_num_src_registers(ins) (ins_sreg_counts [(ins)-&gt;opcode - OP_START - 1])
<span class="lineNum">     583 </span>            : #else
<span class="lineNum">     584 </span>            : #define mono_inst_get_num_src_registers(ins) 0
<span class="lineNum">     585 </span>            : #endif
<span class="lineNum">     586 </span>            : 
<span class="lineNum">     587 </span>            : #define mono_inst_get_src_registers(ins, regs) (((regs) [0] = (ins)-&gt;sreg1), ((regs) [1] = (ins)-&gt;sreg2), ((regs) [2] = (ins)-&gt;sreg3), mono_inst_get_num_src_registers ((ins)))
<span class="lineNum">     588 </span>            : 
<span class="lineNum">     589 </span>            : #define MONO_BB_FOR_EACH_INS(bb, ins) for ((ins) = (bb)-&gt;code; (ins); (ins) = (ins)-&gt;next)
<span class="lineNum">     590 </span>            : 
<span class="lineNum">     591 </span>            : #define MONO_BB_FOR_EACH_INS_SAFE(bb, n, ins) for ((ins) = (bb)-&gt;code, n = (ins) ? (ins)-&gt;next : NULL; (ins); (ins) = (n), (n) = (ins) ? (ins)-&gt;next : NULL)
<span class="lineNum">     592 </span>            : 
<span class="lineNum">     593 </span>            : #define MONO_BB_FOR_EACH_INS_REVERSE_SAFE(bb, p, ins) for ((ins) = (bb)-&gt;last_ins, p = (ins) ? (ins)-&gt;prev : NULL; (ins); (ins) = (p), (p) = (ins) ? (ins)-&gt;prev : NULL)
<span class="lineNum">     594 </span>            : 
<span class="lineNum">     595 </span>            : #define mono_bb_first_ins(bb) (bb)-&gt;code
<span class="lineNum">     596 </span>            : 
<span class="lineNum">     597 </span>            : struct MonoSpillInfo {
<span class="lineNum">     598 </span>            :         int offset;
<span class="lineNum">     599 </span>            : };
<span class="lineNum">     600 </span>            : 
<span class="lineNum">     601 </span>            : /*
<span class="lineNum">     602 </span>            :  * Information about a call site for the GC map creation code
<span class="lineNum">     603 </span>            :  */
<span class="lineNum">     604 </span>            : typedef struct {
<span class="lineNum">     605 </span>            :         /* The next offset after the call instruction */
<span class="lineNum">     606 </span>            :         int pc_offset;
<span class="lineNum">     607 </span>            :         /* The basic block containing the call site */
<span class="lineNum">     608 </span>            :         MonoBasicBlock *bb;
<span class="lineNum">     609 </span>            :         /* 
<span class="lineNum">     610 </span>            :          * The set of variables live at the call site.
<span class="lineNum">     611 </span>            :          * Has length cfg-&gt;num_varinfo in bits.
<span class="lineNum">     612 </span>            :          */
<span class="lineNum">     613 </span>            :         guint8 *liveness;
<span class="lineNum">     614 </span>            :         /*
<span class="lineNum">     615 </span>            :          * List of OP_GC_PARAM_SLOT_LIVENESS_DEF instructions defining the param slots
<span class="lineNum">     616 </span>            :          * used by this call.
<span class="lineNum">     617 </span>            :          */
<span class="lineNum">     618 </span>            :         GSList *param_slots;
<span class="lineNum">     619 </span>            : } GCCallSite;
<span class="lineNum">     620 </span>            : 
<span class="lineNum">     621 </span>            : /*
<span class="lineNum">     622 </span>            :  * The IR-level extended basic block.  
<span class="lineNum">     623 </span>            :  *
<span class="lineNum">     624 </span>            :  * A basic block can have multiple exits just fine, as long as the point of
<span class="lineNum">     625 </span>            :  * 'departure' is the last instruction in the basic block. Extended basic
<span class="lineNum">     626 </span>            :  * blocks, on the other hand, may have instructions that leave the block
<span class="lineNum">     627 </span>            :  * midstream. The important thing is that they cannot be _entered_
<span class="lineNum">     628 </span>            :  * midstream, ie, execution of a basic block (or extened bb) always start
<span class="lineNum">     629 </span>            :  * at the beginning of the block, never in the middle.
<span class="lineNum">     630 </span>            :  */
<span class="lineNum">     631 </span>            : struct MonoBasicBlock {
<span class="lineNum">     632 </span>            :         MonoInst *last_ins;
<span class="lineNum">     633 </span>            : 
<span class="lineNum">     634 </span>            :         /* the next basic block in the order it appears in IL */
<span class="lineNum">     635 </span>            :         MonoBasicBlock *next_bb;
<span class="lineNum">     636 </span>            : 
<span class="lineNum">     637 </span>            :         /*
<span class="lineNum">     638 </span>            :          * Before instruction selection it is the first tree in the
<span class="lineNum">     639 </span>            :          * forest and the first item in the list of trees. After
<span class="lineNum">     640 </span>            :          * instruction selection it is the first instruction and the
<span class="lineNum">     641 </span>            :          * first item in the list of instructions.
<span class="lineNum">     642 </span>            :          */
<span class="lineNum">     643 </span>            :         MonoInst *code;
<span class="lineNum">     644 </span>            : 
<span class="lineNum">     645 </span>            :         /* unique block number identification */
<span class="lineNum">     646 </span>            :         gint32 block_num;
<span class="lineNum">     647 </span>            :         
<span class="lineNum">     648 </span>            :         gint32 dfn;
<span class="lineNum">     649 </span>            : 
<span class="lineNum">     650 </span>            :         /* Basic blocks: incoming and outgoing counts and pointers */
<span class="lineNum">     651 </span>            :         /* Each bb should only appear once in each array */
<span class="lineNum">     652 </span>            :         gint16 out_count, in_count;
<span class="lineNum">     653 </span>            :         MonoBasicBlock **in_bb;
<span class="lineNum">     654 </span>            :         MonoBasicBlock **out_bb;
<span class="lineNum">     655 </span>            : 
<span class="lineNum">     656 </span>            :         /* Points to the start of the CIL code that initiated this BB */
<span class="lineNum">     657 </span>            :         unsigned char* cil_code;
<span class="lineNum">     658 </span>            : 
<span class="lineNum">     659 </span>            :         /* Length of the CIL block */
<span class="lineNum">     660 </span>            :         gint32 cil_length;
<span class="lineNum">     661 </span>            : 
<span class="lineNum">     662 </span>            :         /* The offset of the generated code, used for fixups */
<span class="lineNum">     663 </span>            :         int native_offset;
<span class="lineNum">     664 </span>            :         /* The length of the generated code, doesn't include alignment padding */
<span class="lineNum">     665 </span>            :         int native_length;
<span class="lineNum">     666 </span>            :         /* The real native offset, which includes alignment padding too */
<span class="lineNum">     667 </span>            :         int real_native_offset;
<span class="lineNum">     668 </span>            :         int max_offset;
<span class="lineNum">     669 </span>            :         int max_length;
<span class="lineNum">     670 </span>            : 
<span class="lineNum">     671 </span>            :         /* Visited and reachable flags */
<span class="lineNum">     672 </span>            :         guint32 flags;
<span class="lineNum">     673 </span>            : 
<span class="lineNum">     674 </span>            :         /*
<span class="lineNum">     675 </span>            :          * SSA and loop based flags
<span class="lineNum">     676 </span>            :          */
<span class="lineNum">     677 </span>            :         MonoBitSet *dominators;
<span class="lineNum">     678 </span>            :         MonoBitSet *dfrontier;
<span class="lineNum">     679 </span>            :         MonoBasicBlock *idom;
<span class="lineNum">     680 </span>            :         GSList *dominated;
<span class="lineNum">     681 </span>            :         /* fast dominator algorithm */
<span class="lineNum">     682 </span>            :         MonoBasicBlock *df_parent, *ancestor, *child, *label;
<span class="lineNum">     683 </span>            :         int size, sdom, idomn;
<span class="lineNum">     684 </span>            :         
<span class="lineNum">     685 </span>            :         /* loop nesting and recognition */
<span class="lineNum">     686 </span>            :         GList *loop_blocks;
<span class="lineNum">     687 </span>            :         gint8  nesting;
<span class="lineNum">     688 </span>            :         gint8  loop_body_start;
<span class="lineNum">     689 </span>            : 
<span class="lineNum">     690 </span>            :         /* 
<span class="lineNum">     691 </span>            :          * Whenever the bblock is rarely executed so it should be emitted after
<span class="lineNum">     692 </span>            :          * the function epilog.
<span class="lineNum">     693 </span>            :          */
<span class="lineNum">     694 </span>            :         guint out_of_line : 1;
<span class="lineNum">     695 </span>            :         /* Caches the result of uselessness calculation during optimize_branches */
<span class="lineNum">     696 </span>            :         guint not_useless : 1;
<span class="lineNum">     697 </span>            :         /* Whenever the decompose_array_access_opts () pass needs to process this bblock */
<span class="lineNum">     698 </span>            :         guint has_array_access : 1;
<span class="lineNum">     699 </span>            :         /* Whenever this bblock is extended, ie. it has branches inside it */
<span class="lineNum">     700 </span>            :         guint extended : 1;
<span class="lineNum">     701 </span>            :         /* Whenever this bblock contains a OP_JUMP_TABLE instruction */
<span class="lineNum">     702 </span>            :         guint has_jump_table : 1;
<span class="lineNum">     703 </span>            :         /* Whenever this bblock contains an OP_CALL_HANDLER instruction */
<span class="lineNum">     704 </span>            :         guint has_call_handler : 1;
<span class="lineNum">     705 </span>            :         /* Whenever this bblock starts a try block */
<span class="lineNum">     706 </span>            :         guint try_start : 1;
<span class="lineNum">     707 </span>            : 
<span class="lineNum">     708 </span>            : #ifdef ENABLE_LLVM
<span class="lineNum">     709 </span>            :         /* The offset of the CIL instruction in this bblock which ends a try block */
<span class="lineNum">     710 </span>            :         intptr_t try_end;
<span class="lineNum">     711 </span>            : #endif
<span class="lineNum">     712 </span>            : 
<span class="lineNum">     713 </span>            :         /*
<span class="lineNum">     714 </span>            :          * If this is set, extend the try range started by this bblock by an arch specific
<span class="lineNum">     715 </span>            :          * number of bytes to encompass the end of the previous bblock (e.g. a Monitor.Enter
<span class="lineNum">     716 </span>            :          * call).
<span class="lineNum">     717 </span>            :          */
<span class="lineNum">     718 </span>            :         guint extend_try_block : 1;
<span class="lineNum">     719 </span>            :         
<span class="lineNum">     720 </span>            :         /* use for liveness analysis */
<span class="lineNum">     721 </span>            :         MonoBitSet *gen_set;
<span class="lineNum">     722 </span>            :         MonoBitSet *kill_set;
<span class="lineNum">     723 </span>            :         MonoBitSet *live_in_set;
<span class="lineNum">     724 </span>            :         MonoBitSet *live_out_set;
<span class="lineNum">     725 </span>            : 
<span class="lineNum">     726 </span>            :         /* fields to deal with non-empty stack slots at bb boundary */
<span class="lineNum">     727 </span>            :         guint16 out_scount, in_scount;
<span class="lineNum">     728 </span>            :         MonoInst **out_stack;
<span class="lineNum">     729 </span>            :         MonoInst **in_stack;
<span class="lineNum">     730 </span>            : 
<span class="lineNum">     731 </span>            :         /* we use that to prevent merging of bblocks covered by different clauses*/
<span class="lineNum">     732 </span>            :         guint real_offset;
<span class="lineNum">     733 </span>            : 
<span class="lineNum">     734 </span>            :         GSList *seq_points;
<span class="lineNum">     735 </span>            : 
<span class="lineNum">     736 </span>            :         // The MonoInst of the last sequence point for the current basic block.
<span class="lineNum">     737 </span>            :         MonoInst *last_seq_point;
<span class="lineNum">     738 </span>            :         
<span class="lineNum">     739 </span>            :         // This will hold a list of last sequence points of incoming basic blocks
<span class="lineNum">     740 </span>            :         MonoInst **pred_seq_points;
<span class="lineNum">     741 </span>            :         guint num_pred_seq_points;
<span class="lineNum">     742 </span>            : 
<span class="lineNum">     743 </span>            :         GSList *spill_slot_defs;
<span class="lineNum">     744 </span>            : 
<span class="lineNum">     745 </span>            :         /* List of call sites in this bblock sorted by pc_offset */
<span class="lineNum">     746 </span>            :         GSList *gc_callsites;
<span class="lineNum">     747 </span>            : 
<span class="lineNum">     748 </span>            :         /*
<span class="lineNum">     749 </span>            :          * The region encodes whether the basic block is inside
<span class="lineNum">     750 </span>            :          * a finally, catch, filter or none of these.
<span class="lineNum">     751 </span>            :          *
<span class="lineNum">     752 </span>            :          * If the value is -1, then it is neither finally, catch nor filter
<span class="lineNum">     753 </span>            :          *
<span class="lineNum">     754 </span>            :          * Otherwise the format is:
<span class="lineNum">     755 </span>            :          *
<span class="lineNum">     756 </span>            :          *  Bits: |     0-3      |       4-7      |     8-31
<span class="lineNum">     757 </span>            :          *        |              |                |
<span class="lineNum">     758 </span>            :          *        | clause-flags |   MONO_REGION  | clause-index 
<span class="lineNum">     759 </span>            :          *
<span class="lineNum">     760 </span>            :          */
<span class="lineNum">     761 </span>            :         guint region;
<span class="lineNum">     762 </span>            : 
<span class="lineNum">     763 </span>            :         /* The current symbolic register number, used in local register allocation. */
<span class="lineNum">     764 </span>            :         guint32 max_vreg;
<span class="lineNum">     765 </span>            : };
<span class="lineNum">     766 </span>            : 
<span class="lineNum">     767 </span>            : /* BBlock flags */
<span class="lineNum">     768 </span>            : enum {
<span class="lineNum">     769 </span>            :         BB_VISITED              = 1 &lt;&lt; 0,
<span class="lineNum">     770 </span>            :         BB_REACHABLE            = 1 &lt;&lt; 1,
<span class="lineNum">     771 </span>            :         BB_EXCEPTION_DEAD_OBJ   = 1 &lt;&lt; 2,
<span class="lineNum">     772 </span>            :         BB_EXCEPTION_UNSAFE     = 1 &lt;&lt; 3,
<span class="lineNum">     773 </span>            :         BB_EXCEPTION_HANDLER    = 1 &lt;&lt; 4,
<span class="lineNum">     774 </span>            :         /* for Native Client, mark the blocks that can be jumped to indirectly */
<span class="lineNum">     775 </span>            :         BB_INDIRECT_JUMP_TARGET = 1 &lt;&lt; 5 
<span class="lineNum">     776 </span>            : };
<span class="lineNum">     777 </span>            : 
<span class="lineNum">     778 </span>            : typedef struct MonoMemcpyArgs {
<span class="lineNum">     779 </span>            :         int size, align;
<span class="lineNum">     780 </span>            : } MonoMemcpyArgs;
<span class="lineNum">     781 </span>            : 
<span class="lineNum">     782 </span>            : typedef enum {
<span class="lineNum">     783 </span>            :         LLVMArgNone,
<span class="lineNum">     784 </span>            :         /* Scalar argument passed by value */
<span class="lineNum">     785 </span>            :         LLVMArgNormal,
<span class="lineNum">     786 </span>            :         /* Only in ainfo-&gt;pair_storage */
<span class="lineNum">     787 </span>            :         LLVMArgInIReg,
<span class="lineNum">     788 </span>            :         /* Only in ainfo-&gt;pair_storage */
<span class="lineNum">     789 </span>            :         LLVMArgInFPReg,
<span class="lineNum">     790 </span>            :         /* Valuetype passed in 1-2 consecutive register */
<span class="lineNum">     791 </span>            :         LLVMArgVtypeInReg,
<span class="lineNum">     792 </span>            :         LLVMArgVtypeByVal,
<span class="lineNum">     793 </span>            :         LLVMArgVtypeRetAddr, /* On on cinfo-&gt;ret */
<span class="lineNum">     794 </span>            :         LLVMArgGSharedVt,
<span class="lineNum">     795 </span>            :         /* Fixed size argument passed to/returned from gsharedvt method by ref */
<span class="lineNum">     796 </span>            :         LLVMArgGsharedvtFixed,
<span class="lineNum">     797 </span>            :         /* Fixed size vtype argument passed to/returned from gsharedvt method by ref */
<span class="lineNum">     798 </span>            :         LLVMArgGsharedvtFixedVtype,
<span class="lineNum">     799 </span>            :         /* Variable sized argument passed to/returned from gsharedvt method by ref */
<span class="lineNum">     800 </span>            :         LLVMArgGsharedvtVariable,
<span class="lineNum">     801 </span>            :         /* Vtype passed/returned as one int array argument */
<span class="lineNum">     802 </span>            :         LLVMArgAsIArgs,
<span class="lineNum">     803 </span>            :         /* Vtype passed as a set of fp arguments */
<span class="lineNum">     804 </span>            :         LLVMArgAsFpArgs,
<span class="lineNum">     805 </span>            :         /*
<span class="lineNum">     806 </span>            :          * Only for returns, a structure which
<span class="lineNum">     807 </span>            :          * consists of floats/doubles.
<span class="lineNum">     808 </span>            :          */
<span class="lineNum">     809 </span>            :         LLVMArgFpStruct,
<span class="lineNum">     810 </span>            :         LLVMArgVtypeByRef,
<span class="lineNum">     811 </span>            :         /* Vtype returned as an int */
<span class="lineNum">     812 </span>            :         LLVMArgVtypeAsScalar
<span class="lineNum">     813 </span>            : } LLVMArgStorage;
<span class="lineNum">     814 </span>            : 
<span class="lineNum">     815 </span>            : typedef struct {
<span class="lineNum">     816 </span>            :         LLVMArgStorage storage;
<span class="lineNum">     817 </span>            : 
<span class="lineNum">     818 </span>            :         /*
<span class="lineNum">     819 </span>            :          * Only if storage == ArgValuetypeInReg/LLVMArgAsFpArgs.
<span class="lineNum">     820 </span>            :          * This contains how the parts of the vtype are passed.
<span class="lineNum">     821 </span>            :          */
<span class="lineNum">     822 </span>            :         LLVMArgStorage pair_storage [8];
<span class="lineNum">     823 </span>            :         /*
<span class="lineNum">     824 </span>            :          * Only if storage == LLVMArgAsIArgs/LLVMArgAsFpArgs/LLVMArgFpStruct.
<span class="lineNum">     825 </span>            :          * If storage == LLVMArgAsFpArgs, this is the number of arguments
<span class="lineNum">     826 </span>            :          * used to pass the value.
<span class="lineNum">     827 </span>            :          * If storage == LLVMArgFpStruct, this is the number of fields
<span class="lineNum">     828 </span>            :          * in the structure.
<span class="lineNum">     829 </span>            :          */
<span class="lineNum">     830 </span>            :         int nslots;
<span class="lineNum">     831 </span>            :         /* Only if storage == LLVMArgAsFpArgs/LLVMArgFpStruct (4/8) */
<span class="lineNum">     832 </span>            :         int esize;
<span class="lineNum">     833 </span>            :         /* Parameter index in the LLVM signature */
<span class="lineNum">     834 </span>            :         int pindex;
<span class="lineNum">     835 </span>            :         MonoType *type;
<span class="lineNum">     836 </span>            :         /* Only if storage == LLVMArgAsFpArgs. Dummy fp args to insert before this arg */
<span class="lineNum">     837 </span>            :         int ndummy_fpargs;
<span class="lineNum">     838 </span>            : } LLVMArgInfo;
<span class="lineNum">     839 </span>            : 
<span class="lineNum">     840 </span>            : typedef struct {
<span class="lineNum">     841 </span>            :         LLVMArgInfo ret;
<span class="lineNum">     842 </span>            :         /* Whenever there is an rgctx argument */
<span class="lineNum">     843 </span>            :         gboolean rgctx_arg;
<span class="lineNum">     844 </span>            :         /* Whenever there is an IMT argument */
<span class="lineNum">     845 </span>            :         gboolean imt_arg;
<span class="lineNum">     846 </span>            :         /* 
<span class="lineNum">     847 </span>            :          * The position of the vret arg in the argument list.
<span class="lineNum">     848 </span>            :          * Only if ret-&gt;storage == ArgVtypeRetAddr.
<span class="lineNum">     849 </span>            :          * Should be 0 or 1.
<span class="lineNum">     850 </span>            :          */
<span class="lineNum">     851 </span>            :         int vret_arg_index;
<span class="lineNum">     852 </span>            :         /* The indexes of various special arguments in the LLVM signature */
<span class="lineNum">     853 </span>            :         int vret_arg_pindex, this_arg_pindex, rgctx_arg_pindex, imt_arg_pindex;
<span class="lineNum">     854 </span>            : 
<span class="lineNum">     855 </span>            :         /* Inline array of argument info */
<span class="lineNum">     856 </span>            :         /* args [0] is for the this argument if it exists */
<span class="lineNum">     857 </span>            :         LLVMArgInfo args [1];
<span class="lineNum">     858 </span>            : } LLVMCallInfo;
<span class="lineNum">     859 </span>            : 
<span class="lineNum">     860 </span>            : #define MONO_MAX_SRC_REGS       3
<span class="lineNum">     861 </span>            : 
<span class="lineNum">     862 </span>            : struct MonoInst {
<span class="lineNum">     863 </span>            :         guint16 opcode;
<span class="lineNum">     864 </span>            :         guint8  type; /* stack type */
<span class="lineNum">     865 </span>            :         guint8  flags;
<span class="lineNum">     866 </span>            :         
<span class="lineNum">     867 </span>            :         /* used by the register allocator */
<span class="lineNum">     868 </span>            :         gint32 dreg, sreg1, sreg2, sreg3;
<span class="lineNum">     869 </span>            : 
<span class="lineNum">     870 </span>            :         MonoInst *next, *prev;
<span class="lineNum">     871 </span>            : 
<span class="lineNum">     872 </span>            :         union {
<span class="lineNum">     873 </span>            :                 union {
<span class="lineNum">     874 </span>            :                         MonoInst *src;
<span class="lineNum">     875 </span>            :                         MonoMethodVar *var;
<span class="lineNum">     876 </span>            :                         mgreg_t const_val;
<span class="lineNum">     877 </span>            : #if (SIZEOF_REGISTER &gt; SIZEOF_VOID_P) &amp;&amp; (G_BYTE_ORDER == G_BIG_ENDIAN)
<span class="lineNum">     878 </span>            :                         struct {
<span class="lineNum">     879 </span>            :                                 gpointer p[SIZEOF_REGISTER/SIZEOF_VOID_P];
<span class="lineNum">     880 </span>            :                         } pdata;
<span class="lineNum">     881 </span>            : #else
<span class="lineNum">     882 </span>            :                         gpointer p;
<span class="lineNum">     883 </span>            : #endif
<span class="lineNum">     884 </span>            :                         MonoMethod *method;
<span class="lineNum">     885 </span>            :                         MonoMethodSignature *signature;
<span class="lineNum">     886 </span>            :                         MonoBasicBlock **many_blocks;
<span class="lineNum">     887 </span>            :                         MonoBasicBlock *target_block;
<span class="lineNum">     888 </span>            :                         MonoInst **args;
<span class="lineNum">     889 </span>            :                         MonoType *vtype;
<span class="lineNum">     890 </span>            :                         MonoClass *klass;
<span class="lineNum">     891 </span>            :                         int *phi_args;
<span class="lineNum">     892 </span>            :                         MonoCallInst *call_inst;
<span class="lineNum">     893 </span>            :                         MonoExceptionClause *exception_clause;
<span class="lineNum">     894 </span>            :                 } op [2];
<span class="lineNum">     895 </span>            :                 gint64 i8const;
<span class="lineNum">     896 </span>            :                 double r8const;
<span class="lineNum">     897 </span>            :         } data;
<span class="lineNum">     898 </span>            : 
<span class="lineNum">     899 </span>            :         const unsigned char* cil_code; /* for debugging and bblock splitting */
<span class="lineNum">     900 </span>            : 
<span class="lineNum">     901 </span>            :         /* used mostly by the backend to store additional info it may need */
<span class="lineNum">     902 </span>            :         union {
<span class="lineNum">     903 </span>            :                 gint32 reg3;
<span class="lineNum">     904 </span>            :                 gint32 arg_info;
<span class="lineNum">     905 </span>            :                 gint32 size;
<span class="lineNum">     906 </span>            :                 MonoMemcpyArgs *memcpy_args; /* in OP_MEMSET and OP_MEMCPY */
<span class="lineNum">     907 </span>            :                 gpointer data;
<span class="lineNum">     908 </span>            :                 gint shift_amount;
<span class="lineNum">     909 </span>            :                 gboolean is_pinvoke; /* for variables in the unmanaged marshal format */
<span class="lineNum">     910 </span>            :                 gboolean record_cast_details; /* For CEE_CASTCLASS */
<span class="lineNum">     911 </span>            :                 MonoInst *spill_var; /* for OP_MOVE_I4_TO_F/F_TO_I4 and OP_FCONV_TO_R8_X */
<span class="lineNum">     912 </span>            :                 guint16 source_opcode; /*OP_XCONV_R8_TO_I4 needs to know which op was used to do proper widening*/
<span class="lineNum">     913 </span>            :                 int pc_offset; /* OP_GC_LIVERANGE_START/END */
<span class="lineNum">     914 </span>            : 
<span class="lineNum">     915 </span>            :                 /*
<span class="lineNum">     916 </span>            :                  * memory_barrier: MONO_MEMORY_BARRIER_{ACQ,REL,SEQ}
<span class="lineNum">     917 </span>            :                  * atomic_load_*: MONO_MEMORY_BARRIER_{ACQ,SEQ}
<span class="lineNum">     918 </span>            :                  * atomic_store_*: MONO_MEMORY_BARRIER_{REL,SEQ}
<span class="lineNum">     919 </span>            :                  */
<span class="lineNum">     920 </span>            :                 int memory_barrier_kind;
<span class="lineNum">     921 </span>            :         } backend;
<span class="lineNum">     922 </span>            :         
<span class="lineNum">     923 </span>            :         MonoClass *klass;
<span class="lineNum">     924 </span>            : };
<span class="lineNum">     925 </span>            :         
<span class="lineNum">     926 </span>            : struct MonoCallInst {
<span class="lineNum">     927 </span>            :         MonoInst inst;
<span class="lineNum">     928 </span>            :         MonoMethodSignature *signature;
<span class="lineNum">     929 </span>            :         MonoMethod *method;
<span class="lineNum">     930 </span>            :         MonoInst **args;
<span class="lineNum">     931 </span>            :         MonoInst *out_args;
<span class="lineNum">     932 </span>            :         MonoInst *vret_var;
<span class="lineNum">     933 </span>            :         gconstpointer fptr;
<span class="lineNum">     934 </span>            :         guint stack_usage;
<span class="lineNum">     935 </span>            :         guint stack_align_amount;
<span class="lineNum">     936 </span>            :         guint is_virtual : 1;
<span class="lineNum">     937 </span>            :         guint tail_call : 1;
<span class="lineNum">     938 </span>            :         /* If this is TRUE, 'fptr' points to a MonoJumpInfo instead of an address. */
<span class="lineNum">     939 </span>            :         guint fptr_is_patch : 1;
<span class="lineNum">     940 </span>            :         /*
<span class="lineNum">     941 </span>            :          * If this is true, then the call returns a vtype in a register using the same 
<span class="lineNum">     942 </span>            :          * calling convention as OP_CALL.
<span class="lineNum">     943 </span>            :          */
<span class="lineNum">     944 </span>            :         guint vret_in_reg : 1;
<span class="lineNum">     945 </span>            :         /* Whenever vret_in_reg returns fp values */
<span class="lineNum">     946 </span>            :         guint vret_in_reg_fp : 1;
<span class="lineNum">     947 </span>            :         /* Whenever there is an IMT argument and it is dynamic */
<span class="lineNum">     948 </span>            :         guint dynamic_imt_arg : 1;
<span class="lineNum">     949 </span>            :         /* Whenever there is an RGCTX argument */
<span class="lineNum">     950 </span>            :         guint32 rgctx_reg : 1;
<span class="lineNum">     951 </span>            :         /* Whenever the call will need an unbox trampoline */
<span class="lineNum">     952 </span>            :         guint need_unbox_trampoline : 1;
<span class="lineNum">     953 </span>            :         regmask_t used_iregs;
<span class="lineNum">     954 </span>            :         regmask_t used_fregs;
<span class="lineNum">     955 </span>            :         GSList *out_ireg_args;
<span class="lineNum">     956 </span>            :         GSList *out_freg_args;
<span class="lineNum">     957 </span>            :         GSList *outarg_vts;
<span class="lineNum">     958 </span>            :         gpointer call_info;
<span class="lineNum">     959 </span>            : #ifdef ENABLE_LLVM
<span class="lineNum">     960 </span>            :         LLVMCallInfo *cinfo;
<span class="lineNum">     961 </span>            :         int rgctx_arg_reg, imt_arg_reg;
<span class="lineNum">     962 </span>            : #endif
<span class="lineNum">     963 </span>            : #ifdef TARGET_ARM
<span class="lineNum">     964 </span>            :         /* See the comment in mini-arm.c!mono_arch_emit_call for RegTypeFP. */
<span class="lineNum">     965 </span>            :         GSList *float_args;
<span class="lineNum">     966 </span>            : #endif
<span class="lineNum">     967 </span>            : };
<span class="lineNum">     968 </span>            : 
<span class="lineNum">     969 </span>            : struct MonoCallArgParm {
<span class="lineNum">     970 </span>            :         MonoInst ins;
<span class="lineNum">     971 </span>            :         gint32 size;
<span class="lineNum">     972 </span>            :         gint32 offset;
<span class="lineNum">     973 </span>            :         gint32 offPrm;
<span class="lineNum">     974 </span>            : };
<span class="lineNum">     975 </span>            : 
<span class="lineNum">     976 </span>            : /* 
<span class="lineNum">     977 </span>            :  * flags for MonoInst
<span class="lineNum">     978 </span>            :  * Note: some of the values overlap, because they can't appear
<span class="lineNum">     979 </span>            :  * in the same MonoInst.
<span class="lineNum">     980 </span>            :  */
<span class="lineNum">     981 </span>            : enum {
<span class="lineNum">     982 </span>            :         MONO_INST_HAS_METHOD = 1,
<span class="lineNum">     983 </span>            :         MONO_INST_INIT       = 1, /* in localloc */
<span class="lineNum">     984 </span>            :         MONO_INST_SINGLE_STEP_LOC = 1, /* in SEQ_POINT */
<span class="lineNum">     985 </span>            :         MONO_INST_IS_DEAD    = 2,
<span class="lineNum">     986 </span>            :         MONO_INST_TAILCALL   = 4,
<span class="lineNum">     987 </span>            :         MONO_INST_VOLATILE   = 4,
<span class="lineNum">     988 </span>            :         MONO_INST_NOTYPECHECK    = 4,
<span class="lineNum">     989 </span>            :         MONO_INST_NONEMPTY_STACK = 4, /* in SEQ_POINT */
<span class="lineNum">     990 </span>            :         MONO_INST_UNALIGNED  = 8,
<span class="lineNum">     991 </span>            :     MONO_INST_CFOLD_TAKEN = 8, /* On branches */
<span class="lineNum">     992 </span>            :     MONO_INST_CFOLD_NOT_TAKEN = 16, /* On branches */
<span class="lineNum">     993 </span>            :         MONO_INST_DEFINITION_HAS_SIDE_EFFECTS = 8,
<span class="lineNum">     994 </span>            :         /* the address of the variable has been taken */
<span class="lineNum">     995 </span>            :         MONO_INST_INDIRECT   = 16,
<span class="lineNum">     996 </span>            :         MONO_INST_NORANGECHECK   = 16,
<span class="lineNum">     997 </span>            :         /* On loads, the source address can be null */
<span class="lineNum">     998 </span>            :         MONO_INST_FAULT = 32,
<span class="lineNum">     999 </span>            :         /* 
<span class="lineNum">    1000 </span>            :          * On variables, identifies LMF variables. These variables have a dummy type (int), but
<span class="lineNum">    1001 </span>            :          * require stack space for a MonoLMF struct.
<span class="lineNum">    1002 </span>            :          */
<span class="lineNum">    1003 </span>            :         MONO_INST_LMF = 32,
<span class="lineNum">    1004 </span>            :         /* On loads, the source address points to a constant value */
<span class="lineNum">    1005 </span>            :         MONO_INST_INVARIANT_LOAD = 64,
<span class="lineNum">    1006 </span>            :         /* On variables, the variable needs GC tracking */
<span class="lineNum">    1007 </span>            :         MONO_INST_GC_TRACK = 128,
<span class="lineNum">    1008 </span>            :         /*
<span class="lineNum">    1009 </span>            :          * Set on instructions during code emission which make calls, i.e. OP_CALL, OP_THROW.
<span class="lineNum">    1010 </span>            :          * backend.pc_offset will be set to the pc offset at the end of the native call instructions.
<span class="lineNum">    1011 </span>            :          */
<span class="lineNum">    1012 </span>            :         MONO_INST_GC_CALLSITE = 128,
<span class="lineNum">    1013 </span>            :         /* On comparisons, mark the branch following the condition as likely to be taken */
<span class="lineNum">    1014 </span>            :         MONO_INST_LIKELY = 128,
<span class="lineNum">    1015 </span>            : };
<span class="lineNum">    1016 </span>            : 
<span class="lineNum">    1017 </span>            : #define inst_c0 data.op[0].const_val
<span class="lineNum">    1018 </span>            : #define inst_c1 data.op[1].const_val
<span class="lineNum">    1019 </span>            : #define inst_i0 data.op[0].src
<span class="lineNum">    1020 </span>            : #define inst_i1 data.op[1].src
<span class="lineNum">    1021 </span>            : #if (SIZEOF_REGISTER &gt; SIZEOF_VOID_P) &amp;&amp; (G_BYTE_ORDER == G_BIG_ENDIAN)
<span class="lineNum">    1022 </span>            : #define inst_p0 data.op[0].pdata.p[SIZEOF_REGISTER/SIZEOF_VOID_P - 1]
<span class="lineNum">    1023 </span>            : #define inst_p1 data.op[1].pdata.p[SIZEOF_REGISTER/SIZEOF_VOID_P - 1]
<span class="lineNum">    1024 </span>            : #else
<span class="lineNum">    1025 </span>            : #define inst_p0 data.op[0].p
<span class="lineNum">    1026 </span>            : #define inst_p1 data.op[1].p
<span class="lineNum">    1027 </span>            : #endif
<span class="lineNum">    1028 </span>            : #define inst_l  data.i8const
<span class="lineNum">    1029 </span>            : #define inst_r  data.r8const
<span class="lineNum">    1030 </span>            : #define inst_left  data.op[0].src
<span class="lineNum">    1031 </span>            : #define inst_right data.op[1].src
<span class="lineNum">    1032 </span>            : 
<span class="lineNum">    1033 </span>            : #define inst_newa_len   data.op[0].src
<span class="lineNum">    1034 </span>            : #define inst_newa_class data.op[1].klass
<span class="lineNum">    1035 </span>            : 
<span class="lineNum">    1036 </span>            : #define inst_var    data.op[0].var
<span class="lineNum">    1037 </span>            : #define inst_vtype  data.op[1].vtype
<span class="lineNum">    1038 </span>            : /* in branch instructions */
<span class="lineNum">    1039 </span>            : #define inst_many_bb   data.op[1].many_blocks
<span class="lineNum">    1040 </span>            : #define inst_target_bb data.op[0].target_block
<span class="lineNum">    1041 </span>            : #define inst_true_bb   data.op[1].many_blocks[0]
<span class="lineNum">    1042 </span>            : #define inst_false_bb  data.op[1].many_blocks[1]
<span class="lineNum">    1043 </span>            : 
<span class="lineNum">    1044 </span>            : #define inst_basereg sreg1
<span class="lineNum">    1045 </span>            : #define inst_indexreg sreg2
<span class="lineNum">    1046 </span>            : #define inst_destbasereg dreg
<span class="lineNum">    1047 </span>            : #define inst_offset data.op[0].const_val
<span class="lineNum">    1048 </span>            : #define inst_imm    data.op[1].const_val
<span class="lineNum">    1049 </span>            : #define inst_call   data.op[1].call_inst
<span class="lineNum">    1050 </span>            : 
<span class="lineNum">    1051 </span>            : #define inst_phi_args   data.op[1].phi_args
<span class="lineNum">    1052 </span>            : #define inst_eh_block    data.op[1].exception_clause
<a name="1053"><span class="lineNum">    1053 </span>            : </a>
<span class="lineNum">    1054 </span>            : static inline void
<span class="lineNum">    1055 </span>            : mono_inst_set_src_registers (MonoInst *ins, int *regs)
<span class="lineNum">    1056 </span>            : {
<span class="lineNum">    1057 </span><span class="lineCov"> 7255717764 :         ins-&gt;sreg1 = regs [0];</span>
<span class="lineNum">    1058 </span><span class="lineCov"> 7255717764 :         ins-&gt;sreg2 = regs [1];</span>
<span class="lineNum">    1059 </span><span class="lineCov"> 7255717764 :         ins-&gt;sreg3 = regs [2];</span>
<span class="lineNum">    1060 </span><span class="lineCov"> 7255717764 : }</span>
<span class="lineNum">    1061 </span>            : 
<span class="lineNum">    1062 </span>            : /* instruction description for use in regalloc/scheduling */
<span class="lineNum">    1063 </span>            : enum {
<span class="lineNum">    1064 </span>            :         MONO_INST_DEST,
<span class="lineNum">    1065 </span>            :         MONO_INST_SRC1,         /* we depend on the SRCs to be consecutive */
<span class="lineNum">    1066 </span>            :         MONO_INST_SRC2,
<span class="lineNum">    1067 </span>            :         MONO_INST_SRC3,
<span class="lineNum">    1068 </span>            :         MONO_INST_LEN,
<span class="lineNum">    1069 </span>            :         MONO_INST_CLOB,
<span class="lineNum">    1070 </span>            :         /* Unused, commented out to reduce the size of the mdesc tables
<span class="lineNum">    1071 </span>            :         MONO_INST_FLAGS,
<span class="lineNum">    1072 </span>            :         MONO_INST_COST,
<span class="lineNum">    1073 </span>            :         MONO_INST_DELAY,
<span class="lineNum">    1074 </span>            :         MONO_INST_RES,
<span class="lineNum">    1075 </span>            :         */
<span class="lineNum">    1076 </span>            :         MONO_INST_MAX
<span class="lineNum">    1077 </span>            : };
<span class="lineNum">    1078 </span>            : 
<span class="lineNum">    1079 </span>            : typedef union {
<span class="lineNum">    1080 </span>            :         struct {
<span class="lineNum">    1081 </span>            :                 guint16 tid; /* tree number */
<span class="lineNum">    1082 </span>            :                 guint16 bid; /* block number */
<span class="lineNum">    1083 </span>            :         } pos ;
<span class="lineNum">    1084 </span>            :         guint32 abs_pos; 
<span class="lineNum">    1085 </span>            : } MonoPosition;
<span class="lineNum">    1086 </span>            : 
<span class="lineNum">    1087 </span>            : typedef struct {
<span class="lineNum">    1088 </span>            :         MonoPosition first_use, last_use;
<span class="lineNum">    1089 </span>            : } MonoLiveRange;
<span class="lineNum">    1090 </span>            : 
<span class="lineNum">    1091 </span>            : typedef struct MonoLiveRange2 MonoLiveRange2;
<span class="lineNum">    1092 </span>            : 
<span class="lineNum">    1093 </span>            : struct MonoLiveRange2 {
<span class="lineNum">    1094 </span>            :         int from, to;
<span class="lineNum">    1095 </span>            :         MonoLiveRange2 *next;
<span class="lineNum">    1096 </span>            : };
<span class="lineNum">    1097 </span>            : 
<span class="lineNum">    1098 </span>            : typedef struct {
<span class="lineNum">    1099 </span>            :         /* List of live ranges sorted by 'from' */
<span class="lineNum">    1100 </span>            :         MonoLiveRange2 *range;
<span class="lineNum">    1101 </span>            :         MonoLiveRange2 *last_range;
<span class="lineNum">    1102 </span>            : } MonoLiveInterval;
<span class="lineNum">    1103 </span>            : 
<span class="lineNum">    1104 </span>            : /*
<span class="lineNum">    1105 </span>            :  * Additional information about a variable
<span class="lineNum">    1106 </span>            :  */
<span class="lineNum">    1107 </span>            : struct MonoMethodVar {
<span class="lineNum">    1108 </span>            :         guint           idx; /* inside cfg-&gt;varinfo, cfg-&gt;vars */
<span class="lineNum">    1109 </span>            :         MonoLiveRange   range; /* generated by liveness analysis */
<span class="lineNum">    1110 </span>            :         MonoLiveInterval *interval; /* generated by liveness analysis */
<span class="lineNum">    1111 </span>            :         int             reg; /* != -1 if allocated into a register */
<span class="lineNum">    1112 </span>            :         int             spill_costs;
<span class="lineNum">    1113 </span>            :         MonoBitSet     *def_in; /* used by SSA */
<span class="lineNum">    1114 </span>            :         MonoInst       *def;    /* used by SSA */
<span class="lineNum">    1115 </span>            :         MonoBasicBlock *def_bb; /* used by SSA */
<span class="lineNum">    1116 </span>            :         GList          *uses;   /* used by SSA */
<span class="lineNum">    1117 </span>            :         char            cpstate;  /* used by SSA conditional  constant propagation */
<span class="lineNum">    1118 </span>            :         /* The native offsets corresponding to the live range of the variable */
<span class="lineNum">    1119 </span>            :         gint32         live_range_start, live_range_end;
<span class="lineNum">    1120 </span>            :         /* 
<span class="lineNum">    1121 </span>            :          * cfg-&gt;varinfo [idx]-&gt;dreg could be replaced for OP_REGVAR, this contains the 
<span class="lineNum">    1122 </span>            :          * original vreg.
<span class="lineNum">    1123 </span>            :          */
<span class="lineNum">    1124 </span>            :         gint32         vreg;
<span class="lineNum">    1125 </span>            : };
<span class="lineNum">    1126 </span>            : 
<span class="lineNum">    1127 </span>            : /*
<span class="lineNum">    1128 </span>            :  * Stores state need to resume exception handling when using LLVM
<span class="lineNum">    1129 </span>            :  */
<span class="lineNum">    1130 </span>            : typedef struct {
<span class="lineNum">    1131 </span>            :         MonoJitInfo *ji;
<span class="lineNum">    1132 </span>            :         int clause_index;
<span class="lineNum">    1133 </span>            :         MonoContext ctx, new_ctx;
<span class="lineNum">    1134 </span>            :         /* FIXME: GC */
<span class="lineNum">    1135 </span>            :         gpointer        ex_obj;
<span class="lineNum">    1136 </span>            :         MonoLMF *lmf;
<span class="lineNum">    1137 </span>            :         int first_filter_idx, filter_idx;
<span class="lineNum">    1138 </span>            : } ResumeState;
<span class="lineNum">    1139 </span>            : 
<span class="lineNum">    1140 </span>            : typedef struct {
<span class="lineNum">    1141 </span>            :         gpointer          end_of_stack;
<span class="lineNum">    1142 </span>            :         guint32           stack_size;
<span class="lineNum">    1143 </span>            :         /* !defined(HAVE_KW_THREAD) || !defined(MONO_ARCH_ENABLE_MONO_LMF_VAR) */
<span class="lineNum">    1144 </span>            :         MonoLMF          *lmf;
<span class="lineNum">    1145 </span>            :         MonoLMF          *first_lmf;
<span class="lineNum">    1146 </span>            :         gpointer         restore_stack_prot;
<span class="lineNum">    1147 </span>            :         guint32          handling_stack_ovf;
<span class="lineNum">    1148 </span>            :         gpointer         signal_stack;
<span class="lineNum">    1149 </span>            :         guint32          signal_stack_size;
<span class="lineNum">    1150 </span>            :         gpointer         stack_ovf_guard_base;
<span class="lineNum">    1151 </span>            :         guint32          stack_ovf_guard_size;
<span class="lineNum">    1152 </span>            :         guint            stack_ovf_valloced : 1;
<span class="lineNum">    1153 </span>            :         void            (*abort_func) (MonoObject *object);
<span class="lineNum">    1154 </span>            :         /* Used to implement --debug=casts */
<span class="lineNum">    1155 </span>            :         MonoClass       *class_cast_from, *class_cast_to;
<span class="lineNum">    1156 </span>            : 
<span class="lineNum">    1157 </span>            :         /* Stores state needed by handler block with a guard */
<span class="lineNum">    1158 </span>            :         MonoContext     ex_ctx;
<span class="lineNum">    1159 </span>            :         ResumeState resume_state;
<span class="lineNum">    1160 </span>            : 
<span class="lineNum">    1161 </span>            :         /*Variabled use to implement handler blocks (finally/catch/etc) guards during interruption*/
<span class="lineNum">    1162 </span>            :         /* handler block return address */
<span class="lineNum">    1163 </span>            :         gpointer handler_block_return_address;
<span class="lineNum">    1164 </span>            : 
<span class="lineNum">    1165 </span>            :         /* handler block been guarded. It's safe to store this even for dynamic methods since there
<span class="lineNum">    1166 </span>            :         is an activation on stack making sure it will remain alive.*/
<span class="lineNum">    1167 </span>            :         MonoJitExceptionInfo *handler_block;
<span class="lineNum">    1168 </span>            : 
<span class="lineNum">    1169 </span>            :         /* context to be used by the guard trampoline when resuming interruption.*/
<span class="lineNum">    1170 </span>            :         MonoContext handler_block_context;
<span class="lineNum">    1171 </span>            :         /* 
<span class="lineNum">    1172 </span>            :          * Stores the state at the exception throw site to be used by mono_stack_walk ()
<span class="lineNum">    1173 </span>            :          * when it is called from profiler functions during exception handling.
<span class="lineNum">    1174 </span>            :          */
<span class="lineNum">    1175 </span>            :         MonoContext orig_ex_ctx;
<span class="lineNum">    1176 </span>            :         gboolean orig_ex_ctx_set;
<span class="lineNum">    1177 </span>            : 
<span class="lineNum">    1178 </span>            :         /* 
<span class="lineNum">    1179 </span>            :          * Stores if we need to run a chained exception in Windows.
<span class="lineNum">    1180 </span>            :          */
<span class="lineNum">    1181 </span>            :         gboolean mono_win_chained_exception_needs_run;
<span class="lineNum">    1182 </span>            : 
<span class="lineNum">    1183 </span>            :         /* 
<span class="lineNum">    1184 </span>            :          * The current exception in flight
<span class="lineNum">    1185 </span>            :          */
<span class="lineNum">    1186 </span>            :         guint32 thrown_exc;
<span class="lineNum">    1187 </span>            :         /*
<span class="lineNum">    1188 </span>            :          * If the current exception is not a subclass of Exception,
<span class="lineNum">    1189 </span>            :          * the original exception.
<span class="lineNum">    1190 </span>            :          */
<span class="lineNum">    1191 </span>            :         guint32 thrown_non_exc;
<span class="lineNum">    1192 </span>            : 
<span class="lineNum">    1193 </span>            :         /*
<span class="lineNum">    1194 </span>            :          * The calling assembly in llvmonly mode.
<span class="lineNum">    1195 </span>            :          */
<span class="lineNum">    1196 </span>            :         MonoImage *calling_image;
<span class="lineNum">    1197 </span>            : 
<span class="lineNum">    1198 </span>            :         /*
<span class="lineNum">    1199 </span>            :          * The stack frame &quot;high water mark&quot; for ThreadAbortExceptions.
<span class="lineNum">    1200 </span>            :          * We will rethrow the exception upon exiting a catch clause that's
<span class="lineNum">    1201 </span>            :          * in a function stack frame above the water mark(isn't being called by
<span class="lineNum">    1202 </span>            :          * the catch block that caught the ThreadAbortException).
<span class="lineNum">    1203 </span>            :          */
<span class="lineNum">    1204 </span>            :         gpointer abort_exc_stack_threshold;
<span class="lineNum">    1205 </span>            : } MonoJitTlsData;
<span class="lineNum">    1206 </span>            : 
<span class="lineNum">    1207 </span>            : /*
<span class="lineNum">    1208 </span>            :  * This structure is an extension of MonoLMF and contains extra information.
<span class="lineNum">    1209 </span>            :  */
<span class="lineNum">    1210 </span>            : typedef struct {
<span class="lineNum">    1211 </span>            :         struct MonoLMF lmf;
<span class="lineNum">    1212 </span>            :         gboolean debugger_invoke;
<span class="lineNum">    1213 </span>            :         MonoContext ctx; /* if debugger_invoke is TRUE */
<span class="lineNum">    1214 </span>            : } MonoLMFExt;
<span class="lineNum">    1215 </span>            : 
<span class="lineNum">    1216 </span>            : /* Generic sharing */
<span class="lineNum">    1217 </span>            : 
<span class="lineNum">    1218 </span>            : /*
<span class="lineNum">    1219 </span>            :  * Flags for which contexts were used in inflating a generic.
<span class="lineNum">    1220 </span>            :  */
<span class="lineNum">    1221 </span>            : enum {
<span class="lineNum">    1222 </span>            :         MONO_GENERIC_CONTEXT_USED_CLASS = 1,
<span class="lineNum">    1223 </span>            :         MONO_GENERIC_CONTEXT_USED_METHOD = 2
<span class="lineNum">    1224 </span>            : };
<span class="lineNum">    1225 </span>            : 
<span class="lineNum">    1226 </span>            : enum {
<span class="lineNum">    1227 </span>            :         /* Cannot be 0 since this is stored in rgctx slots, and 0 means an unitialized rgctx slot */
<span class="lineNum">    1228 </span>            :         MONO_GSHAREDVT_BOX_TYPE_VTYPE = 1,
<span class="lineNum">    1229 </span>            :         MONO_GSHAREDVT_BOX_TYPE_REF = 2,
<span class="lineNum">    1230 </span>            :         MONO_GSHAREDVT_BOX_TYPE_NULLABLE = 3
<span class="lineNum">    1231 </span>            : };
<span class="lineNum">    1232 </span>            : 
<span class="lineNum">    1233 </span>            : typedef enum {
<span class="lineNum">    1234 </span>            :         MONO_RGCTX_INFO_STATIC_DATA,
<span class="lineNum">    1235 </span>            :         MONO_RGCTX_INFO_KLASS,
<span class="lineNum">    1236 </span>            :         MONO_RGCTX_INFO_ELEMENT_KLASS,
<span class="lineNum">    1237 </span>            :         MONO_RGCTX_INFO_VTABLE,
<span class="lineNum">    1238 </span>            :         MONO_RGCTX_INFO_TYPE,
<span class="lineNum">    1239 </span>            :         MONO_RGCTX_INFO_REFLECTION_TYPE,
<span class="lineNum">    1240 </span>            :         MONO_RGCTX_INFO_METHOD,
<span class="lineNum">    1241 </span>            :         /* In llvmonly mode, this is a function descriptor */
<span class="lineNum">    1242 </span>            :         MONO_RGCTX_INFO_GENERIC_METHOD_CODE,
<span class="lineNum">    1243 </span>            :         MONO_RGCTX_INFO_GSHAREDVT_OUT_WRAPPER,
<span class="lineNum">    1244 </span>            :         MONO_RGCTX_INFO_CLASS_FIELD,
<span class="lineNum">    1245 </span>            :         MONO_RGCTX_INFO_METHOD_RGCTX,
<span class="lineNum">    1246 </span>            :         MONO_RGCTX_INFO_METHOD_CONTEXT,
<span class="lineNum">    1247 </span>            :         MONO_RGCTX_INFO_REMOTING_INVOKE_WITH_CHECK,
<span class="lineNum">    1248 </span>            :         MONO_RGCTX_INFO_METHOD_DELEGATE_CODE,
<span class="lineNum">    1249 </span>            :         MONO_RGCTX_INFO_CAST_CACHE,
<span class="lineNum">    1250 </span>            :         MONO_RGCTX_INFO_ARRAY_ELEMENT_SIZE,
<span class="lineNum">    1251 </span>            :         MONO_RGCTX_INFO_VALUE_SIZE,
<span class="lineNum">    1252 </span>            :         /* +1 to avoid zero values in rgctx slots */
<span class="lineNum">    1253 </span>            :         MONO_RGCTX_INFO_FIELD_OFFSET,
<span class="lineNum">    1254 </span>            :         /* Either the code for a gsharedvt method, or the address for a gsharedvt-out trampoline for the method */
<span class="lineNum">    1255 </span>            :         /* In llvmonly mode, this is a function descriptor */
<span class="lineNum">    1256 </span>            :         MONO_RGCTX_INFO_METHOD_GSHAREDVT_OUT_TRAMPOLINE,
<span class="lineNum">    1257 </span>            :         /* Same for virtual calls */
<span class="lineNum">    1258 </span>            :         /* In llvmonly mode, this is a function descriptor */
<span class="lineNum">    1259 </span>            :         MONO_RGCTX_INFO_METHOD_GSHAREDVT_OUT_TRAMPOLINE_VIRT,
<span class="lineNum">    1260 </span>            :         /* Same for calli, associated with a signature */
<span class="lineNum">    1261 </span>            :         MONO_RGCTX_INFO_SIG_GSHAREDVT_OUT_TRAMPOLINE_CALLI,
<span class="lineNum">    1262 </span>            :         MONO_RGCTX_INFO_SIG_GSHAREDVT_IN_TRAMPOLINE_CALLI,
<span class="lineNum">    1263 </span>            :         /* One of MONO_GSHAREDVT_BOX_TYPE */
<span class="lineNum">    1264 </span>            :         MONO_RGCTX_INFO_CLASS_BOX_TYPE,
<span class="lineNum">    1265 </span>            :         /* Resolves to a MonoGSharedVtMethodRuntimeInfo */
<span class="lineNum">    1266 </span>            :         MONO_RGCTX_INFO_METHOD_GSHAREDVT_INFO,
<span class="lineNum">    1267 </span>            :         MONO_RGCTX_INFO_LOCAL_OFFSET,
<span class="lineNum">    1268 </span>            :         MONO_RGCTX_INFO_MEMCPY,
<span class="lineNum">    1269 </span>            :         MONO_RGCTX_INFO_BZERO,
<span class="lineNum">    1270 </span>            :         /* The address of Nullable&lt;T&gt;.Box () */
<span class="lineNum">    1271 </span>            :         /* In llvmonly mode, this is a function descriptor */
<span class="lineNum">    1272 </span>            :         MONO_RGCTX_INFO_NULLABLE_CLASS_BOX,
<span class="lineNum">    1273 </span>            :         MONO_RGCTX_INFO_NULLABLE_CLASS_UNBOX,
<span class="lineNum">    1274 </span>            :         /* MONO_PATCH_INFO_VCALL_METHOD */
<span class="lineNum">    1275 </span>            :         MONO_RGCTX_INFO_VIRT_METHOD_CODE,
<span class="lineNum">    1276 </span>            :         /*
<span class="lineNum">    1277 </span>            :          * MONO_PATCH_INFO_VCALL_METHOD
<span class="lineNum">    1278 </span>            :          * Same as MONO_RGCTX_INFO_CLASS_BOX_TYPE, but for the class
<span class="lineNum">    1279 </span>            :          * which implements the method.
<span class="lineNum">    1280 </span>            :          */
<span class="lineNum">    1281 </span>            :         MONO_RGCTX_INFO_VIRT_METHOD_BOX_TYPE,
<span class="lineNum">    1282 </span>            : } MonoRgctxInfoType;
<span class="lineNum">    1283 </span>            : 
<span class="lineNum">    1284 </span>            : typedef struct _MonoRuntimeGenericContextInfoTemplate {
<span class="lineNum">    1285 </span>            :         MonoRgctxInfoType info_type;
<span class="lineNum">    1286 </span>            :         gpointer data;
<span class="lineNum">    1287 </span>            :         struct _MonoRuntimeGenericContextInfoTemplate *next;
<span class="lineNum">    1288 </span>            : } MonoRuntimeGenericContextInfoTemplate;
<span class="lineNum">    1289 </span>            : 
<span class="lineNum">    1290 </span>            : typedef struct {
<span class="lineNum">    1291 </span>            :         MonoClass *next_subclass;
<span class="lineNum">    1292 </span>            :         MonoRuntimeGenericContextInfoTemplate *infos;
<span class="lineNum">    1293 </span>            :         GSList *method_templates;
<span class="lineNum">    1294 </span>            : } MonoRuntimeGenericContextTemplate;
<span class="lineNum">    1295 </span>            : 
<span class="lineNum">    1296 </span>            : typedef struct {
<span class="lineNum">    1297 </span>            :         MonoVTable *class_vtable; /* must be the first element */
<span class="lineNum">    1298 </span>            :         MonoGenericInst *method_inst;
<span class="lineNum">    1299 </span>            :         gpointer infos [MONO_ZERO_LEN_ARRAY];
<span class="lineNum">    1300 </span>            : } MonoMethodRuntimeGenericContext;
<span class="lineNum">    1301 </span>            : 
<span class="lineNum">    1302 </span>            : #define MONO_SIZEOF_METHOD_RUNTIME_GENERIC_CONTEXT (sizeof (MonoMethodRuntimeGenericContext) - MONO_ZERO_LEN_ARRAY * SIZEOF_VOID_P)
<span class="lineNum">    1303 </span>            : 
<span class="lineNum">    1304 </span>            : #define MONO_RGCTX_SLOT_MAKE_RGCTX(i)   (i)
<span class="lineNum">    1305 </span>            : #define MONO_RGCTX_SLOT_MAKE_MRGCTX(i)  ((i) | 0x80000000)
<span class="lineNum">    1306 </span>            : #define MONO_RGCTX_SLOT_INDEX(s)        ((s) &amp; 0x7fffffff)
<span class="lineNum">    1307 </span>            : #define MONO_RGCTX_SLOT_IS_MRGCTX(s)    (((s) &amp; 0x80000000) ? TRUE : FALSE)
<span class="lineNum">    1308 </span>            : 
<span class="lineNum">    1309 </span>            : #define MONO_GSHAREDVT_DEL_INVOKE_VT_OFFSET -2
<span class="lineNum">    1310 </span>            : 
<span class="lineNum">    1311 </span>            : typedef struct {
<span class="lineNum">    1312 </span>            :         MonoMethod *method;
<span class="lineNum">    1313 </span>            :         MonoRuntimeGenericContextInfoTemplate *entries;
<span class="lineNum">    1314 </span>            :         int num_entries, count_entries;
<span class="lineNum">    1315 </span>            : } MonoGSharedVtMethodInfo;
<span class="lineNum">    1316 </span>            : 
<span class="lineNum">    1317 </span>            : /* This is used by gsharedvt methods to allocate locals and compute local offsets */
<span class="lineNum">    1318 </span>            : typedef struct {
<span class="lineNum">    1319 </span>            :         int locals_size;
<span class="lineNum">    1320 </span>            :         /*
<span class="lineNum">    1321 </span>            :          * The results of resolving the entries in MOonGSharedVtMethodInfo-&gt;entries.
<span class="lineNum">    1322 </span>            :          * We use this instead of rgctx slots since these can be loaded using a load instead
<span class="lineNum">    1323 </span>            :          * of a call to an rgctx fetch trampoline.
<span class="lineNum">    1324 </span>            :          */
<span class="lineNum">    1325 </span>            :         gpointer entries [MONO_ZERO_LEN_ARRAY];
<span class="lineNum">    1326 </span>            : } MonoGSharedVtMethodRuntimeInfo;
<span class="lineNum">    1327 </span>            : 
<span class="lineNum">    1328 </span>            : typedef struct
<span class="lineNum">    1329 </span>            : {
<span class="lineNum">    1330 </span>            :         MonoMethod *invoke;
<span class="lineNum">    1331 </span>            :         MonoMethod *method;
<span class="lineNum">    1332 </span>            :         MonoMethodSignature *invoke_sig;
<span class="lineNum">    1333 </span>            :         MonoMethodSignature *sig;
<span class="lineNum">    1334 </span>            :         gpointer method_ptr;
<span class="lineNum">    1335 </span>            :         gpointer invoke_impl;
<span class="lineNum">    1336 </span>            :         gpointer impl_this;
<span class="lineNum">    1337 </span>            :         gpointer impl_nothis;
<span class="lineNum">    1338 </span>            :         gboolean need_rgctx_tramp;
<span class="lineNum">    1339 </span>            : } MonoDelegateTrampInfo;
<span class="lineNum">    1340 </span>            : 
<span class="lineNum">    1341 </span>            : /*
<span class="lineNum">    1342 </span>            :  * A function descriptor, which is a function address + argument pair.
<span class="lineNum">    1343 </span>            :  * In llvm-only mode, these are used instead of trampolines to pass
<span class="lineNum">    1344 </span>            :  * extra arguments to runtime functions/methods.
<span class="lineNum">    1345 </span>            :  */
<span class="lineNum">    1346 </span>            : typedef struct
<span class="lineNum">    1347 </span>            : {
<span class="lineNum">    1348 </span>            :         gpointer addr;
<span class="lineNum">    1349 </span>            :         gpointer arg;
<span class="lineNum">    1350 </span>            : } MonoFtnDesc;
<span class="lineNum">    1351 </span>            : 
<span class="lineNum">    1352 </span>            : typedef enum {
<span class="lineNum">    1353 </span>            : #define PATCH_INFO(a,b) MONO_PATCH_INFO_ ## a,
<span class="lineNum">    1354 </span>            : #include &quot;patch-info.h&quot;
<span class="lineNum">    1355 </span>            : #undef PATCH_INFO
<span class="lineNum">    1356 </span>            :         MONO_PATCH_INFO_NUM
<span class="lineNum">    1357 </span>            : } MonoJumpInfoType;
<span class="lineNum">    1358 </span>            : 
<span class="lineNum">    1359 </span>            : /*
<span class="lineNum">    1360 </span>            :  * We need to store the image which the token refers to along with the token,
<span class="lineNum">    1361 </span>            :  * since the image might not be the same as the image of the method which
<span class="lineNum">    1362 </span>            :  * contains the relocation, because of inlining.
<span class="lineNum">    1363 </span>            :  */
<span class="lineNum">    1364 </span>            : typedef struct MonoJumpInfoToken {
<span class="lineNum">    1365 </span>            :         MonoImage *image;
<span class="lineNum">    1366 </span>            :         guint32 token;
<span class="lineNum">    1367 </span>            :         gboolean has_context;
<span class="lineNum">    1368 </span>            :         MonoGenericContext context;
<span class="lineNum">    1369 </span>            : } MonoJumpInfoToken;
<span class="lineNum">    1370 </span>            : 
<span class="lineNum">    1371 </span>            : typedef struct MonoJumpInfoBBTable {
<span class="lineNum">    1372 </span>            :         MonoBasicBlock **table;
<span class="lineNum">    1373 </span>            :         int table_size;
<span class="lineNum">    1374 </span>            : } MonoJumpInfoBBTable;
<span class="lineNum">    1375 </span>            : 
<span class="lineNum">    1376 </span>            : typedef struct MonoJumpInfoRgctxEntry MonoJumpInfoRgctxEntry;
<span class="lineNum">    1377 </span>            : 
<span class="lineNum">    1378 </span>            : /* Contains information describing an LLVM IMT trampoline */
<span class="lineNum">    1379 </span>            : typedef struct MonoJumpInfoImtTramp {
<span class="lineNum">    1380 </span>            :         MonoMethod *method;
<span class="lineNum">    1381 </span>            :         int vt_offset;
<span class="lineNum">    1382 </span>            : } MonoJumpInfoImtTramp;
<span class="lineNum">    1383 </span>            : 
<span class="lineNum">    1384 </span>            : typedef struct MonoJumpInfoGSharedVtCall MonoJumpInfoGSharedVtCall;
<span class="lineNum">    1385 </span>            : 
<span class="lineNum">    1386 </span>            : /*
<span class="lineNum">    1387 </span>            :  * Represents the method which is called when a virtual call is made to METHOD
<span class="lineNum">    1388 </span>            :  * on a receiver of type KLASS.
<span class="lineNum">    1389 </span>            :  */
<span class="lineNum">    1390 </span>            : typedef struct {
<span class="lineNum">    1391 </span>            :         /* Receiver class */
<span class="lineNum">    1392 </span>            :         MonoClass *klass;
<span class="lineNum">    1393 </span>            :         /* Virtual method */
<span class="lineNum">    1394 </span>            :         MonoMethod *method;
<span class="lineNum">    1395 </span>            : } MonoJumpInfoVirtMethod;
<span class="lineNum">    1396 </span>            : 
<span class="lineNum">    1397 </span>            : typedef struct MonoJumpInfo MonoJumpInfo;
<span class="lineNum">    1398 </span>            : struct MonoJumpInfo {
<span class="lineNum">    1399 </span>            :         MonoJumpInfo *next;
<span class="lineNum">    1400 </span>            :         /* Relocation type for patching */
<span class="lineNum">    1401 </span>            :         int relocation;
<span class="lineNum">    1402 </span>            :         union {
<span class="lineNum">    1403 </span>            :                 int i;
<span class="lineNum">    1404 </span>            :                 guint8 *p;
<span class="lineNum">    1405 </span>            :                 MonoInst *label;
<span class="lineNum">    1406 </span>            :         } ip;
<span class="lineNum">    1407 </span>            : 
<span class="lineNum">    1408 </span>            :         MonoJumpInfoType type;
<span class="lineNum">    1409 </span>            :         union {
<span class="lineNum">    1410 </span>            :                 gconstpointer   target;
<span class="lineNum">    1411 </span>            : #if SIZEOF_VOID_P == 8
<span class="lineNum">    1412 </span>            :                 gint64          offset;
<span class="lineNum">    1413 </span>            : #else
<span class="lineNum">    1414 </span>            :                 int             offset;
<span class="lineNum">    1415 </span>            : #endif
<span class="lineNum">    1416 </span>            :                 int index;
<span class="lineNum">    1417 </span>            :                 MonoBasicBlock *bb;
<span class="lineNum">    1418 </span>            :                 MonoInst       *inst;
<span class="lineNum">    1419 </span>            :                 MonoMethod     *method;
<span class="lineNum">    1420 </span>            :                 MonoClass      *klass;
<span class="lineNum">    1421 </span>            :                 MonoClassField *field;
<span class="lineNum">    1422 </span>            :                 MonoImage      *image;
<span class="lineNum">    1423 </span>            :                 MonoVTable     *vtable;
<span class="lineNum">    1424 </span>            :                 const char     *name;
<span class="lineNum">    1425 </span>            :                 MonoJumpInfoToken  *token;
<span class="lineNum">    1426 </span>            :                 MonoJumpInfoBBTable *table;
<span class="lineNum">    1427 </span>            :                 MonoJumpInfoRgctxEntry *rgctx_entry;
<span class="lineNum">    1428 </span>            :                 MonoJumpInfoImtTramp *imt_tramp;
<span class="lineNum">    1429 </span>            :                 MonoJumpInfoGSharedVtCall *gsharedvt;
<span class="lineNum">    1430 </span>            :                 MonoGSharedVtMethodInfo *gsharedvt_method;
<span class="lineNum">    1431 </span>            :                 MonoMethodSignature *sig;
<span class="lineNum">    1432 </span>            :                 MonoDelegateClassMethodPair *del_tramp;
<span class="lineNum">    1433 </span>            :                 /* MONO_PATCH_INFO_VIRT_METHOD */
<span class="lineNum">    1434 </span>            :                 MonoJumpInfoVirtMethod *virt_method;
<span class="lineNum">    1435 </span>            :         } data;
<span class="lineNum">    1436 </span>            : };
<span class="lineNum">    1437 </span>            :  
<span class="lineNum">    1438 </span>            : /*
<span class="lineNum">    1439 </span>            :  * Contains information for computing the
<span class="lineNum">    1440 </span>            :  * property given by INFO_TYPE of the runtime
<span class="lineNum">    1441 </span>            :  * object described by DATA.
<span class="lineNum">    1442 </span>            :  */
<span class="lineNum">    1443 </span>            : struct MonoJumpInfoRgctxEntry {
<span class="lineNum">    1444 </span>            :         MonoMethod *method;
<span class="lineNum">    1445 </span>            :         gboolean in_mrgctx;
<span class="lineNum">    1446 </span>            :         MonoJumpInfo *data; /* describes the data to be loaded */
<span class="lineNum">    1447 </span>            :         MonoRgctxInfoType info_type;
<span class="lineNum">    1448 </span>            : };
<span class="lineNum">    1449 </span>            : 
<span class="lineNum">    1450 </span>            : /* Contains information about a gsharedvt call */
<span class="lineNum">    1451 </span>            : struct MonoJumpInfoGSharedVtCall {
<span class="lineNum">    1452 </span>            :         /* The original signature of the call */
<span class="lineNum">    1453 </span>            :         MonoMethodSignature *sig;
<span class="lineNum">    1454 </span>            :         /* The method which is called */
<span class="lineNum">    1455 </span>            :         MonoMethod *method;
<span class="lineNum">    1456 </span>            : };
<span class="lineNum">    1457 </span>            : 
<span class="lineNum">    1458 </span>            : typedef enum {
<span class="lineNum">    1459 </span>            :         MONO_TRAMPOLINE_JIT,
<span class="lineNum">    1460 </span>            :         MONO_TRAMPOLINE_JUMP,
<span class="lineNum">    1461 </span>            :         MONO_TRAMPOLINE_RGCTX_LAZY_FETCH,
<span class="lineNum">    1462 </span>            :         MONO_TRAMPOLINE_AOT,
<span class="lineNum">    1463 </span>            :         MONO_TRAMPOLINE_AOT_PLT,
<span class="lineNum">    1464 </span>            :         MONO_TRAMPOLINE_DELEGATE,
<span class="lineNum">    1465 </span>            :         MONO_TRAMPOLINE_RESTORE_STACK_PROT,
<span class="lineNum">    1466 </span>            :         MONO_TRAMPOLINE_GENERIC_VIRTUAL_REMOTING,
<span class="lineNum">    1467 </span>            :         MONO_TRAMPOLINE_VCALL,
<span class="lineNum">    1468 </span>            :         MONO_TRAMPOLINE_HANDLER_BLOCK_GUARD,
<span class="lineNum">    1469 </span>            :         MONO_TRAMPOLINE_NUM
<span class="lineNum">    1470 </span>            : } MonoTrampolineType;
<span class="lineNum">    1471 </span>            : 
<span class="lineNum">    1472 </span>            : /* These trampolines return normally to their caller */
<span class="lineNum">    1473 </span>            : #define MONO_TRAMPOLINE_TYPE_MUST_RETURN(t)             \
<span class="lineNum">    1474 </span>            :         ((t) == MONO_TRAMPOLINE_RESTORE_STACK_PROT ||   \
<span class="lineNum">    1475 </span>            :          (t) == MONO_TRAMPOLINE_RGCTX_LAZY_FETCH)
<span class="lineNum">    1476 </span>            : 
<span class="lineNum">    1477 </span>            : /* These trampolines receive an argument directly in a register */
<span class="lineNum">    1478 </span>            : #define MONO_TRAMPOLINE_TYPE_HAS_ARG(t)         \
<span class="lineNum">    1479 </span>            :         ((t) == MONO_TRAMPOLINE_HANDLER_BLOCK_GUARD)
<span class="lineNum">    1480 </span>            : 
<span class="lineNum">    1481 </span>            : /* optimization flags */
<span class="lineNum">    1482 </span>            : #define OPTFLAG(id,shift,name,descr) MONO_OPT_ ## id = 1 &lt;&lt; shift,
<span class="lineNum">    1483 </span>            : enum {
<span class="lineNum">    1484 </span>            : #include &quot;optflags-def.h&quot;
<span class="lineNum">    1485 </span>            :         MONO_OPT_LAST
<span class="lineNum">    1486 </span>            : };
<span class="lineNum">    1487 </span>            : 
<span class="lineNum">    1488 </span>            : /*
<span class="lineNum">    1489 </span>            :  * This structure represents a JIT backend.
<span class="lineNum">    1490 </span>            :  */
<span class="lineNum">    1491 </span>            : typedef struct {
<span class="lineNum">    1492 </span>            :         guint            have_card_table_wb : 1;
<span class="lineNum">    1493 </span>            :         guint            have_op_generic_class_init : 1;
<span class="lineNum">    1494 </span>            :         guint            emulate_mul_div : 1;
<span class="lineNum">    1495 </span>            :         guint            emulate_div : 1;
<span class="lineNum">    1496 </span>            :         guint            emulate_long_shift_opts : 1;
<span class="lineNum">    1497 </span>            :         guint            have_objc_get_selector : 1;
<span class="lineNum">    1498 </span>            :         guint            have_generalized_imt_trampoline : 1;
<span class="lineNum">    1499 </span>            :         guint            have_liverange_ops: 1;
<span class="lineNum">    1500 </span>            :         guint            have_op_tail_call : 1;
<span class="lineNum">    1501 </span>            :         guint            have_dummy_init : 1;
<span class="lineNum">    1502 </span>            :         guint            gshared_supported : 1;
<span class="lineNum">    1503 </span>            :         guint            use_fpstack : 1;
<span class="lineNum">    1504 </span>            :         guint            ilp32 : 1;
<span class="lineNum">    1505 </span>            :         guint            need_got_var : 1;
<span class="lineNum">    1506 </span>            :         guint            need_div_check : 1;
<span class="lineNum">    1507 </span>            :         guint            no_unaligned_access : 1;
<span class="lineNum">    1508 </span>            :         guint            disable_div_with_mul : 1;
<span class="lineNum">    1509 </span>            :         int              monitor_enter_adjustment;
<span class="lineNum">    1510 </span>            :         int              dyn_call_param_area;
<span class="lineNum">    1511 </span>            : } MonoBackend;
<span class="lineNum">    1512 </span>            : 
<span class="lineNum">    1513 </span>            : /* Flags for mini_method_compile () */
<span class="lineNum">    1514 </span>            : typedef enum {
<span class="lineNum">    1515 </span>            :         /* Whenever to run cctors during JITting */
<span class="lineNum">    1516 </span>            :         JIT_FLAG_RUN_CCTORS = (1 &lt;&lt; 0),
<span class="lineNum">    1517 </span>            :         /* Whenever this is an AOT compilation */
<span class="lineNum">    1518 </span>            :         JIT_FLAG_AOT = (1 &lt;&lt; 1),
<span class="lineNum">    1519 </span>            :         /* Whenever this is a full AOT compilation */
<span class="lineNum">    1520 </span>            :         JIT_FLAG_FULL_AOT = (1 &lt;&lt; 2),
<span class="lineNum">    1521 </span>            :         /* Whenever to compile with LLVM */
<span class="lineNum">    1522 </span>            :         JIT_FLAG_LLVM = (1 &lt;&lt; 3),
<span class="lineNum">    1523 </span>            :         /* Whenever to disable direct calls to icall functions */
<span class="lineNum">    1524 </span>            :         JIT_FLAG_NO_DIRECT_ICALLS = (1 &lt;&lt; 4),
<span class="lineNum">    1525 </span>            :         /* Emit explicit null checks */
<span class="lineNum">    1526 </span>            :         JIT_FLAG_EXPLICIT_NULL_CHECKS = (1 &lt;&lt; 5),
<span class="lineNum">    1527 </span>            :         /* Whenever to compile in llvm-only mode */
<span class="lineNum">    1528 </span>            :         JIT_FLAG_LLVM_ONLY = (1 &lt;&lt; 6),
<span class="lineNum">    1529 </span>            :         /* Whenever calls to pinvoke functions are made directly */
<span class="lineNum">    1530 </span>            :         JIT_FLAG_DIRECT_PINVOKE = (1 &lt;&lt; 7)
<span class="lineNum">    1531 </span>            : } JitFlags;
<span class="lineNum">    1532 </span>            : 
<span class="lineNum">    1533 </span>            : /* Bit-fields in the MonoBasicBlock.region */
<span class="lineNum">    1534 </span>            : #define MONO_REGION_TRY       0
<span class="lineNum">    1535 </span>            : #define MONO_REGION_FINALLY  16
<span class="lineNum">    1536 </span>            : #define MONO_REGION_CATCH    32
<span class="lineNum">    1537 </span>            : #define MONO_REGION_FAULT    64         /* Currently unused */
<span class="lineNum">    1538 </span>            : #define MONO_REGION_FILTER  128
<span class="lineNum">    1539 </span>            : 
<span class="lineNum">    1540 </span>            : #define MONO_BBLOCK_IS_IN_REGION(bblock, regtype) (((bblock)-&gt;region &amp; (0xf &lt;&lt; 4)) == (regtype))
<span class="lineNum">    1541 </span>            : 
<span class="lineNum">    1542 </span>            : #define MONO_REGION_FLAGS(region) ((region) &amp; 0x7)
<span class="lineNum">    1543 </span>            : #define MONO_REGION_CLAUSE_INDEX(region) (((region) &gt;&gt; 8) - 1)
<span class="lineNum">    1544 </span>            : 
<span class="lineNum">    1545 </span>            : #define get_vreg_to_inst(cfg, vreg) ((vreg) &lt; (cfg)-&gt;vreg_to_inst_len ? (cfg)-&gt;vreg_to_inst [(vreg)] : NULL)
<span class="lineNum">    1546 </span>            : 
<span class="lineNum">    1547 </span>            : #define vreg_is_volatile(cfg, vreg) (G_UNLIKELY (get_vreg_to_inst ((cfg), (vreg)) &amp;&amp; (get_vreg_to_inst ((cfg), (vreg))-&gt;flags &amp; (MONO_INST_VOLATILE|MONO_INST_INDIRECT))))
<span class="lineNum">    1548 </span>            : 
<span class="lineNum">    1549 </span>            : #define vreg_is_ref(cfg, vreg) ((vreg) &lt; (cfg)-&gt;vreg_is_ref_len ? (cfg)-&gt;vreg_is_ref [(vreg)] : 0)
<span class="lineNum">    1550 </span>            : #define vreg_is_mp(cfg, vreg) ((vreg) &lt; (cfg)-&gt;vreg_is_mp_len ? (cfg)-&gt;vreg_is_mp [(vreg)] : 0)
<span class="lineNum">    1551 </span>            : 
<span class="lineNum">    1552 </span>            : /*
<span class="lineNum">    1553 </span>            :  * Control Flow Graph and compilation unit information
<span class="lineNum">    1554 </span>            :  */
<span class="lineNum">    1555 </span>            : typedef struct {
<span class="lineNum">    1556 </span>            :         MonoMethod      *method;
<span class="lineNum">    1557 </span>            :         MonoMethodHeader *header;
<span class="lineNum">    1558 </span>            :         MonoMemPool     *mempool;
<span class="lineNum">    1559 </span>            :         MonoInst       **varinfo;
<span class="lineNum">    1560 </span>            :         MonoMethodVar   *vars;
<span class="lineNum">    1561 </span>            :         MonoInst        *ret;
<span class="lineNum">    1562 </span>            :         MonoBasicBlock  *bb_entry;
<span class="lineNum">    1563 </span>            :         MonoBasicBlock  *bb_exit;
<span class="lineNum">    1564 </span>            :         MonoBasicBlock  *bb_init;
<span class="lineNum">    1565 </span>            :         MonoBasicBlock **bblocks;
<span class="lineNum">    1566 </span>            :         MonoBasicBlock **cil_offset_to_bb;
<span class="lineNum">    1567 </span>            :         MonoMemPool     *state_pool; /* used by instruction selection */
<span class="lineNum">    1568 </span>            :         MonoBasicBlock  *cbb;        /* used by instruction selection */
<span class="lineNum">    1569 </span>            :         MonoInst        *prev_ins;   /* in decompose */
<span class="lineNum">    1570 </span>            :         MonoJumpInfo    *patch_info;
<span class="lineNum">    1571 </span>            :         MonoJitInfo     *jit_info;
<span class="lineNum">    1572 </span>            :         MonoJitDynamicMethodInfo *dynamic_info;
<span class="lineNum">    1573 </span>            :         guint            num_bblocks, max_block_num;
<span class="lineNum">    1574 </span>            :         guint            locals_start;
<span class="lineNum">    1575 </span>            :         guint            num_varinfo; /* used items in varinfo */
<span class="lineNum">    1576 </span>            :         guint            varinfo_count; /* total storage in varinfo */
<span class="lineNum">    1577 </span>            :         gint             stack_offset;
<span class="lineNum">    1578 </span>            :         gint             max_ireg;
<span class="lineNum">    1579 </span>            :         gint             cil_offset_to_bb_len;
<span class="lineNum">    1580 </span>            :         MonoRegState    *rs;
<span class="lineNum">    1581 </span>            :         MonoSpillInfo   *spill_info [16]; /* machine register spills */
<span class="lineNum">    1582 </span>            :         gint             spill_count;
<span class="lineNum">    1583 </span>            :         gint             spill_info_len [16];
<span class="lineNum">    1584 </span>            :         /* unsigned char   *cil_code; */
<span class="lineNum">    1585 </span>            :         MonoMethod      *inlined_method; /* the method which is currently inlined */
<span class="lineNum">    1586 </span>            :         MonoInst        *domainvar; /* a cache for the current domain */
<span class="lineNum">    1587 </span>            :         MonoInst        *got_var; /* Global Offset Table variable */
<span class="lineNum">    1588 </span>            :         MonoInst        **locals;
<span class="lineNum">    1589 </span>            :         MonoInst        *rgctx_var; /* Runtime generic context variable (for static generic methods) */
<span class="lineNum">    1590 </span>            :         MonoInst        **args;
<span class="lineNum">    1591 </span>            :         MonoType        **arg_types;
<span class="lineNum">    1592 </span>            :         MonoMethod      *current_method; /* The method currently processed by method_to_ir () */
<span class="lineNum">    1593 </span>            :         MonoMethod      *method_to_register; /* The method to register in JIT info tables */
<span class="lineNum">    1594 </span>            :         MonoGenericContext *generic_context;
<span class="lineNum">    1595 </span>            :         MonoInst        *this_arg;
<span class="lineNum">    1596 </span>            : 
<span class="lineNum">    1597 </span>            :         MonoBackend *backend;
<span class="lineNum">    1598 </span>            : 
<span class="lineNum">    1599 </span>            :         /* 
<span class="lineNum">    1600 </span>            :          * This variable represents the hidden argument holding the vtype
<span class="lineNum">    1601 </span>            :          * return address. If the method returns something other than a vtype, or
<span class="lineNum">    1602 </span>            :          * the vtype is returned in registers this is NULL.
<span class="lineNum">    1603 </span>            :          */
<span class="lineNum">    1604 </span>            :         MonoInst        *vret_addr;
<span class="lineNum">    1605 </span>            : 
<span class="lineNum">    1606 </span>            :         /*
<span class="lineNum">    1607 </span>            :          * This is used to initialize the cil_code field of MonoInst's.
<span class="lineNum">    1608 </span>            :          */
<span class="lineNum">    1609 </span>            :         const unsigned char *ip;
<span class="lineNum">    1610 </span>            :         
<span class="lineNum">    1611 </span>            :         struct MonoAliasingInformation *aliasing_info;
<span class="lineNum">    1612 </span>            : 
<span class="lineNum">    1613 </span>            :         /* A hashtable of region ID-&gt; SP var mappings */
<span class="lineNum">    1614 </span>            :         /* An SP var is a place to store the stack pointer (used by handlers)*/
<span class="lineNum">    1615 </span>            :         GHashTable      *spvars;
<span class="lineNum">    1616 </span>            : 
<span class="lineNum">    1617 </span>            :         /* A hashtable of region ID -&gt; EX var mappings */
<span class="lineNum">    1618 </span>            :         /* An EX var stores the exception object passed to catch/filter blocks */
<span class="lineNum">    1619 </span>            :         GHashTable      *exvars;
<span class="lineNum">    1620 </span>            : 
<span class="lineNum">    1621 </span>            :         GList           *ldstr_list; /* used by AOT */
<span class="lineNum">    1622 </span>            :         
<span class="lineNum">    1623 </span>            :         MonoDomain      *domain;
<span class="lineNum">    1624 </span>            : 
<span class="lineNum">    1625 </span>            :         guint            real_offset;
<span class="lineNum">    1626 </span>            :         GHashTable      *cbb_hash;
<span class="lineNum">    1627 </span>            : 
<span class="lineNum">    1628 </span>            :         /* The current virtual register number */
<span class="lineNum">    1629 </span>            :         guint32 next_vreg;
<span class="lineNum">    1630 </span>            : 
<span class="lineNum">    1631 </span>            :         MonoGenericSharingContext gsctx;
<span class="lineNum">    1632 </span>            :         MonoGenericContext *gsctx_context;
<span class="lineNum">    1633 </span>            : 
<span class="lineNum">    1634 </span>            :         MonoGSharedVtMethodInfo *gsharedvt_info;
<span class="lineNum">    1635 </span>            : 
<span class="lineNum">    1636 </span>            :         /* Points to the gsharedvt locals area at runtime */
<span class="lineNum">    1637 </span>            :         MonoInst *gsharedvt_locals_var;
<span class="lineNum">    1638 </span>            : 
<span class="lineNum">    1639 </span>            :         /* The localloc instruction used to initialize gsharedvt_locals_var */
<span class="lineNum">    1640 </span>            :         MonoInst *gsharedvt_locals_var_ins;
<span class="lineNum">    1641 </span>            : 
<span class="lineNum">    1642 </span>            :         /* Points to a MonoGSharedVtMethodRuntimeInfo at runtime */
<span class="lineNum">    1643 </span>            :         MonoInst *gsharedvt_info_var;
<span class="lineNum">    1644 </span>            : 
<span class="lineNum">    1645 </span>            :         /* For native-to-managed wrappers, CEE_MONO_JIT_(AT|DE)TACH opcodes */
<span class="lineNum">    1646 </span>            :         MonoInst *orig_domain_var;
<span class="lineNum">    1647 </span>            : 
<span class="lineNum">    1648 </span>            :         MonoInst *lmf_var;
<span class="lineNum">    1649 </span>            :         MonoInst *lmf_addr_var;
<span class="lineNum">    1650 </span>            : 
<span class="lineNum">    1651 </span>            :         MonoInst *stack_inbalance_var;
<span class="lineNum">    1652 </span>            : 
<span class="lineNum">    1653 </span>            :         unsigned char   *cil_start;
<span class="lineNum">    1654 </span>            : #ifdef __native_client_codegen__
<span class="lineNum">    1655 </span>            :         /* this alloc is not aligned, native_code */
<span class="lineNum">    1656 </span>            :         /* is the 32-byte aligned version of this */
<span class="lineNum">    1657 </span>            :         unsigned char   *native_code_alloc;
<span class="lineNum">    1658 </span>            : #endif
<span class="lineNum">    1659 </span>            :         unsigned char   *native_code;
<span class="lineNum">    1660 </span>            :         guint            code_size;
<span class="lineNum">    1661 </span>            :         guint            code_len;
<span class="lineNum">    1662 </span>            :         guint            prolog_end;
<span class="lineNum">    1663 </span>            :         guint            epilog_begin;
<span class="lineNum">    1664 </span>            :         guint            epilog_end;
<span class="lineNum">    1665 </span>            :         regmask_t        used_int_regs;
<span class="lineNum">    1666 </span>            :         guint32          opt;
<span class="lineNum">    1667 </span>            :         guint32          prof_options;
<span class="lineNum">    1668 </span>            :         guint32          flags;
<span class="lineNum">    1669 </span>            :         guint32          comp_done;
<span class="lineNum">    1670 </span>            :         guint32          verbose_level;
<span class="lineNum">    1671 </span>            :         guint32          stack_usage;
<span class="lineNum">    1672 </span>            :         guint32          param_area;
<span class="lineNum">    1673 </span>            :         guint32          frame_reg;
<span class="lineNum">    1674 </span>            :         gint32           sig_cookie;
<span class="lineNum">    1675 </span>            :         guint            disable_aot : 1;
<span class="lineNum">    1676 </span>            :         guint            disable_ssa : 1;
<span class="lineNum">    1677 </span>            :         guint            disable_llvm : 1;
<span class="lineNum">    1678 </span>            :         guint            enable_extended_bblocks : 1;
<span class="lineNum">    1679 </span>            :         guint            run_cctors : 1;
<span class="lineNum">    1680 </span>            :         guint            need_lmf_area : 1;
<span class="lineNum">    1681 </span>            :         guint            compile_aot : 1;
<span class="lineNum">    1682 </span>            :         guint            full_aot : 1;
<span class="lineNum">    1683 </span>            :         guint            compile_llvm : 1;
<span class="lineNum">    1684 </span>            :         guint            got_var_allocated : 1;
<span class="lineNum">    1685 </span>            :         guint            ret_var_is_local : 1;
<span class="lineNum">    1686 </span>            :         guint            ret_var_set : 1;
<span class="lineNum">    1687 </span>            :         guint            unverifiable : 1;
<span class="lineNum">    1688 </span>            :         guint            skip_visibility : 1;
<span class="lineNum">    1689 </span>            :         guint            disable_reuse_registers : 1;
<span class="lineNum">    1690 </span>            :         guint            disable_reuse_stack_slots : 1;
<span class="lineNum">    1691 </span>            :         guint            disable_reuse_ref_stack_slots : 1;
<span class="lineNum">    1692 </span>            :         guint            disable_ref_noref_stack_slot_share : 1;
<span class="lineNum">    1693 </span>            :         guint            disable_initlocals_opt : 1;
<span class="lineNum">    1694 </span>            :         guint            disable_initlocals_opt_refs : 1;
<span class="lineNum">    1695 </span>            :         guint            disable_omit_fp : 1;
<span class="lineNum">    1696 </span>            :         guint            disable_vreg_to_lvreg : 1;
<span class="lineNum">    1697 </span>            :         guint            disable_deadce_vars : 1;
<span class="lineNum">    1698 </span>            :         guint            disable_out_of_line_bblocks : 1;
<span class="lineNum">    1699 </span>            :         guint            disable_direct_icalls : 1;
<span class="lineNum">    1700 </span>            :         guint            disable_gc_safe_points : 1;
<span class="lineNum">    1701 </span>            :         guint            direct_pinvoke : 1;
<span class="lineNum">    1702 </span>            :         guint            create_lmf_var : 1;
<span class="lineNum">    1703 </span>            :         /*
<span class="lineNum">    1704 </span>            :          * When this is set, the code to push/pop the LMF from the LMF stack is generated as IR
<span class="lineNum">    1705 </span>            :          * instead of being generated in emit_prolog ()/emit_epilog ().
<span class="lineNum">    1706 </span>            :          */
<span class="lineNum">    1707 </span>            :         guint            lmf_ir : 1;
<span class="lineNum">    1708 </span>            :         /*
<span class="lineNum">    1709 </span>            :          * Whenever to use the mono_lmf TLS variable instead of indirection through the
<span class="lineNum">    1710 </span>            :          * mono_lmf_addr TLS variable.
<span class="lineNum">    1711 </span>            :          */
<span class="lineNum">    1712 </span>            :         guint            lmf_ir_mono_lmf : 1;
<span class="lineNum">    1713 </span>            :         guint            gen_write_barriers : 1;
<span class="lineNum">    1714 </span>            :         guint            init_ref_vars : 1;
<span class="lineNum">    1715 </span>            :         guint            extend_live_ranges : 1;
<span class="lineNum">    1716 </span>            :         guint            compute_precise_live_ranges : 1;
<span class="lineNum">    1717 </span>            :         guint            has_got_slots : 1;
<span class="lineNum">    1718 </span>            :         guint            uses_rgctx_reg : 1;
<span class="lineNum">    1719 </span>            :         guint            uses_vtable_reg : 1;
<span class="lineNum">    1720 </span>            :         guint            uses_simd_intrinsics : 1;
<span class="lineNum">    1721 </span>            :         guint            keep_cil_nops : 1;
<span class="lineNum">    1722 </span>            :         guint            gen_seq_points : 1;
<span class="lineNum">    1723 </span>            :         /* Generate seq points for use by the debugger */
<span class="lineNum">    1724 </span>            :         guint            gen_sdb_seq_points : 1;
<span class="lineNum">    1725 </span>            :         guint            explicit_null_checks : 1;
<span class="lineNum">    1726 </span>            :         guint            compute_gc_maps : 1;
<span class="lineNum">    1727 </span>            :         guint            soft_breakpoints : 1;
<span class="lineNum">    1728 </span>            :         guint            arch_eh_jit_info : 1;
<span class="lineNum">    1729 </span>            :         guint            has_emulated_ops : 1;
<span class="lineNum">    1730 </span>            :         guint            has_indirection : 1;
<span class="lineNum">    1731 </span>            :         guint            has_atomic_add_i4 : 1;
<span class="lineNum">    1732 </span>            :         guint            has_atomic_exchange_i4 : 1;
<span class="lineNum">    1733 </span>            :         guint            has_atomic_cas_i4 : 1;
<span class="lineNum">    1734 </span>            :         guint            check_pinvoke_callconv : 1;
<span class="lineNum">    1735 </span>            :         guint            has_unwind_info_for_epilog : 1;
<span class="lineNum">    1736 </span>            :         guint            disable_inline : 1;
<span class="lineNum">    1737 </span>            :         /* Disable inlining into caller */
<span class="lineNum">    1738 </span>            :         guint            no_inline : 1;
<span class="lineNum">    1739 </span>            :         guint            gshared : 1;
<span class="lineNum">    1740 </span>            :         guint            gsharedvt : 1;
<span class="lineNum">    1741 </span>            :         guint            r4fp : 1;
<span class="lineNum">    1742 </span>            :         guint            llvm_only : 1;
<span class="lineNum">    1743 </span>            :         int              r4_stack_type;
<span class="lineNum">    1744 </span>            :         gpointer         debug_info;
<span class="lineNum">    1745 </span>            :         guint32          lmf_offset;
<span class="lineNum">    1746 </span>            :     guint16          *intvars;
<span class="lineNum">    1747 </span>            :         MonoProfileCoverageInfo *coverage_info;
<span class="lineNum">    1748 </span>            :         GHashTable       *token_info_hash;
<span class="lineNum">    1749 </span>            :         MonoCompileArch  arch;
<span class="lineNum">    1750 </span>            :         guint32          inline_depth;
<span class="lineNum">    1751 </span>            :         /* Size of memory reserved for thunks */
<span class="lineNum">    1752 </span>            :         int              thunk_area;
<span class="lineNum">    1753 </span>            :         /* Thunks */
<span class="lineNum">    1754 </span>            :         guint8          *thunks;
<span class="lineNum">    1755 </span>            :         /* Offset between the start of code and the thunks area */
<span class="lineNum">    1756 </span>            :         int              thunks_offset;
<span class="lineNum">    1757 </span>            :         MonoExceptionType exception_type;       /* MONO_EXCEPTION_* */
<span class="lineNum">    1758 </span>            :         guint32          exception_data;
<span class="lineNum">    1759 </span>            :         char*            exception_message;
<span class="lineNum">    1760 </span>            :         gpointer         exception_ptr;
<span class="lineNum">    1761 </span>            : 
<span class="lineNum">    1762 </span>            :         guint8 *         encoded_unwind_ops;
<span class="lineNum">    1763 </span>            :         guint32          encoded_unwind_ops_len;
<span class="lineNum">    1764 </span>            :         GSList*          unwind_ops;
<span class="lineNum">    1765 </span>            : 
<span class="lineNum">    1766 </span>            :         GList*           dont_inline;
<span class="lineNum">    1767 </span>            : 
<span class="lineNum">    1768 </span>            :         /* Fields used by the local reg allocator */
<span class="lineNum">    1769 </span>            :         void*            reginfo;
<span class="lineNum">    1770 </span>            :         int              reginfo_len;
<span class="lineNum">    1771 </span>            : 
<span class="lineNum">    1772 </span>            :         /* Maps vregs to their associated MonoInst's */
<span class="lineNum">    1773 </span>            :         /* vregs with an associated MonoInst are 'global' while others are 'local' */
<span class="lineNum">    1774 </span>            :         MonoInst **vreg_to_inst;
<span class="lineNum">    1775 </span>            : 
<span class="lineNum">    1776 </span>            :         /* Size of above array */
<span class="lineNum">    1777 </span>            :         guint32 vreg_to_inst_len;
<span class="lineNum">    1778 </span>            : 
<span class="lineNum">    1779 </span>            :         /* Marks vregs which hold a GC ref */
<span class="lineNum">    1780 </span>            :         /* FIXME: Use a bitmap */
<span class="lineNum">    1781 </span>            :         gboolean *vreg_is_ref;
<span class="lineNum">    1782 </span>            : 
<span class="lineNum">    1783 </span>            :         /* Size of above array */
<span class="lineNum">    1784 </span>            :         guint32 vreg_is_ref_len;
<span class="lineNum">    1785 </span>            : 
<span class="lineNum">    1786 </span>            :         /* Marks vregs which hold a managed pointer */
<span class="lineNum">    1787 </span>            :         /* FIXME: Use a bitmap */
<span class="lineNum">    1788 </span>            :         gboolean *vreg_is_mp;
<span class="lineNum">    1789 </span>            : 
<span class="lineNum">    1790 </span>            :         /* Size of above array */
<span class="lineNum">    1791 </span>            :         guint32 vreg_is_mp_len;
<span class="lineNum">    1792 </span>            : 
<span class="lineNum">    1793 </span>            :         /* 
<span class="lineNum">    1794 </span>            :          * The original method to compile, differs from 'method' when doing generic
<span class="lineNum">    1795 </span>            :          * sharing.
<span class="lineNum">    1796 </span>            :          */
<span class="lineNum">    1797 </span>            :         MonoMethod *orig_method;
<span class="lineNum">    1798 </span>            : 
<span class="lineNum">    1799 </span>            :         /* Patches which describe absolute addresses embedded into the native code */
<span class="lineNum">    1800 </span>            :         GHashTable *abs_patches;
<span class="lineNum">    1801 </span>            : 
<span class="lineNum">    1802 </span>            :         /* If the arch passes valuetypes by address, then for methods
<span class="lineNum">    1803 </span>            :            which use JMP the arch code should use these local
<span class="lineNum">    1804 </span>            :            variables to store the addresses of incoming valuetypes.
<span class="lineNum">    1805 </span>            :            The addresses should be stored in mono_arch_emit_prolog()
<span class="lineNum">    1806 </span>            :            and can be used when emitting code for OP_JMP.  See
<span class="lineNum">    1807 </span>            :            mini-ppc.c. */
<span class="lineNum">    1808 </span>            :         MonoInst **tailcall_valuetype_addrs;
<span class="lineNum">    1809 </span>            : 
<span class="lineNum">    1810 </span>            :         /* Used to implement move_i4_to_f on archs that can't do raw
<span class="lineNum">    1811 </span>            :         copy between an ireg and a freg. This is an int32 var.*/
<span class="lineNum">    1812 </span>            :         MonoInst *iconv_raw_var;
<span class="lineNum">    1813 </span>            : 
<span class="lineNum">    1814 </span>            :         /* Used to implement fconv_to_r8_x. This is a double (8 bytes) var.*/
<span class="lineNum">    1815 </span>            :         MonoInst *fconv_to_r8_x_var;
<span class="lineNum">    1816 </span>            : 
<span class="lineNum">    1817 </span>            :         /*Use to implement simd constructors. This is a vector (16 bytes) var.*/
<span class="lineNum">    1818 </span>            :         MonoInst *simd_ctor_var;
<span class="lineNum">    1819 </span>            : 
<span class="lineNum">    1820 </span>            :         /* Used to implement dyn_call */
<span class="lineNum">    1821 </span>            :         MonoInst *dyn_call_var;
<span class="lineNum">    1822 </span>            : 
<span class="lineNum">    1823 </span>            :         /*
<span class="lineNum">    1824 </span>            :          * List of sequence points represented as IL offset+native offset pairs.
<span class="lineNum">    1825 </span>            :          * Allocated using glib.
<span class="lineNum">    1826 </span>            :          * IL offset can be -1 or 0xffffff to refer to the sequence points
<span class="lineNum">    1827 </span>            :          * inside the prolog and epilog used to implement method entry/exit events.
<span class="lineNum">    1828 </span>            :          */
<span class="lineNum">    1829 </span>            :         GPtrArray *seq_points;
<span class="lineNum">    1830 </span>            : 
<span class="lineNum">    1831 </span>            :         /* The encoded sequence point info */
<span class="lineNum">    1832 </span>            :         struct MonoSeqPointInfo *seq_point_info;
<span class="lineNum">    1833 </span>            : 
<span class="lineNum">    1834 </span>            :         /* Method headers which need to be freed after compilation */
<span class="lineNum">    1835 </span>            :         GSList *headers_to_free;
<span class="lineNum">    1836 </span>            : 
<span class="lineNum">    1837 </span>            :         /* Used by AOT */
<span class="lineNum">    1838 </span>            :         guint32 got_offset, ex_info_offset, method_info_offset, method_index;
<span class="lineNum">    1839 </span>            :         /* Symbol used to refer to this method in generated assembly */
<span class="lineNum">    1840 </span>            :         char *asm_symbol;
<span class="lineNum">    1841 </span>            :         char *asm_debug_symbol;
<span class="lineNum">    1842 </span>            :         char *llvm_method_name;
<span class="lineNum">    1843 </span>            :         int castclass_cache_index;
<span class="lineNum">    1844 </span>            : 
<span class="lineNum">    1845 </span>            :         MonoJitExceptionInfo *llvm_ex_info;
<span class="lineNum">    1846 </span>            :         guint32 llvm_ex_info_len;
<span class="lineNum">    1847 </span>            :         int llvm_this_reg, llvm_this_offset;
<span class="lineNum">    1848 </span>            : 
<span class="lineNum">    1849 </span>            :         GSList *try_block_holes;
<span class="lineNum">    1850 </span>            : 
<span class="lineNum">    1851 </span>            :         /* DWARF location list for 'this' */
<span class="lineNum">    1852 </span>            :         GSList *this_loclist;
<span class="lineNum">    1853 </span>            : 
<span class="lineNum">    1854 </span>            :         /* DWARF location list for 'rgctx_var' */
<span class="lineNum">    1855 </span>            :         GSList *rgctx_loclist;
<span class="lineNum">    1856 </span>            : 
<span class="lineNum">    1857 </span>            :         int *gsharedvt_vreg_to_idx;
<span class="lineNum">    1858 </span>            : 
<span class="lineNum">    1859 </span>            :         GSList *signatures;
<span class="lineNum">    1860 </span>            : 
<span class="lineNum">    1861 </span>            :         /* GC Maps */
<span class="lineNum">    1862 </span>            :    
<span class="lineNum">    1863 </span>            :         /* The offsets of the locals area relative to the frame pointer */
<span class="lineNum">    1864 </span>            :         gint locals_min_stack_offset, locals_max_stack_offset;
<span class="lineNum">    1865 </span>            : 
<span class="lineNum">    1866 </span>            :         /* The current CFA rule */
<span class="lineNum">    1867 </span>            :         int cur_cfa_reg, cur_cfa_offset;
<span class="lineNum">    1868 </span>            : 
<span class="lineNum">    1869 </span>            :         /* The final CFA rule at the end of the prolog */
<span class="lineNum">    1870 </span>            :         int cfa_reg, cfa_offset;
<span class="lineNum">    1871 </span>            : 
<span class="lineNum">    1872 </span>            :         /* Points to a MonoCompileGC */
<span class="lineNum">    1873 </span>            :         gpointer gc_info;
<span class="lineNum">    1874 </span>            : 
<span class="lineNum">    1875 </span>            :         /*
<span class="lineNum">    1876 </span>            :          * The encoded GC map along with its size. This contains binary data so it can be saved in an AOT
<span class="lineNum">    1877 </span>            :          * image etc, but it requires a 4 byte alignment.
<span class="lineNum">    1878 </span>            :          */
<span class="lineNum">    1879 </span>            :         guint8 *gc_map;
<span class="lineNum">    1880 </span>            :         guint32 gc_map_size;
<span class="lineNum">    1881 </span>            : 
<span class="lineNum">    1882 </span>            :         /* Error handling */
<span class="lineNum">    1883 </span>            :         MonoError error;
<span class="lineNum">    1884 </span>            : 
<span class="lineNum">    1885 </span>            :         /* pointer to context datastructure used for graph dumping */
<span class="lineNum">    1886 </span>            :         MonoGraphDumper *gdump_ctx;
<span class="lineNum">    1887 </span>            : 
<span class="lineNum">    1888 </span>            :         /* Stats */
<span class="lineNum">    1889 </span>            :         int stat_allocate_var;
<span class="lineNum">    1890 </span>            :         int stat_locals_stack_size;
<span class="lineNum">    1891 </span>            :         int stat_basic_blocks;
<span class="lineNum">    1892 </span>            :         int stat_cil_code_size;
<span class="lineNum">    1893 </span>            :         int stat_n_regvars;
<span class="lineNum">    1894 </span>            :         int stat_inlineable_methods;
<span class="lineNum">    1895 </span>            :         int stat_inlined_methods;
<span class="lineNum">    1896 </span>            :         int stat_code_reallocs;
<span class="lineNum">    1897 </span>            : } MonoCompile;
<span class="lineNum">    1898 </span>            : 
<span class="lineNum">    1899 </span>            : typedef enum {
<span class="lineNum">    1900 </span>            :         MONO_CFG_HAS_ALLOCA = 1 &lt;&lt; 0,
<span class="lineNum">    1901 </span>            :         MONO_CFG_HAS_CALLS  = 1 &lt;&lt; 1,
<span class="lineNum">    1902 </span>            :         MONO_CFG_HAS_LDELEMA  = 1 &lt;&lt; 2,
<span class="lineNum">    1903 </span>            :         MONO_CFG_HAS_VARARGS  = 1 &lt;&lt; 3,
<span class="lineNum">    1904 </span>            :         MONO_CFG_HAS_TAIL     = 1 &lt;&lt; 4,
<span class="lineNum">    1905 </span>            :         MONO_CFG_HAS_FPOUT    = 1 &lt;&lt; 5, /* there are fp values passed in int registers */
<span class="lineNum">    1906 </span>            :         MONO_CFG_HAS_SPILLUP  = 1 &lt;&lt; 6, /* spill var slots are allocated from bottom to top */
<span class="lineNum">    1907 </span>            :         MONO_CFG_HAS_CHECK_THIS  = 1 &lt;&lt; 7,
<span class="lineNum">    1908 </span>            :         MONO_CFG_HAS_ARRAY_ACCESS = 1 &lt;&lt; 8,
<span class="lineNum">    1909 </span>            :         MONO_CFG_HAS_TYPE_CHECK = 1 &lt;&lt; 9
<span class="lineNum">    1910 </span>            : } MonoCompileFlags;
<span class="lineNum">    1911 </span>            : 
<span class="lineNum">    1912 </span>            : typedef struct {
<span class="lineNum">    1913 </span>            :         gint32 methods_compiled;
<span class="lineNum">    1914 </span>            :         gint32 methods_aot;
<span class="lineNum">    1915 </span>            :         gint32 methods_lookups;
<span class="lineNum">    1916 </span>            :         gint32 allocate_var;
<span class="lineNum">    1917 </span>            :         gint32 cil_code_size;
<span class="lineNum">    1918 </span>            :         gint32 native_code_size;
<span class="lineNum">    1919 </span>            :         gint32 code_reallocs;
<span class="lineNum">    1920 </span>            :         gint32 max_code_size_ratio;
<span class="lineNum">    1921 </span>            :         gint32 biggest_method_size;
<span class="lineNum">    1922 </span>            :         gint32 allocated_code_size;
<span class="lineNum">    1923 </span>            :         gint32 allocated_seq_points_size;
<span class="lineNum">    1924 </span>            :         gint32 inlineable_methods;
<span class="lineNum">    1925 </span>            :         gint32 inlined_methods;
<span class="lineNum">    1926 </span>            :         gint32 basic_blocks;
<span class="lineNum">    1927 </span>            :         gint32 max_basic_blocks;
<span class="lineNum">    1928 </span>            :         gint32 locals_stack_size;
<span class="lineNum">    1929 </span>            :         gint32 regvars;
<span class="lineNum">    1930 </span>            :         gint32 generic_virtual_invocations;
<span class="lineNum">    1931 </span>            :         gint32 alias_found;
<span class="lineNum">    1932 </span>            :         gint32 alias_removed;
<span class="lineNum">    1933 </span>            :         gint32 loads_eliminated;
<span class="lineNum">    1934 </span>            :         gint32 stores_eliminated;
<span class="lineNum">    1935 </span>            :         gint32 optimized_divisions;
<span class="lineNum">    1936 </span>            :         int methods_with_llvm;
<span class="lineNum">    1937 </span>            :         int methods_without_llvm;
<span class="lineNum">    1938 </span>            :         char *max_ratio_method;
<span class="lineNum">    1939 </span>            :         char *biggest_method;
<span class="lineNum">    1940 </span>            :         double jit_method_to_ir;
<span class="lineNum">    1941 </span>            :         double jit_liveness_handle_exception_clauses;
<span class="lineNum">    1942 </span>            :         double jit_handle_out_of_line_bblock;
<span class="lineNum">    1943 </span>            :         double jit_decompose_long_opts;
<span class="lineNum">    1944 </span>            :         double jit_decompose_typechecks;
<span class="lineNum">    1945 </span>            :         double jit_local_cprop;
<span class="lineNum">    1946 </span>            :         double jit_local_emulate_ops;
<span class="lineNum">    1947 </span>            :         double jit_optimize_branches;
<span class="lineNum">    1948 </span>            :         double jit_handle_global_vregs;
<span class="lineNum">    1949 </span>            :         double jit_local_deadce;
<span class="lineNum">    1950 </span>            :         double jit_local_alias_analysis;
<span class="lineNum">    1951 </span>            :         double jit_if_conversion;
<span class="lineNum">    1952 </span>            :         double jit_bb_ordering;
<span class="lineNum">    1953 </span>            :         double jit_compile_dominator_info;
<span class="lineNum">    1954 </span>            :         double jit_compute_natural_loops;
<span class="lineNum">    1955 </span>            :         double jit_insert_safepoints;
<span class="lineNum">    1956 </span>            :         double jit_ssa_compute;
<span class="lineNum">    1957 </span>            :         double jit_ssa_cprop;
<span class="lineNum">    1958 </span>            :         double jit_ssa_deadce;
<span class="lineNum">    1959 </span>            :         double jit_perform_abc_removal;
<span class="lineNum">    1960 </span>            :         double jit_ssa_remove;
<span class="lineNum">    1961 </span>            :         double jit_local_cprop2;
<span class="lineNum">    1962 </span>            :         double jit_handle_global_vregs2;
<span class="lineNum">    1963 </span>            :         double jit_local_deadce2;
<span class="lineNum">    1964 </span>            :         double jit_optimize_branches2;
<span class="lineNum">    1965 </span>            :         double jit_decompose_vtype_opts;
<span class="lineNum">    1966 </span>            :         double jit_decompose_array_access_opts;
<span class="lineNum">    1967 </span>            :         double jit_liveness_handle_exception_clauses2;
<span class="lineNum">    1968 </span>            :         double jit_analyze_liveness;
<span class="lineNum">    1969 </span>            :         double jit_linear_scan;
<span class="lineNum">    1970 </span>            :         double jit_arch_allocate_vars;
<span class="lineNum">    1971 </span>            :         double jit_spill_global_vars;
<span class="lineNum">    1972 </span>            :         double jit_local_cprop3;
<span class="lineNum">    1973 </span>            :         double jit_local_deadce3;
<span class="lineNum">    1974 </span>            :         double jit_codegen;
<span class="lineNum">    1975 </span>            :         double jit_create_jit_info;
<span class="lineNum">    1976 </span>            :         double jit_gc_create_gc_map;
<span class="lineNum">    1977 </span>            :         double jit_save_seq_point_info;
<span class="lineNum">    1978 </span>            :         double jit_time;
<span class="lineNum">    1979 </span>            :         gboolean enabled;
<span class="lineNum">    1980 </span>            : } MonoJitStats;
<span class="lineNum">    1981 </span>            : 
<span class="lineNum">    1982 </span>            : extern MonoJitStats mono_jit_stats;
<span class="lineNum">    1983 </span>            : 
<span class="lineNum">    1984 </span>            : /* opcodes: value assigned after all the CIL opcodes */
<span class="lineNum">    1985 </span>            : #ifdef MINI_OP
<span class="lineNum">    1986 </span>            : #undef MINI_OP
<span class="lineNum">    1987 </span>            : #endif
<span class="lineNum">    1988 </span>            : #ifdef MINI_OP3
<span class="lineNum">    1989 </span>            : #undef MINI_OP3
<span class="lineNum">    1990 </span>            : #endif
<span class="lineNum">    1991 </span>            : #define MINI_OP(a,b,dest,src1,src2) a,
<span class="lineNum">    1992 </span>            : #define MINI_OP3(a,b,dest,src1,src2,src3) a,
<span class="lineNum">    1993 </span>            : enum {
<span class="lineNum">    1994 </span>            :         OP_START = MONO_CEE_LAST - 1,
<span class="lineNum">    1995 </span>            : #include &quot;mini-ops.h&quot;
<span class="lineNum">    1996 </span>            :         OP_LAST
<span class="lineNum">    1997 </span>            : };
<span class="lineNum">    1998 </span>            : #undef MINI_OP
<span class="lineNum">    1999 </span>            : #undef MINI_OP3
<span class="lineNum">    2000 </span>            : 
<span class="lineNum">    2001 </span>            : #if SIZEOF_VOID_P == 8
<span class="lineNum">    2002 </span>            : #define OP_PCONST OP_I8CONST
<span class="lineNum">    2003 </span>            : #define OP_DUMMY_PCONST OP_DUMMY_I8CONST
<span class="lineNum">    2004 </span>            : #define OP_PADD OP_LADD
<span class="lineNum">    2005 </span>            : #define OP_PADD_IMM OP_LADD_IMM
<span class="lineNum">    2006 </span>            : #define OP_PSUB_IMM OP_LSUB_IMM
<span class="lineNum">    2007 </span>            : #define OP_PAND_IMM OP_LAND_IMM
<span class="lineNum">    2008 </span>            : #define OP_PXOR_IMM OP_LXOR_IMM
<span class="lineNum">    2009 </span>            : #define OP_PSUB OP_LSUB
<span class="lineNum">    2010 </span>            : #define OP_PMUL OP_LMUL
<span class="lineNum">    2011 </span>            : #define OP_PMUL_IMM OP_LMUL_IMM
<span class="lineNum">    2012 </span>            : #define OP_PNEG OP_LNEG
<span class="lineNum">    2013 </span>            : #define OP_PCONV_TO_I1 OP_LCONV_TO_I1
<span class="lineNum">    2014 </span>            : #define OP_PCONV_TO_U1 OP_LCONV_TO_U1
<span class="lineNum">    2015 </span>            : #define OP_PCONV_TO_I2 OP_LCONV_TO_I2
<span class="lineNum">    2016 </span>            : #define OP_PCONV_TO_U2 OP_LCONV_TO_U2
<span class="lineNum">    2017 </span>            : #define OP_PCONV_TO_OVF_I1_UN OP_LCONV_TO_OVF_I1_UN
<span class="lineNum">    2018 </span>            : #define OP_PCONV_TO_OVF_I1 OP_LCONV_TO_OVF_I1
<span class="lineNum">    2019 </span>            : #define OP_PBEQ OP_LBEQ
<span class="lineNum">    2020 </span>            : #define OP_PCEQ OP_LCEQ
<span class="lineNum">    2021 </span>            : #define OP_PBNE_UN OP_LBNE_UN
<span class="lineNum">    2022 </span>            : #define OP_PBGE_UN OP_LBGE_UN
<span class="lineNum">    2023 </span>            : #define OP_PBLT_UN OP_LBLT_UN
<span class="lineNum">    2024 </span>            : #define OP_PBGE OP_LBGE
<span class="lineNum">    2025 </span>            : #define OP_STOREP_MEMBASE_REG OP_STOREI8_MEMBASE_REG
<span class="lineNum">    2026 </span>            : #define OP_STOREP_MEMBASE_IMM OP_STOREI8_MEMBASE_IMM
<span class="lineNum">    2027 </span>            : #else
<span class="lineNum">    2028 </span>            : #define OP_PCONST OP_ICONST
<span class="lineNum">    2029 </span>            : #define OP_DUMMY_PCONST OP_DUMMY_ICONST
<span class="lineNum">    2030 </span>            : #define OP_PADD OP_IADD
<span class="lineNum">    2031 </span>            : #define OP_PADD_IMM OP_IADD_IMM
<span class="lineNum">    2032 </span>            : #define OP_PSUB_IMM OP_ISUB_IMM
<span class="lineNum">    2033 </span>            : #define OP_PAND_IMM OP_IAND_IMM
<span class="lineNum">    2034 </span>            : #define OP_PXOR_IMM OP_IXOR_IMM
<span class="lineNum">    2035 </span>            : #define OP_PSUB OP_ISUB
<span class="lineNum">    2036 </span>            : #define OP_PMUL OP_IMUL
<span class="lineNum">    2037 </span>            : #define OP_PMUL_IMM OP_IMUL_IMM
<span class="lineNum">    2038 </span>            : #define OP_PNEG OP_INEG
<span class="lineNum">    2039 </span>            : #define OP_PCONV_TO_I1 OP_ICONV_TO_I1
<span class="lineNum">    2040 </span>            : #define OP_PCONV_TO_U1 OP_ICONV_TO_U1
<span class="lineNum">    2041 </span>            : #define OP_PCONV_TO_I2 OP_ICONV_TO_I2
<span class="lineNum">    2042 </span>            : #define OP_PCONV_TO_U2 OP_ICONV_TO_U2
<span class="lineNum">    2043 </span>            : #define OP_PCONV_TO_OVF_I1_UN OP_ICONV_TO_OVF_I1_UN
<span class="lineNum">    2044 </span>            : #define OP_PCONV_TO_OVF_I1 OP_ICONV_TO_OVF_I1
<span class="lineNum">    2045 </span>            : #define OP_PBEQ OP_IBEQ
<span class="lineNum">    2046 </span>            : #define OP_PCEQ OP_ICEQ
<span class="lineNum">    2047 </span>            : #define OP_PBNE_UN OP_IBNE_UN
<span class="lineNum">    2048 </span>            : #define OP_PBGE_UN OP_IBGE_UN
<span class="lineNum">    2049 </span>            : #define OP_PBLT_UN OP_IBLT_UN
<span class="lineNum">    2050 </span>            : #define OP_PBGE OP_IBGE
<span class="lineNum">    2051 </span>            : #define OP_STOREP_MEMBASE_REG OP_STOREI4_MEMBASE_REG
<span class="lineNum">    2052 </span>            : #define OP_STOREP_MEMBASE_IMM OP_STOREI4_MEMBASE_IMM
<span class="lineNum">    2053 </span>            : #endif
<span class="lineNum">    2054 </span>            : 
<span class="lineNum">    2055 </span>            : /* Opcodes to load/store regsize quantities */
<span class="lineNum">    2056 </span>            : #if defined (__mono_ilp32__)
<span class="lineNum">    2057 </span>            : #define OP_LOADR_MEMBASE OP_LOADI8_MEMBASE
<span class="lineNum">    2058 </span>            : #define OP_STORER_MEMBASE_REG OP_STOREI8_MEMBASE_REG
<span class="lineNum">    2059 </span>            : #else
<span class="lineNum">    2060 </span>            : #define OP_LOADR_MEMBASE OP_LOAD_MEMBASE
<span class="lineNum">    2061 </span>            : #define OP_STORER_MEMBASE_REG OP_STORE_MEMBASE_REG
<span class="lineNum">    2062 </span>            : #endif
<span class="lineNum">    2063 </span>            : 
<span class="lineNum">    2064 </span>            : typedef enum {
<span class="lineNum">    2065 </span>            :         STACK_INV,
<span class="lineNum">    2066 </span>            :         STACK_I4,
<span class="lineNum">    2067 </span>            :         STACK_I8,
<span class="lineNum">    2068 </span>            :         STACK_PTR,
<span class="lineNum">    2069 </span>            :         STACK_R8,
<span class="lineNum">    2070 </span>            :         STACK_MP,
<span class="lineNum">    2071 </span>            :         STACK_OBJ,
<span class="lineNum">    2072 </span>            :         STACK_VTYPE,
<span class="lineNum">    2073 </span>            :         STACK_R4,
<span class="lineNum">    2074 </span>            :         STACK_MAX
<span class="lineNum">    2075 </span>            : } MonoStackType;
<span class="lineNum">    2076 </span>            : 
<span class="lineNum">    2077 </span>            : typedef struct {
<span class="lineNum">    2078 </span>            :         union {
<span class="lineNum">    2079 </span>            :                 double   r8;
<span class="lineNum">    2080 </span>            :                 gint32   i4;
<span class="lineNum">    2081 </span>            :                 gint64   i8;
<span class="lineNum">    2082 </span>            :                 gpointer p;
<span class="lineNum">    2083 </span>            :                 MonoClass *klass;
<span class="lineNum">    2084 </span>            :         } data;
<span class="lineNum">    2085 </span>            :         int type;
<span class="lineNum">    2086 </span>            : } StackSlot;
<span class="lineNum">    2087 </span>            : 
<span class="lineNum">    2088 </span>            : #if HAVE_ARRAY_ELEM_INIT
<span class="lineNum">    2089 </span>            : extern const guint8 mono_burg_arity [];
<span class="lineNum">    2090 </span>            : #else
<span class="lineNum">    2091 </span>            : extern guint8 mono_burg_arity [];
<span class="lineNum">    2092 </span>            : #endif
<span class="lineNum">    2093 </span>            : 
<span class="lineNum">    2094 </span>            : extern const char MONO_ARCH_CPU_SPEC [];
<span class="lineNum">    2095 </span>            : #define MONO_ARCH_CPU_SPEC_IDX_COMBINE(a) a ## _idx
<span class="lineNum">    2096 </span>            : #define MONO_ARCH_CPU_SPEC_IDX(a) MONO_ARCH_CPU_SPEC_IDX_COMBINE(a)
<span class="lineNum">    2097 </span>            : extern const guint16 MONO_ARCH_CPU_SPEC_IDX(MONO_ARCH_CPU_SPEC) [];
<span class="lineNum">    2098 </span>            : #define ins_get_spec(op) ((const char*)&amp;MONO_ARCH_CPU_SPEC + MONO_ARCH_CPU_SPEC_IDX(MONO_ARCH_CPU_SPEC)[(op) - OP_LOAD])
<span class="lineNum">    2099 </span>            : 
<span class="lineNum">    2100 </span>            : enum {
<span class="lineNum">    2101 </span>            :         MONO_COMP_DOM = 1,
<span class="lineNum">    2102 </span>            :         MONO_COMP_IDOM = 2,
<span class="lineNum">    2103 </span>            :         MONO_COMP_DFRONTIER = 4,
<span class="lineNum">    2104 </span>            :         MONO_COMP_DOM_REV = 8,
<span class="lineNum">    2105 </span>            :         MONO_COMP_LIVENESS = 16,
<span class="lineNum">    2106 </span>            :         MONO_COMP_SSA = 32,
<span class="lineNum">    2107 </span>            :         MONO_COMP_SSA_DEF_USE = 64,
<span class="lineNum">    2108 </span>            :         MONO_COMP_REACHABILITY = 128,
<span class="lineNum">    2109 </span>            :         MONO_COMP_LOOPS = 256
<span class="lineNum">    2110 </span>            : };
<span class="lineNum">    2111 </span>            : 
<span class="lineNum">    2112 </span>            : typedef enum {
<span class="lineNum">    2113 </span>            :         MONO_GRAPH_CFG = 1,
<span class="lineNum">    2114 </span>            :         MONO_GRAPH_DTREE = 2,
<span class="lineNum">    2115 </span>            :         MONO_GRAPH_CFG_CODE = 4,
<span class="lineNum">    2116 </span>            :         MONO_GRAPH_CFG_SSA = 8,
<span class="lineNum">    2117 </span>            :         MONO_GRAPH_CFG_OPTCODE = 16
<span class="lineNum">    2118 </span>            : } MonoGraphOptions;
<span class="lineNum">    2119 </span>            : 
<span class="lineNum">    2120 </span>            : typedef struct {
<span class="lineNum">    2121 </span>            :         guint16 size;
<span class="lineNum">    2122 </span>            :         guint16 offset;
<span class="lineNum">    2123 </span>            :         guint8  pad;
<span class="lineNum">    2124 </span>            : } MonoJitArgumentInfo;
<span class="lineNum">    2125 </span>            : 
<span class="lineNum">    2126 </span>            : typedef struct {
<span class="lineNum">    2127 </span>            :         gboolean handle_sigint;
<span class="lineNum">    2128 </span>            :         gboolean keep_delegates;
<span class="lineNum">    2129 </span>            :         gboolean reverse_pinvoke_exceptions;
<span class="lineNum">    2130 </span>            :         gboolean collect_pagefault_stats;
<span class="lineNum">    2131 </span>            :         gboolean break_on_unverified;
<span class="lineNum">    2132 </span>            :         gboolean better_cast_details;
<span class="lineNum">    2133 </span>            :         gboolean mdb_optimizations;
<span class="lineNum">    2134 </span>            :         gboolean no_gdb_backtrace;
<span class="lineNum">    2135 </span>            :         gboolean suspend_on_sigsegv;
<span class="lineNum">    2136 </span>            :         gboolean suspend_on_exception;
<span class="lineNum">    2137 </span>            :         gboolean suspend_on_unhandled;
<span class="lineNum">    2138 </span>            :         gboolean dyn_runtime_invoke;
<span class="lineNum">    2139 </span>            :         gboolean gdb;
<span class="lineNum">    2140 </span>            :         gboolean lldb;
<span class="lineNum">    2141 </span>            :         gboolean use_fallback_tls;
<span class="lineNum">    2142 </span>            :         /*
<span class="lineNum">    2143 </span>            :          * Whenever data such as next sequence points and flags is required.
<span class="lineNum">    2144 </span>            :          * Next sequence points and flags are required by the debugger agent.
<span class="lineNum">    2145 </span>            :          */
<span class="lineNum">    2146 </span>            :         gboolean gen_sdb_seq_points;
<span class="lineNum">    2147 </span>            :         gboolean no_seq_points_compact_data;
<span class="lineNum">    2148 </span>            :         /*
<span class="lineNum">    2149 </span>            :          * Setting single_imm_size should guarantee that each time managed code is compiled
<span class="lineNum">    2150 </span>            :          * the same instructions and registers are used, regardless of the size of used values.
<span class="lineNum">    2151 </span>            :          */
<span class="lineNum">    2152 </span>            :         gboolean single_imm_size;
<span class="lineNum">    2153 </span>            :         gboolean explicit_null_checks;
<span class="lineNum">    2154 </span>            :         /*
<span class="lineNum">    2155 </span>            :          * Fill stack frames with 0x2a in method prologs. This helps with the
<span class="lineNum">    2156 </span>            :          * debugging of the stack marking code in the GC.
<span class="lineNum">    2157 </span>            :          */
<span class="lineNum">    2158 </span>            :         gboolean init_stacks;
<span class="lineNum">    2159 </span>            : 
<span class="lineNum">    2160 </span>            :         /*
<span class="lineNum">    2161 </span>            :          * Whenever to implement single stepping and breakpoints without signals in the
<span class="lineNum">    2162 </span>            :          * soft debugger. This is useful on platforms without signals, like the ps3, or during
<span class="lineNum">    2163 </span>            :          * runtime debugging, since it avoids SIGSEGVs when a single step location or breakpoint
<span class="lineNum">    2164 </span>            :          * is hit.
<span class="lineNum">    2165 </span>            :          */
<span class="lineNum">    2166 </span>            :         gboolean soft_breakpoints;
<span class="lineNum">    2167 </span>            :         /*
<span class="lineNum">    2168 </span>            :          * Whenever to break in the debugger using G_BREAKPOINT on unhandled exceptions.
<span class="lineNum">    2169 </span>            :          */
<span class="lineNum">    2170 </span>            :         gboolean break_on_exc;
<span class="lineNum">    2171 </span>            :         /*
<span class="lineNum">    2172 </span>            :          * Load AOT JIT info eagerly.
<span class="lineNum">    2173 </span>            :          */
<span class="lineNum">    2174 </span>            :         gboolean load_aot_jit_info_eagerly;
<span class="lineNum">    2175 </span>            :         /*
<span class="lineNum">    2176 </span>            :          * Check for pinvoke calling convention mismatches.
<span class="lineNum">    2177 </span>            :          */
<span class="lineNum">    2178 </span>            :         gboolean check_pinvoke_callconv;
<span class="lineNum">    2179 </span>            :         /*
<span class="lineNum">    2180 </span>            :          * Translate Debugger.Break () into a native breakpoint signal
<span class="lineNum">    2181 </span>            :          */
<span class="lineNum">    2182 </span>            :         gboolean native_debugger_break;
<span class="lineNum">    2183 </span>            :         /*
<span class="lineNum">    2184 </span>            :          * Disabling the frame pointer emit optimization can allow debuggers to more easily
<span class="lineNum">    2185 </span>            :          * identify the stack on some platforms
<span class="lineNum">    2186 </span>            :          */
<span class="lineNum">    2187 </span>            :         gboolean disable_omit_fp;
<span class="lineNum">    2188 </span>            : } MonoDebugOptions;
<span class="lineNum">    2189 </span>            : 
<span class="lineNum">    2190 </span>            : enum {
<span class="lineNum">    2191 </span>            :         BRANCH_NOT_TAKEN,
<span class="lineNum">    2192 </span>            :         BRANCH_TAKEN,
<span class="lineNum">    2193 </span>            :         BRANCH_UNDEF
<span class="lineNum">    2194 </span>            : };
<span class="lineNum">    2195 </span>            : 
<span class="lineNum">    2196 </span>            : typedef enum {
<span class="lineNum">    2197 </span>            :         CMP_EQ,
<span class="lineNum">    2198 </span>            :         CMP_NE,
<span class="lineNum">    2199 </span>            :         CMP_LE,
<span class="lineNum">    2200 </span>            :         CMP_GE,
<span class="lineNum">    2201 </span>            :         CMP_LT,
<span class="lineNum">    2202 </span>            :         CMP_GT,
<span class="lineNum">    2203 </span>            :         CMP_LE_UN,
<span class="lineNum">    2204 </span>            :         CMP_GE_UN,
<span class="lineNum">    2205 </span>            :         CMP_LT_UN,
<span class="lineNum">    2206 </span>            :         CMP_GT_UN
<span class="lineNum">    2207 </span>            : } CompRelation;
<span class="lineNum">    2208 </span>            : 
<span class="lineNum">    2209 </span>            : typedef enum {
<span class="lineNum">    2210 </span>            :         CMP_TYPE_L,
<span class="lineNum">    2211 </span>            :         CMP_TYPE_I,
<span class="lineNum">    2212 </span>            :         CMP_TYPE_F
<span class="lineNum">    2213 </span>            : } CompType;
<span class="lineNum">    2214 </span>            : 
<span class="lineNum">    2215 </span>            : /* Implicit exceptions */
<span class="lineNum">    2216 </span>            : enum {
<span class="lineNum">    2217 </span>            :         MONO_EXC_INDEX_OUT_OF_RANGE,
<span class="lineNum">    2218 </span>            :         MONO_EXC_OVERFLOW,
<span class="lineNum">    2219 </span>            :         MONO_EXC_ARITHMETIC,
<span class="lineNum">    2220 </span>            :         MONO_EXC_DIVIDE_BY_ZERO,
<span class="lineNum">    2221 </span>            :         MONO_EXC_INVALID_CAST,
<span class="lineNum">    2222 </span>            :         MONO_EXC_NULL_REF,
<span class="lineNum">    2223 </span>            :         MONO_EXC_ARRAY_TYPE_MISMATCH,
<span class="lineNum">    2224 </span>            :         MONO_EXC_ARGUMENT,
<span class="lineNum">    2225 </span>            :         MONO_EXC_INTRINS_NUM
<span class="lineNum">    2226 </span>            : };
<span class="lineNum">    2227 </span>            : 
<span class="lineNum">    2228 </span>            : enum {
<span class="lineNum">    2229 </span>            :         MINI_TOKEN_SOURCE_CLASS,
<span class="lineNum">    2230 </span>            :         MINI_TOKEN_SOURCE_METHOD,
<span class="lineNum">    2231 </span>            :         MINI_TOKEN_SOURCE_FIELD
<span class="lineNum">    2232 </span>            : };
<span class="lineNum">    2233 </span>            : 
<span class="lineNum">    2234 </span>            :  /* 
<span class="lineNum">    2235 </span>            :   * Information about a trampoline function.
<span class="lineNum">    2236 </span>            :   */
<span class="lineNum">    2237 </span>            :  typedef struct
<span class="lineNum">    2238 </span>            :  {
<span class="lineNum">    2239 </span>            :         /* 
<span class="lineNum">    2240 </span>            :          * The native code of the trampoline. Not owned by this structure.
<span class="lineNum">    2241 </span>            :          */
<span class="lineNum">    2242 </span>            :         guint8 *code;
<span class="lineNum">    2243 </span>            :         guint32 code_size;
<span class="lineNum">    2244 </span>            :         /*
<span class="lineNum">    2245 </span>            :          * The name of the trampoline which can be used in AOT/xdebug. Owned by this
<span class="lineNum">    2246 </span>            :          * structure.
<span class="lineNum">    2247 </span>            :          */
<span class="lineNum">    2248 </span>            :         char *name;
<span class="lineNum">    2249 </span>            :         /* 
<span class="lineNum">    2250 </span>            :          * Patches required by the trampoline when aot-ing. Owned by this structure.
<span class="lineNum">    2251 </span>            :          */
<span class="lineNum">    2252 </span>            :         MonoJumpInfo *ji;
<span class="lineNum">    2253 </span>            :         /*
<span class="lineNum">    2254 </span>            :          * Unwind information. Owned by this structure.
<span class="lineNum">    2255 </span>            :          */
<span class="lineNum">    2256 </span>            :         GSList *unwind_ops;
<span class="lineNum">    2257 </span>            : 
<span class="lineNum">    2258 </span>            :          /*
<span class="lineNum">    2259 </span>            :           * Encoded unwind info loaded from AOT images
<span class="lineNum">    2260 </span>            :           */
<span class="lineNum">    2261 </span>            :          guint8 *uw_info;
<span class="lineNum">    2262 </span>            :          guint32 uw_info_len;
<span class="lineNum">    2263 </span>            : } MonoTrampInfo;
<span class="lineNum">    2264 </span>            : 
<span class="lineNum">    2265 </span>            : typedef void (*MonoInstFunc) (MonoInst *tree, gpointer data);
<span class="lineNum">    2266 </span>            : 
<span class="lineNum">    2267 </span>            : enum {
<span class="lineNum">    2268 </span>            :         FILTER_IL_SEQ_POINT = 1 &lt;&lt; 0,
<span class="lineNum">    2269 </span>            :         FILTER_NOP          = 1 &lt;&lt; 1,
<span class="lineNum">    2270 </span>            : };
<a name="2271"><span class="lineNum">    2271 </span>            : </a>
<span class="lineNum">    2272 </span>            : static inline gboolean
<span class="lineNum">    2273 </span>            : mono_inst_filter (MonoInst *ins, int filter)
<span class="lineNum">    2274 </span>            : {
<span class="lineNum">    2275 </span><span class="lineCov">14954117471 :         if (!ins || !filter)</span>
<span class="lineNum">    2276 </span><span class="lineCov"> 1088192175 :                 return FALSE;</span>
<span class="lineNum">    2277 </span>            : 
<span class="lineNum">    2278 </span><span class="lineCov">13798513650 :         if ((filter &amp; FILTER_IL_SEQ_POINT) &amp;&amp; ins-&gt;opcode == OP_IL_SEQ_POINT)</span>
<span class="lineNum">    2279 </span><span class="lineCov"> 1652291412 :                 return TRUE;</span>
<span class="lineNum">    2280 </span>            : 
<span class="lineNum">    2281 </span><span class="lineCov"> 7766358830 :         if ((filter &amp; FILTER_NOP) &amp;&amp; ins-&gt;opcode == OP_NOP)</span>
<span class="lineNum">    2282 </span><span class="lineCov">    6711942 :                 return TRUE;</span>
<span class="lineNum">    2283 </span>            : 
<span class="lineNum">    2284 </span><span class="lineCov"> 5336433237 :         return FALSE;</span>
<span class="lineNum">    2285 </span><span class="lineCov"> 8025077184 : }</span>
<a name="2286"><span class="lineNum">    2286 </span>            : </a>
<span class="lineNum">    2287 </span>            : static inline MonoInst*
<span class="lineNum">    2288 </span>            : mono_inst_next (MonoInst *ins, int filter)
<span class="lineNum">    2289 </span>            : {
<span class="lineNum">    2290 </span><span class="lineCov">  550753848 :         do {</span>
<span class="lineNum">    2291 </span><span class="lineCov">  601085845 :                 ins = ins-&gt;next;</span>
<span class="lineNum">    2292 </span><span class="lineCov"> 1206042615 :         } while (mono_inst_filter (ins, filter));</span>
<span class="lineNum">    2293 </span>            : 
<span class="lineNum">    2294 </span><span class="lineCov">  554891973 :         return ins;</span>
<span class="lineNum">    2295 </span>            : }
<a name="2296"><span class="lineNum">    2296 </span>            : </a>
<span class="lineNum">    2297 </span>            : static inline MonoInst*
<span class="lineNum">    2298 </span>            : mono_inst_prev (MonoInst *ins, int filter)
<span class="lineNum">    2299 </span>            : {
<span class="lineNum">    2300 </span><span class="lineCov"> 5698133171 :         do {</span>
<span class="lineNum">    2301 </span><span class="lineCov"> 6938811703 :                 ins = ins-&gt;prev;</span>
<span class="lineNum">    2302 </span><span class="lineCov">13915819872 :         } while (mono_inst_filter (ins, filter));</span>
<span class="lineNum">    2303 </span>            : 
<span class="lineNum">    2304 </span><span class="lineCov"> 5705618332 :         return ins;</span>
<span class="lineNum">    2305 </span>            : }
<a name="2306"><span class="lineNum">    2306 </span>            : </a>
<span class="lineNum">    2307 </span>            : static inline MonoInst*
<span class="lineNum">    2308 </span>            : mono_bb_first_inst (MonoBasicBlock *bb, int filter)
<span class="lineNum">    2309 </span>            : {
<span class="lineNum">    2310 </span><span class="lineCov">  480586381 :         MonoInst *ins = bb-&gt;code;</span>
<span class="lineNum">    2311 </span><span class="lineCov">  480586381 :         if (mono_inst_filter (ins, filter))</span>
<span class="lineNum">    2312 </span><span class="lineCov">  333206197 :                 ins = mono_inst_next (ins, filter);</span>
<span class="lineNum">    2313 </span>            : 
<span class="lineNum">    2314 </span><span class="lineCov">  479401493 :         return ins;</span>
<span class="lineNum">    2315 </span>            : }
<a name="2316"><span class="lineNum">    2316 </span>            : </a>
<span class="lineNum">    2317 </span>            : static inline MonoInst*
<span class="lineNum">    2318 </span>            : mono_bb_last_inst (MonoBasicBlock *bb, int filter)
<span class="lineNum">    2319 </span>            : {
<span class="lineNum">    2320 </span><span class="lineCov">    6377827 :         MonoInst *ins = bb-&gt;last_ins;</span>
<span class="lineNum">    2321 </span><span class="lineCov">    6377827 :         if (mono_inst_filter (ins, filter))</span>
<span class="lineNum">    2322 </span><span class="lineNoCov">          0 :                 ins = mono_inst_prev (ins, filter);</span>
<span class="lineNum">    2323 </span>            : 
<span class="lineNum">    2324 </span><span class="lineCov">    6377899 :         return ins;</span>
<span class="lineNum">    2325 </span>            : }
<span class="lineNum">    2326 </span>            : 
<span class="lineNum">    2327 </span>            : /* main function */
<span class="lineNum">    2328 </span>            : MONO_API int         mono_main                      (int argc, char* argv[]);
<span class="lineNum">    2329 </span>            : MONO_API void        mono_set_defaults              (int verbose_level, guint32 opts);
<span class="lineNum">    2330 </span>            : MONO_API void        mono_parse_env_options         (int *ref_argc, char **ref_argv []);
<span class="lineNum">    2331 </span>            : MONO_API char       *mono_parse_options_from        (const char *options, int *ref_argc, char **ref_argv []);
<span class="lineNum">    2332 </span>            : 
<span class="lineNum">    2333 </span>            : MonoDomain* mini_init                      (const char *filename, const char *runtime_version);
<span class="lineNum">    2334 </span>            : void        mini_cleanup                   (MonoDomain *domain);
<span class="lineNum">    2335 </span>            : MONO_API MonoDebugOptions *mini_get_debug_options   (void);
<span class="lineNum">    2336 </span>            : MONO_API gboolean    mini_parse_debug_option (const char *option);
<span class="lineNum">    2337 </span>            : void        mini_profiler_enable_with_options (const char *profile_options);
<span class="lineNum">    2338 </span>            : 
<span class="lineNum">    2339 </span>            : /* graph dumping */
<span class="lineNum">    2340 </span>            : void mono_cfg_dump_create_context (MonoCompile *cfg);
<span class="lineNum">    2341 </span>            : void mono_cfg_dump_begin_group (MonoCompile *cfg);
<span class="lineNum">    2342 </span>            : void mono_cfg_dump_close_group (MonoCompile *cfg);
<span class="lineNum">    2343 </span>            : void mono_cfg_dump_ir (MonoCompile *cfg, const char *phase_name);
<span class="lineNum">    2344 </span>            : 
<span class="lineNum">    2345 </span>            : /* helper methods */
<span class="lineNum">    2346 </span>            : void      mini_jit_init                    (void);
<span class="lineNum">    2347 </span>            : void      mini_jit_cleanup                 (void);
<span class="lineNum">    2348 </span>            : void      mono_disable_optimizations       (guint32 opts);
<span class="lineNum">    2349 </span>            : void      mono_set_optimizations           (guint32 opts);
<span class="lineNum">    2350 </span>            : void      mono_set_bisect_methods          (guint32 opt, const char *method_list_filename);
<span class="lineNum">    2351 </span>            : guint32   mono_get_optimizations_for_method (MonoMethod *method, guint32 default_opt);
<span class="lineNum">    2352 </span>            : char*     mono_opt_descr                   (guint32 flags);
<span class="lineNum">    2353 </span>            : void      mono_set_verbose_level           (guint32 level);
<span class="lineNum">    2354 </span>            : MonoJumpInfoToken* mono_jump_info_token_new (MonoMemPool *mp, MonoImage *image, guint32 token);
<span class="lineNum">    2355 </span>            : MonoJumpInfoToken* mono_jump_info_token_new2 (MonoMemPool *mp, MonoImage *image, guint32 token, MonoGenericContext *context);
<span class="lineNum">    2356 </span>            : MonoInst* mono_find_spvar_for_region        (MonoCompile *cfg, int region);
<span class="lineNum">    2357 </span>            : MonoInst* mono_find_exvar_for_offset        (MonoCompile *cfg, int offset);
<span class="lineNum">    2358 </span>            : int       mono_get_block_region_notry       (MonoCompile *cfg, int region) MONO_LLVM_INTERNAL;
<span class="lineNum">    2359 </span>            : 
<span class="lineNum">    2360 </span>            : void      mono_precompile_assemblies        (void);
<span class="lineNum">    2361 </span>            : MONO_API int       mono_parse_default_optimizations  (const char* p);
<span class="lineNum">    2362 </span>            : void      mono_bblock_add_inst              (MonoBasicBlock *bb, MonoInst *inst) MONO_LLVM_INTERNAL;
<span class="lineNum">    2363 </span>            : void      mono_bblock_insert_after_ins      (MonoBasicBlock *bb, MonoInst *ins, MonoInst *ins_to_insert);
<span class="lineNum">    2364 </span>            : void      mono_bblock_insert_before_ins     (MonoBasicBlock *bb, MonoInst *ins, MonoInst *ins_to_insert);
<span class="lineNum">    2365 </span>            : void      mono_verify_bblock                (MonoBasicBlock *bb);
<span class="lineNum">    2366 </span>            : void      mono_verify_cfg                   (MonoCompile *cfg);
<span class="lineNum">    2367 </span>            : void      mono_constant_fold                (MonoCompile *cfg);
<span class="lineNum">    2368 </span>            : MonoInst* mono_constant_fold_ins            (MonoCompile *cfg, MonoInst *ins, MonoInst *arg1, MonoInst *arg2, gboolean overwrite);
<span class="lineNum">    2369 </span>            : int       mono_eval_cond_branch             (MonoInst *branch);
<span class="lineNum">    2370 </span>            : int       mono_is_power_of_two              (guint32 val) MONO_LLVM_INTERNAL;
<span class="lineNum">    2371 </span>            : void      mono_cprop_local                  (MonoCompile *cfg, MonoBasicBlock *bb, MonoInst **acp, int acp_size);
<span class="lineNum">    2372 </span>            : MonoInst* mono_compile_create_var           (MonoCompile *cfg, MonoType *type, int opcode);
<span class="lineNum">    2373 </span>            : MonoInst* mono_compile_create_var_for_vreg  (MonoCompile *cfg, MonoType *type, int opcode, int vreg);
<span class="lineNum">    2374 </span>            : void      mono_compile_make_var_load        (MonoCompile *cfg, MonoInst *dest, gssize var_index);
<span class="lineNum">    2375 </span>            : MonoInst* mini_get_int_to_float_spill_area  (MonoCompile *cfg);
<span class="lineNum">    2376 </span>            : MonoType* mono_type_from_stack_type         (MonoInst *ins);
<span class="lineNum">    2377 </span>            : guint32   mono_alloc_ireg                   (MonoCompile *cfg) MONO_LLVM_INTERNAL;
<span class="lineNum">    2378 </span>            : guint32   mono_alloc_lreg                   (MonoCompile *cfg) MONO_LLVM_INTERNAL;
<span class="lineNum">    2379 </span>            : guint32   mono_alloc_freg                   (MonoCompile *cfg) MONO_LLVM_INTERNAL;
<span class="lineNum">    2380 </span>            : guint32   mono_alloc_preg                   (MonoCompile *cfg) MONO_LLVM_INTERNAL;
<span class="lineNum">    2381 </span>            : guint32   mono_alloc_dreg                   (MonoCompile *cfg, MonoStackType stack_type);
<span class="lineNum">    2382 </span>            : guint32   mono_alloc_ireg_ref               (MonoCompile *cfg) MONO_LLVM_INTERNAL;
<span class="lineNum">    2383 </span>            : guint32   mono_alloc_ireg_mp                (MonoCompile *cfg) MONO_LLVM_INTERNAL;
<span class="lineNum">    2384 </span>            : guint32   mono_alloc_ireg_copy              (MonoCompile *cfg, guint32 vreg) MONO_LLVM_INTERNAL;
<span class="lineNum">    2385 </span>            : void      mono_mark_vreg_as_ref             (MonoCompile *cfg, int vreg);
<span class="lineNum">    2386 </span>            : void      mono_mark_vreg_as_mp              (MonoCompile *cfg, int vreg);
<span class="lineNum">    2387 </span>            : 
<span class="lineNum">    2388 </span>            : void      mono_link_bblock                  (MonoCompile *cfg, MonoBasicBlock *from, MonoBasicBlock* to);
<span class="lineNum">    2389 </span>            : void      mono_unlink_bblock                (MonoCompile *cfg, MonoBasicBlock *from, MonoBasicBlock* to);
<span class="lineNum">    2390 </span>            : gboolean  mono_bblocks_linked               (MonoBasicBlock *bb1, MonoBasicBlock *bb2);
<span class="lineNum">    2391 </span>            : void      mono_remove_bblock                (MonoCompile *cfg, MonoBasicBlock *bb);
<span class="lineNum">    2392 </span>            : void      mono_nullify_basic_block          (MonoBasicBlock *bb);
<span class="lineNum">    2393 </span>            : void      mono_merge_basic_blocks           (MonoCompile *cfg, MonoBasicBlock *bb, MonoBasicBlock *bbn);
<span class="lineNum">    2394 </span>            : void      mono_optimize_branches            (MonoCompile *cfg);
<span class="lineNum">    2395 </span>            : 
<span class="lineNum">    2396 </span>            : void      mono_blockset_print               (MonoCompile *cfg, MonoBitSet *set, const char *name, guint idom);
<span class="lineNum">    2397 </span>            : const char*mono_ji_type_to_string           (MonoJumpInfoType type);
<span class="lineNum">    2398 </span>            : void      mono_print_ji                     (const MonoJumpInfo *ji);
<span class="lineNum">    2399 </span>            : void      mono_print_ins_index              (int i, MonoInst *ins);
<span class="lineNum">    2400 </span>            : GString  *mono_print_ins_index_strbuf       (int i, MonoInst *ins);
<span class="lineNum">    2401 </span>            : void      mono_print_ins                    (MonoInst *ins);
<span class="lineNum">    2402 </span>            : void      mono_print_bb                     (MonoBasicBlock *bb, const char *msg);
<span class="lineNum">    2403 </span>            : void      mono_print_code                   (MonoCompile *cfg, const char *msg);
<span class="lineNum">    2404 </span>            : MONO_API void      mono_print_method_from_ip         (void *ip);
<span class="lineNum">    2405 </span>            : MONO_API char     *mono_pmip                         (void *ip);
<span class="lineNum">    2406 </span>            : gboolean  mono_debug_count                  (void);
<span class="lineNum">    2407 </span>            : MONO_API const char* mono_inst_name                  (int op);
<span class="lineNum">    2408 </span>            : int       mono_op_to_op_imm                 (int opcode);
<span class="lineNum">    2409 </span>            : int       mono_op_imm_to_op                 (int opcode);
<span class="lineNum">    2410 </span>            : int       mono_load_membase_to_load_mem     (int opcode);
<span class="lineNum">    2411 </span>            : guint     mono_type_to_load_membase         (MonoCompile *cfg, MonoType *type);
<span class="lineNum">    2412 </span>            : guint     mono_type_to_store_membase        (MonoCompile *cfg, MonoType *type);
<span class="lineNum">    2413 </span>            : guint     mini_type_to_stind                (MonoCompile* cfg, MonoType *type);
<span class="lineNum">    2414 </span>            : MonoJitInfo* mini_lookup_method             (MonoDomain *domain, MonoMethod *method, MonoMethod *shared);
<span class="lineNum">    2415 </span>            : guint32   mono_reverse_branch_op            (guint32 opcode);
<span class="lineNum">    2416 </span>            : void      mono_disassemble_code             (MonoCompile *cfg, guint8 *code, int size, char *id);
<span class="lineNum">    2417 </span>            : void      mono_add_patch_info               (MonoCompile *cfg, int ip, MonoJumpInfoType type, gconstpointer target) MONO_LLVM_INTERNAL;
<span class="lineNum">    2418 </span>            : void      mono_add_patch_info_rel           (MonoCompile *cfg, int ip, MonoJumpInfoType type, gconstpointer target, int relocation) MONO_LLVM_INTERNAL;
<span class="lineNum">    2419 </span>            : void      mono_remove_patch_info            (MonoCompile *cfg, int ip);
<span class="lineNum">    2420 </span>            : MonoJumpInfo* mono_patch_info_dup_mp        (MonoMemPool *mp, MonoJumpInfo *patch_info);
<span class="lineNum">    2421 </span>            : guint     mono_patch_info_hash (gconstpointer data);
<span class="lineNum">    2422 </span>            : gint      mono_patch_info_equal (gconstpointer ka, gconstpointer kb);
<span class="lineNum">    2423 </span>            : MonoJumpInfo *mono_patch_info_list_prepend  (MonoJumpInfo *list, int ip, MonoJumpInfoType type, gconstpointer target);
<span class="lineNum">    2424 </span>            : gpointer  mono_resolve_patch_target         (MonoMethod *method, MonoDomain *domain, guint8 *code, MonoJumpInfo *patch_info, gboolean run_cctors, MonoError *error) MONO_LLVM_INTERNAL;
<span class="lineNum">    2425 </span>            : gpointer  mono_jit_find_compiled_method_with_jit_info (MonoDomain *domain, MonoMethod *method, MonoJitInfo **ji);
<span class="lineNum">    2426 </span>            : gpointer  mono_jit_find_compiled_method     (MonoDomain *domain, MonoMethod *method);
<span class="lineNum">    2427 </span>            : gpointer  mono_jit_compile_method           (MonoMethod *method, MonoError *error);
<span class="lineNum">    2428 </span>            : gpointer  mono_jit_compile_method_inner     (MonoMethod *method, MonoDomain *target_domain, int opt, MonoError *error);
<span class="lineNum">    2429 </span>            : MonoLMF * mono_get_lmf                      (void);
<span class="lineNum">    2430 </span>            : MonoLMF** mono_get_lmf_addr                 (void);
<span class="lineNum">    2431 </span>            : void      mono_set_lmf                      (MonoLMF *lmf);
<span class="lineNum">    2432 </span>            : MonoJitTlsData* mono_get_jit_tls            (void);
<span class="lineNum">    2433 </span>            : MONO_API MonoDomain* mono_jit_thread_attach (MonoDomain *domain);
<span class="lineNum">    2434 </span>            : MONO_API void      mono_jit_set_domain      (MonoDomain *domain);
<span class="lineNum">    2435 </span>            : MonoInst* mono_create_tls_get               (MonoCompile *cfg, MonoTlsKey key);
<span class="lineNum">    2436 </span>            : GList    *mono_varlist_insert_sorted        (MonoCompile *cfg, GList *list, MonoMethodVar *mv, int sort_type);
<span class="lineNum">    2437 </span>            : GList    *mono_varlist_sort                 (MonoCompile *cfg, GList *list, int sort_type);
<span class="lineNum">    2438 </span>            : void      mono_analyze_liveness             (MonoCompile *cfg);
<span class="lineNum">    2439 </span>            : void      mono_analyze_liveness_gc          (MonoCompile *cfg);
<span class="lineNum">    2440 </span>            : void      mono_linear_scan                  (MonoCompile *cfg, GList *vars, GList *regs, regmask_t *used_mask);
<span class="lineNum">    2441 </span>            : void      mono_global_regalloc              (MonoCompile *cfg);
<span class="lineNum">    2442 </span>            : void      mono_create_jump_table            (MonoCompile *cfg, MonoInst *label, MonoBasicBlock **bbs, int num_blocks);
<span class="lineNum">    2443 </span>            : MonoCompile *mini_method_compile            (MonoMethod *method, guint32 opts, MonoDomain *domain, JitFlags flags, int parts, int aot_method_index);
<span class="lineNum">    2444 </span>            : void      mono_destroy_compile              (MonoCompile *cfg);
<span class="lineNum">    2445 </span>            : void      mono_empty_compile              (MonoCompile *cfg);
<span class="lineNum">    2446 </span>            : MonoJitICallInfo *mono_find_jit_opcode_emulation (int opcode);
<span class="lineNum">    2447 </span>            : void      mono_print_ins_index (int i, MonoInst *ins);
<span class="lineNum">    2448 </span>            : void      mono_print_ins (MonoInst *ins);
<span class="lineNum">    2449 </span>            : gboolean  mini_assembly_can_skip_verification (MonoDomain *domain, MonoMethod *method);
<span class="lineNum">    2450 </span>            : gboolean mono_compile_is_broken (MonoCompile *cfg, MonoMethod *method, gboolean fail_compile);
<span class="lineNum">    2451 </span>            : MonoInst *mono_get_got_var (MonoCompile *cfg);
<span class="lineNum">    2452 </span>            : void      mono_add_seq_point (MonoCompile *cfg, MonoBasicBlock *bb, MonoInst *ins, int native_offset);
<span class="lineNum">    2453 </span>            : void      mono_add_var_location (MonoCompile *cfg, MonoInst *var, gboolean is_reg, int reg, int offset, int from, int to);
<span class="lineNum">    2454 </span>            : MonoInst* mono_emit_jit_icall (MonoCompile *cfg, gconstpointer func, MonoInst **args);
<span class="lineNum">    2455 </span>            : MonoInst* mono_emit_jit_icall_by_info (MonoCompile *cfg, int il_offset, MonoJitICallInfo *info, MonoInst **args);
<span class="lineNum">    2456 </span>            : MonoInst* mono_emit_method_call (MonoCompile *cfg, MonoMethod *method, MonoInst **args, MonoInst *this_ins);
<span class="lineNum">    2457 </span>            : void      mono_create_helper_signatures (void);
<span class="lineNum">    2458 </span>            : 
<span class="lineNum">    2459 </span>            : gboolean  mini_class_is_system_array (MonoClass *klass);
<span class="lineNum">    2460 </span>            : MonoMethodSignature *mono_get_element_address_signature (int arity);
<span class="lineNum">    2461 </span>            : MonoJitICallInfo    *mono_get_element_address_icall (int rank);
<span class="lineNum">    2462 </span>            : MonoJitICallInfo    *mono_get_array_new_va_icall (int rank);
<span class="lineNum">    2463 </span>            : 
<span class="lineNum">    2464 </span>            : void      mono_linterval_add_range          (MonoCompile *cfg, MonoLiveInterval *interval, int from, int to);
<span class="lineNum">    2465 </span>            : void      mono_linterval_print              (MonoLiveInterval *interval);
<span class="lineNum">    2466 </span>            : void      mono_linterval_print_nl (MonoLiveInterval *interval);
<span class="lineNum">    2467 </span>            : gboolean  mono_linterval_covers             (MonoLiveInterval *interval, int pos);
<span class="lineNum">    2468 </span>            : gint32    mono_linterval_get_intersect_pos  (MonoLiveInterval *i1, MonoLiveInterval *i2);
<span class="lineNum">    2469 </span>            : void      mono_linterval_split              (MonoCompile *cfg, MonoLiveInterval *interval, MonoLiveInterval **i1, MonoLiveInterval **i2, int pos);
<span class="lineNum">    2470 </span>            : void      mono_liveness_handle_exception_clauses (MonoCompile *cfg);
<span class="lineNum">    2471 </span>            : 
<span class="lineNum">    2472 </span>            : /* Native Client functions */
<span class="lineNum">    2473 </span>            : gpointer mono_realloc_native_code(MonoCompile *cfg);
<span class="lineNum">    2474 </span>            : 
<span class="lineNum">    2475 </span>            : #if defined(__native_client__) || defined(__native_client_codegen__)
<span class="lineNum">    2476 </span>            : extern volatile int __nacl_thread_suspension_needed;
<span class="lineNum">    2477 </span>            : void __nacl_suspend_thread_if_needed(void);
<span class="lineNum">    2478 </span>            : void mono_nacl_gc(void);
<span class="lineNum">    2479 </span>            : #endif
<span class="lineNum">    2480 </span>            : 
<span class="lineNum">    2481 </span>            : extern MonoDebugOptions debug_options;
<a name="2482"><span class="lineNum">    2482 </span>            : </a>
<span class="lineNum">    2483 </span>            : static inline MonoMethod*
<span class="lineNum">    2484 </span>            : jinfo_get_method (MonoJitInfo *ji)
<span class="lineNum">    2485 </span>            : {
<span class="lineNum">    2486 </span><span class="lineCov">   67314927 :         return mono_jit_info_get_method (ji);</span>
<span class="lineNum">    2487 </span>            : }
<span class="lineNum">    2488 </span>            : 
<span class="lineNum">    2489 </span>            : /* AOT */
<span class="lineNum">    2490 </span>            : void      mono_aot_init                     (void);
<span class="lineNum">    2491 </span>            : void      mono_aot_cleanup                  (void);
<span class="lineNum">    2492 </span>            : gpointer  mono_aot_get_method_checked       (MonoDomain *domain,
<span class="lineNum">    2493 </span>            :                                                                                          MonoMethod *method, MonoError *error);
<span class="lineNum">    2494 </span>            : gpointer  mono_aot_get_method_from_token    (MonoDomain *domain, MonoImage *image, guint32 token, MonoError *error);
<span class="lineNum">    2495 </span>            : gboolean  mono_aot_is_got_entry             (guint8 *code, guint8 *addr);
<span class="lineNum">    2496 </span>            : guint8*   mono_aot_get_plt_entry            (guint8 *code);
<span class="lineNum">    2497 </span>            : guint32   mono_aot_get_plt_info_offset      (mgreg_t *regs, guint8 *code);
<span class="lineNum">    2498 </span>            : gboolean  mono_aot_get_cached_class_info    (MonoClass *klass, MonoCachedClassInfo *res);
<span class="lineNum">    2499 </span>            : gboolean  mono_aot_get_class_from_name      (MonoImage *image, const char *name_space, const char *name, MonoClass **klass);
<span class="lineNum">    2500 </span>            : MonoJitInfo* mono_aot_find_jit_info         (MonoDomain *domain, MonoImage *image, gpointer addr);
<span class="lineNum">    2501 </span>            : gpointer mono_aot_plt_resolve               (gpointer aot_module, guint32 plt_info_offset, guint8 *code, MonoError *error);
<span class="lineNum">    2502 </span>            : void     mono_aot_patch_plt_entry           (guint8 *code, guint8 *plt_entry, gpointer *got, mgreg_t *regs, guint8 *addr);
<span class="lineNum">    2503 </span>            : gpointer mono_aot_get_method_from_vt_slot   (MonoDomain *domain, MonoVTable *vtable, int slot, MonoError *error);
<span class="lineNum">    2504 </span>            : gpointer mono_aot_create_specific_trampoline   (MonoImage *image, gpointer arg1, MonoTrampolineType tramp_type, MonoDomain *domain, guint32 *code_len);
<span class="lineNum">    2505 </span>            : gpointer mono_aot_get_trampoline            (const char *name);
<span class="lineNum">    2506 </span>            : gpointer mono_aot_get_trampoline_full       (const char *name, MonoTrampInfo **out_tinfo);
<span class="lineNum">    2507 </span>            : gpointer mono_aot_get_unbox_trampoline      (MonoMethod *method);
<span class="lineNum">    2508 </span>            : gpointer mono_aot_get_lazy_fetch_trampoline (guint32 slot);
<span class="lineNum">    2509 </span>            : gpointer mono_aot_get_static_rgctx_trampoline (gpointer ctx, gpointer addr);
<span class="lineNum">    2510 </span>            : gpointer mono_aot_get_imt_trampoline        (MonoVTable *vtable, MonoDomain *domain, MonoIMTCheckItem **imt_entries, int count, gpointer fail_tramp);
<span class="lineNum">    2511 </span>            : gpointer mono_aot_get_gsharedvt_arg_trampoline(gpointer arg, gpointer addr);
<span class="lineNum">    2512 </span>            : guint8*  mono_aot_get_unwind_info           (MonoJitInfo *ji, guint32 *unwind_info_len);
<span class="lineNum">    2513 </span>            : guint32  mono_aot_method_hash               (MonoMethod *method);
<span class="lineNum">    2514 </span>            : MonoMethod* mono_aot_get_array_helper_from_wrapper (MonoMethod *method);
<span class="lineNum">    2515 </span>            : void     mono_aot_set_make_unreadable       (gboolean unreadable);
<span class="lineNum">    2516 </span>            : gboolean mono_aot_is_pagefault              (void *ptr);
<span class="lineNum">    2517 </span>            : void     mono_aot_handle_pagefault          (void *ptr);
<span class="lineNum">    2518 </span>            : void     mono_aot_register_jit_icall        (const char *name, gpointer addr);
<span class="lineNum">    2519 </span>            : guint32  mono_aot_find_method_index         (MonoMethod *method);
<span class="lineNum">    2520 </span>            : void     mono_aot_init_llvm_method          (gpointer aot_module, guint32 method_index);
<span class="lineNum">    2521 </span>            : void     mono_aot_init_gshared_method_this  (gpointer aot_module, guint32 method_index, MonoObject *this_ins);
<span class="lineNum">    2522 </span>            : void     mono_aot_init_gshared_method_mrgctx  (gpointer aot_module, guint32 method_index, MonoMethodRuntimeGenericContext *rgctx);
<span class="lineNum">    2523 </span>            : void     mono_aot_init_gshared_method_vtable  (gpointer aot_module, guint32 method_index, MonoVTable *vtable);
<span class="lineNum">    2524 </span>            : 
<span class="lineNum">    2525 </span>            : /* This is an exported function */
<span class="lineNum">    2526 </span>            : MONO_API void     mono_aot_register_module           (gpointer *aot_info);
<span class="lineNum">    2527 </span>            : 
<span class="lineNum">    2528 </span>            : /* These are used to load the AOT data for aot images compiled with MONO_AOT_FILE_FLAG_SEPARATE_DATA */
<span class="lineNum">    2529 </span>            : /*
<span class="lineNum">    2530 </span>            :  * Return the AOT data for ASSEMBLY. SIZE is the size of the data. OUT_HANDLE should be set to a handle which is later
<span class="lineNum">    2531 </span>            :  * passed to the free function.
<span class="lineNum">    2532 </span>            :  */
<span class="lineNum">    2533 </span>            : typedef unsigned char* (*MonoLoadAotDataFunc)          (MonoAssembly *assembly, int size, gpointer user_data, void **out_handle);
<span class="lineNum">    2534 </span>            : /* Not yet used */
<span class="lineNum">    2535 </span>            : typedef void  (*MonoFreeAotDataFunc)          (MonoAssembly *assembly, int size, gpointer user_data, void *handle);
<span class="lineNum">    2536 </span>            : MONO_API void mono_install_load_aot_data_hook (MonoLoadAotDataFunc load_func, MonoFreeAotDataFunc free_func, gpointer user_data);
<span class="lineNum">    2537 </span>            : 
<span class="lineNum">    2538 </span>            : void     mono_xdebug_init                   (const char *xdebug_opts);
<span class="lineNum">    2539 </span>            : void     mono_save_xdebug_info              (MonoCompile *cfg);
<span class="lineNum">    2540 </span>            : void     mono_save_trampoline_xdebug_info   (MonoTrampInfo *info);
<span class="lineNum">    2541 </span>            : /* This is an exported function */
<span class="lineNum">    2542 </span>            : void     mono_xdebug_flush                  (void);
<span class="lineNum">    2543 </span>            : 
<span class="lineNum">    2544 </span>            : gboolean  mono_method_blittable             (MonoMethod *method);
<span class="lineNum">    2545 </span>            : gboolean  mono_method_same_domain           (MonoJitInfo *caller, MonoJitInfo *callee);
<span class="lineNum">    2546 </span>            : 
<span class="lineNum">    2547 </span>            : void      mono_register_opcode_emulation    (int opcode, const char* name, const char *sigstr, gpointer func, gboolean no_throw);
<span class="lineNum">    2548 </span>            : void      mono_draw_graph                   (MonoCompile *cfg, MonoGraphOptions draw_options);
<span class="lineNum">    2549 </span>            : void      mono_add_ins_to_end               (MonoBasicBlock *bb, MonoInst *inst);
<span class="lineNum">    2550 </span>            : gpointer  mono_create_ftnptr                (MonoDomain *domain, gpointer addr);
<span class="lineNum">    2551 </span>            : 
<span class="lineNum">    2552 </span>            : MONO_API void      mono_replace_ins                  (MonoCompile *cfg, MonoBasicBlock *bb, MonoInst *ins, MonoInst **prev, MonoBasicBlock *first_bb, MonoBasicBlock *last_bb);
<span class="lineNum">    2553 </span>            : 
<span class="lineNum">    2554 </span>            : int               mono_find_method_opcode      (MonoMethod *method);
<span class="lineNum">    2555 </span>            : MonoJitICallInfo *mono_register_jit_icall      (gconstpointer func, const char *name, MonoMethodSignature *sig, gboolean is_save);
<span class="lineNum">    2556 </span>            : gconstpointer     mono_icall_get_wrapper       (MonoJitICallInfo* callinfo) MONO_LLVM_INTERNAL;
<span class="lineNum">    2557 </span>            : gconstpointer     mono_icall_get_wrapper_full  (MonoJitICallInfo* callinfo, gboolean do_compile);
<span class="lineNum">    2558 </span>            : void              mini_register_opcode_emulation (int opcode, const char *name, const char *sigstr, gpointer func, const char *symbol, gboolean no_throw);
<span class="lineNum">    2559 </span>            : 
<span class="lineNum">    2560 </span>            : void              mono_trampolines_init (void);
<span class="lineNum">    2561 </span>            : void              mono_trampolines_cleanup (void);
<span class="lineNum">    2562 </span>            : guint8 *          mono_get_trampoline_code (MonoTrampolineType tramp_type);
<span class="lineNum">    2563 </span>            : gpointer          mono_create_specific_trampoline (gpointer arg1, MonoTrampolineType tramp_type, MonoDomain *domain, guint32 *code_len);
<span class="lineNum">    2564 </span>            : gpointer          mono_create_jump_trampoline (MonoDomain *domain, 
<span class="lineNum">    2565 </span>            :                                                                                            MonoMethod *method, 
<span class="lineNum">    2566 </span>            :                                                                                            gboolean add_sync_wrapper,
<span class="lineNum">    2567 </span>            :                                                                                            MonoError *error);
<span class="lineNum">    2568 </span>            : gpointer          mono_create_class_init_trampoline (MonoVTable *vtable);
<span class="lineNum">    2569 </span>            : gpointer          mono_create_jit_trampoline (MonoDomain *domain, MonoMethod *method, MonoError *error) MONO_LLVM_INTERNAL;
<span class="lineNum">    2570 </span>            : gpointer          mono_create_jit_trampoline_from_token (MonoImage *image, guint32 token);
<span class="lineNum">    2571 </span>            : gpointer          mono_create_delegate_trampoline (MonoDomain *domain, MonoClass *klass);
<span class="lineNum">    2572 </span>            : MonoDelegateTrampInfo* mono_create_delegate_trampoline_info (MonoDomain *domain, MonoClass *klass, MonoMethod *method);
<span class="lineNum">    2573 </span>            : gpointer          mono_create_delegate_virtual_trampoline (MonoDomain *domain, MonoClass *klass, MonoMethod *method);
<span class="lineNum">    2574 </span>            : gpointer          mono_create_rgctx_lazy_fetch_trampoline (guint32 offset);
<span class="lineNum">    2575 </span>            : gpointer          mono_create_monitor_enter_trampoline (void);
<span class="lineNum">    2576 </span>            : gpointer          mono_create_monitor_enter_v4_trampoline (void);
<span class="lineNum">    2577 </span>            : gpointer          mono_create_monitor_exit_trampoline (void);
<span class="lineNum">    2578 </span>            : gpointer          mono_create_static_rgctx_trampoline (MonoMethod *m, gpointer addr);
<span class="lineNum">    2579 </span>            : MonoVTable*       mono_find_class_init_trampoline_by_addr (gconstpointer addr);
<span class="lineNum">    2580 </span>            : guint32           mono_find_rgctx_lazy_fetch_trampoline_by_addr (gconstpointer addr);
<span class="lineNum">    2581 </span>            : gpointer          mono_magic_trampoline (mgreg_t *regs, guint8 *code, gpointer arg, guint8* tramp);
<span class="lineNum">    2582 </span>            : #ifndef DISABLE_REMOTING
<span class="lineNum">    2583 </span>            : gpointer          mono_generic_virtual_remoting_trampoline (mgreg_t *regs, guint8 *code, MonoMethod *m, guint8 *tramp);
<span class="lineNum">    2584 </span>            : #endif
<span class="lineNum">    2585 </span>            : gpointer          mono_delegate_trampoline (mgreg_t *regs, guint8 *code, gpointer *tramp_data, guint8* tramp);
<span class="lineNum">    2586 </span>            : gpointer          mono_aot_trampoline (mgreg_t *regs, guint8 *code, guint8 *token_info, 
<span class="lineNum">    2587 </span>            :                                                                            guint8* tramp);
<span class="lineNum">    2588 </span>            : gpointer          mono_aot_plt_trampoline (mgreg_t *regs, guint8 *code, guint8 *token_info, 
<span class="lineNum">    2589 </span>            :                                                                                    guint8* tramp);
<span class="lineNum">    2590 </span>            : void              mono_class_init_trampoline (mgreg_t *regs, guint8 *code, MonoVTable *vtable, guint8 *tramp);
<span class="lineNum">    2591 </span>            : void              mono_generic_class_init_trampoline (mgreg_t *regs, guint8 *code, MonoVTable *vtable, guint8 *tramp);
<span class="lineNum">    2592 </span>            : void              mono_monitor_enter_trampoline (mgreg_t *regs, guint8 *code, MonoObject *obj, guint8 *tramp);
<span class="lineNum">    2593 </span>            : void              mono_monitor_enter_v4_trampoline (mgreg_t *regs, guint8 *code, MonoObject *obj, guint8 *tramp);
<span class="lineNum">    2594 </span>            : void              mono_monitor_exit_trampoline (mgreg_t *regs, guint8 *code, MonoObject *obj, guint8 *tramp);
<span class="lineNum">    2595 </span>            : gconstpointer     mono_get_trampoline_func (MonoTrampolineType tramp_type);
<span class="lineNum">    2596 </span>            : gpointer          mini_get_vtable_trampoline (MonoVTable *vt, int slot_index);
<span class="lineNum">    2597 </span>            : const char*       mono_get_generic_trampoline_simple_name (MonoTrampolineType tramp_type);
<span class="lineNum">    2598 </span>            : char*             mono_get_generic_trampoline_name (MonoTrampolineType tramp_type);
<span class="lineNum">    2599 </span>            : char*             mono_get_rgctx_fetch_trampoline_name (int slot);
<span class="lineNum">    2600 </span>            : gpointer          mini_get_nullified_class_init_trampoline (void);
<span class="lineNum">    2601 </span>            : gpointer          mini_get_single_step_trampoline (void);
<span class="lineNum">    2602 </span>            : gpointer          mini_get_breakpoint_trampoline (void);
<span class="lineNum">    2603 </span>            : gpointer          mini_add_method_trampoline (MonoMethod *m, gpointer compiled_method, gboolean add_static_rgctx_tramp, gboolean add_unbox_tramp);
<span class="lineNum">    2604 </span>            : gpointer          mini_add_method_wrappers_llvmonly (MonoMethod *m, gpointer compiled_method, gboolean caller_gsharedvt, gboolean add_unbox_tramp, gpointer *out_arg);
<span class="lineNum">    2605 </span>            : gboolean          mini_jit_info_is_gsharedvt (MonoJitInfo *ji);
<span class="lineNum">    2606 </span>            : gpointer*         mini_resolve_imt_method (MonoVTable *vt, gpointer *vtable_slot, MonoMethod *imt_method, MonoMethod **impl_method, gpointer *out_aot_addr,
<span class="lineNum">    2607 </span>            :                                            gboolean *out_need_rgctx_tramp, MonoMethod **variant_iface,
<span class="lineNum">    2608 </span>            :                                            MonoError *error);
<span class="lineNum">    2609 </span>            : MonoFtnDesc      *mini_create_llvmonly_ftndesc (MonoDomain *domain, gpointer addr, gpointer arg);
<span class="lineNum">    2610 </span>            : 
<span class="lineNum">    2611 </span>            : gboolean          mono_running_on_valgrind (void);
<span class="lineNum">    2612 </span>            : void*             mono_global_codeman_reserve (int size);
<span class="lineNum">    2613 </span>            : void              mono_global_codeman_foreach (MonoCodeManagerFunc func, void *user_data);
<span class="lineNum">    2614 </span>            : const char       *mono_regname_full (int reg, int bank);
<span class="lineNum">    2615 </span>            : gint32*           mono_allocate_stack_slots (MonoCompile *cfg, gboolean backward, guint32 *stack_size, guint32 *stack_align);
<span class="lineNum">    2616 </span>            : void              mono_local_regalloc (MonoCompile *cfg, MonoBasicBlock *bb);
<span class="lineNum">    2617 </span>            : MonoInst         *mono_branch_optimize_exception_target (MonoCompile *cfg, MonoBasicBlock *bb, const char * exname);
<span class="lineNum">    2618 </span>            : void              mono_remove_critical_edges (MonoCompile *cfg);
<span class="lineNum">    2619 </span>            : gboolean          mono_is_regsize_var (MonoType *t);
<span class="lineNum">    2620 </span>            : void              mini_emit_memcpy (MonoCompile *cfg, int destreg, int doffset, int srcreg, int soffset, int size, int align);
<span class="lineNum">    2621 </span>            : void              mini_emit_stobj (MonoCompile *cfg, MonoInst *dest, MonoInst *src, MonoClass *klass, gboolean native);
<span class="lineNum">    2622 </span>            : void              mini_emit_initobj (MonoCompile *cfg, MonoInst *dest, const guchar *ip, MonoClass *klass);
<span class="lineNum">    2623 </span>            : MonoInst*         mini_emit_ldelema_1_ins (MonoCompile *cfg, MonoClass *klass, MonoInst *arr, MonoInst *index, gboolean bcheck);
<span class="lineNum">    2624 </span>            : CompRelation      mono_opcode_to_cond (int opcode) MONO_LLVM_INTERNAL;
<span class="lineNum">    2625 </span>            : CompType          mono_opcode_to_type (int opcode, int cmp_opcode);
<span class="lineNum">    2626 </span>            : CompRelation      mono_negate_cond (CompRelation cond);
<span class="lineNum">    2627 </span>            : int               mono_op_imm_to_op (int opcode);
<span class="lineNum">    2628 </span>            : void              mono_decompose_op_imm (MonoCompile *cfg, MonoBasicBlock *bb, MonoInst *ins);
<span class="lineNum">    2629 </span>            : void              mono_peephole_ins (MonoBasicBlock *bb, MonoInst *ins);
<span class="lineNum">    2630 </span>            : MonoUnwindOp     *mono_create_unwind_op (int when, 
<span class="lineNum">    2631 </span>            :                                                                                  int tag, int reg, 
<span class="lineNum">    2632 </span>            :                                                                                  int val);
<span class="lineNum">    2633 </span>            : void              mono_emit_unwind_op (MonoCompile *cfg, int when, 
<span class="lineNum">    2634 </span>            :                                                                            int tag, int reg, 
<span class="lineNum">    2635 </span>            :                                                                            int val);
<span class="lineNum">    2636 </span>            : MonoTrampInfo*    mono_tramp_info_create (const char *name, guint8 *code, guint32 code_size, MonoJumpInfo *ji, GSList *unwind_ops);
<span class="lineNum">    2637 </span>            : void              mono_tramp_info_free (MonoTrampInfo *info);
<span class="lineNum">    2638 </span>            : void              mono_tramp_info_register (MonoTrampInfo *info, MonoDomain *domain);
<span class="lineNum">    2639 </span>            : int               mini_exception_id_by_name (const char *name);
<span class="lineNum">    2640 </span>            : gboolean          mini_type_is_hfa (MonoType *t, int *out_nfields, int *out_esize) MONO_LLVM_INTERNAL;
<span class="lineNum">    2641 </span>            : 
<span class="lineNum">    2642 </span>            : int               mono_method_to_ir (MonoCompile *cfg, MonoMethod *method, MonoBasicBlock *start_bblock, MonoBasicBlock *end_bblock, 
<span class="lineNum">    2643 </span>            :                                                                          MonoInst *return_var, MonoInst **inline_args,
<span class="lineNum">    2644 </span>            :                                                                          guint inline_offset, gboolean is_virtual_call);
<span class="lineNum">    2645 </span>            : 
<span class="lineNum">    2646 </span>            : //the following methods could just be renamed/moved from method-to-ir.c
<span class="lineNum">    2647 </span>            : int               mini_inline_method (MonoCompile *cfg, MonoMethod *cmethod, MonoMethodSignature *fsig, MonoInst **sp, guchar *ip,
<span class="lineNum">    2648 </span>            :                                                                           guint real_offset, gboolean inline_always);
<span class="lineNum">    2649 </span>            : 
<span class="lineNum">    2650 </span>            : MonoInst*         mini_emit_get_rgctx_klass (MonoCompile *cfg, int context_used, MonoClass *klass, MonoRgctxInfoType rgctx_type);
<span class="lineNum">    2651 </span>            : MonoInst*         mini_emit_runtime_constant (MonoCompile *cfg, MonoJumpInfoType patch_type, gpointer data);
<span class="lineNum">    2652 </span>            : void              mini_save_cast_details (MonoCompile *cfg, MonoClass *klass, int obj_reg, gboolean null_check);
<span class="lineNum">    2653 </span>            : void              mini_reset_cast_details (MonoCompile *cfg);
<span class="lineNum">    2654 </span>            : void              mini_emit_class_check (MonoCompile *cfg, int klass_reg, MonoClass *klass);
<span class="lineNum">    2655 </span>            : 
<span class="lineNum">    2656 </span>            : gboolean          mini_class_has_reference_variant_generic_argument (MonoCompile *cfg, MonoClass *klass, int context_used);
<span class="lineNum">    2657 </span>            : 
<span class="lineNum">    2658 </span>            : 
<span class="lineNum">    2659 </span>            : MonoInst         *mono_decompose_opcode (MonoCompile *cfg, MonoInst *ins);
<span class="lineNum">    2660 </span>            : void              mono_decompose_long_opts (MonoCompile *cfg);
<span class="lineNum">    2661 </span>            : void              mono_decompose_vtype_opts (MonoCompile *cfg);
<span class="lineNum">    2662 </span>            : void              mono_decompose_array_access_opts (MonoCompile *cfg);
<span class="lineNum">    2663 </span>            : void              mono_decompose_soft_float (MonoCompile *cfg);
<span class="lineNum">    2664 </span>            : void              mono_local_emulate_ops (MonoCompile *cfg);
<span class="lineNum">    2665 </span>            : void              mono_handle_global_vregs (MonoCompile *cfg);
<span class="lineNum">    2666 </span>            : void              mono_spill_global_vars (MonoCompile *cfg, gboolean *need_local_opts);
<span class="lineNum">    2667 </span>            : void              mono_allocate_gsharedvt_vars (MonoCompile *cfg);
<span class="lineNum">    2668 </span>            : void              mono_if_conversion (MonoCompile *cfg);
<span class="lineNum">    2669 </span>            : 
<span class="lineNum">    2670 </span>            : 
<span class="lineNum">    2671 </span>            : 
<span class="lineNum">    2672 </span>            : /* Delegates */
<span class="lineNum">    2673 </span>            : gpointer          mini_get_delegate_arg (MonoMethod *method, gpointer method_ptr);
<span class="lineNum">    2674 </span>            : void              mini_init_delegate (MonoDelegate *del);
<span class="lineNum">    2675 </span>            : char*             mono_get_delegate_virtual_invoke_impl_name (gboolean load_imt_reg, int offset);
<span class="lineNum">    2676 </span>            : gpointer          mono_get_delegate_virtual_invoke_impl  (MonoMethodSignature *sig, MonoMethod *method);
<span class="lineNum">    2677 </span>            : 
<span class="lineNum">    2678 </span>            : /* methods that must be provided by the arch-specific port */
<span class="lineNum">    2679 </span>            : void      mono_arch_init                        (void);
<span class="lineNum">    2680 </span>            : void      mono_arch_finish_init                 (void);
<span class="lineNum">    2681 </span>            : void      mono_arch_cleanup                     (void);
<span class="lineNum">    2682 </span>            : void      mono_arch_cpu_init                    (void);
<span class="lineNum">    2683 </span>            : guint32   mono_arch_cpu_optimizations           (guint32 *exclude_mask);
<span class="lineNum">    2684 </span>            : void      mono_arch_instrument_mem_needs        (MonoMethod *method, int *stack, int *code);
<span class="lineNum">    2685 </span>            : void     *mono_arch_instrument_prolog           (MonoCompile *cfg, void *func, void *p, gboolean enable_arguments);
<span class="lineNum">    2686 </span>            : void     *mono_arch_instrument_epilog           (MonoCompile *cfg, void *func, void *p, gboolean enable_arguments);
<span class="lineNum">    2687 </span>            : void     *mono_arch_instrument_epilog_full     (MonoCompile *cfg, void *func, void *p, gboolean enable_arguments, gboolean preserve_argument_registers);
<span class="lineNum">    2688 </span>            : void      mono_codegen                          (MonoCompile *cfg);
<span class="lineNum">    2689 </span>            : void      mono_call_inst_add_outarg_reg         (MonoCompile *cfg, MonoCallInst *call, int vreg, int hreg, int bank) MONO_LLVM_INTERNAL;
<span class="lineNum">    2690 </span>            : void      mono_call_inst_add_outarg_vt          (MonoCompile *cfg, MonoCallInst *call, MonoInst *outarg_vt);
<span class="lineNum">    2691 </span>            : const char *mono_arch_regname                   (int reg);
<span class="lineNum">    2692 </span>            : const char *mono_arch_fregname                  (int reg);
<span class="lineNum">    2693 </span>            : void      mono_arch_exceptions_init             (void);
<span class="lineNum">    2694 </span>            : guchar*   mono_arch_create_generic_trampoline   (MonoTrampolineType tramp_type, MonoTrampInfo **info, gboolean aot);
<span class="lineNum">    2695 </span>            : gpointer  mono_arch_create_rgctx_lazy_fetch_trampoline (guint32 slot, MonoTrampInfo **info, gboolean aot);
<span class="lineNum">    2696 </span>            : gpointer  mono_arch_create_general_rgctx_lazy_fetch_trampoline (MonoTrampInfo **info, gboolean aot);
<span class="lineNum">    2697 </span>            : gpointer  mono_arch_get_nullified_class_init_trampoline (MonoTrampInfo **info);
<span class="lineNum">    2698 </span>            : guint8*   mono_arch_create_sdb_trampoline (gboolean single_step, MonoTrampInfo **info, gboolean aot);
<span class="lineNum">    2699 </span>            : gpointer  mono_arch_create_monitor_enter_trampoline (MonoTrampInfo **info, gboolean is_v4, gboolean aot);
<span class="lineNum">    2700 </span>            : gpointer  mono_arch_create_monitor_exit_trampoline (MonoTrampInfo **info, gboolean aot);
<span class="lineNum">    2701 </span>            : guint8   *mono_arch_create_llvm_native_thunk     (MonoDomain *domain, guint8* addr) MONO_LLVM_INTERNAL;
<span class="lineNum">    2702 </span>            : gpointer  mono_arch_get_get_tls_tramp (void);
<span class="lineNum">    2703 </span>            : GList    *mono_arch_get_allocatable_int_vars    (MonoCompile *cfg);
<span class="lineNum">    2704 </span>            : GList    *mono_arch_get_global_int_regs         (MonoCompile *cfg);
<span class="lineNum">    2705 </span>            : GList    *mono_arch_get_global_fp_regs          (MonoCompile *cfg);
<span class="lineNum">    2706 </span>            : GList    *mono_arch_get_iregs_clobbered_by_call (MonoCallInst *call);
<span class="lineNum">    2707 </span>            : GList    *mono_arch_get_fregs_clobbered_by_call (MonoCallInst *call);
<span class="lineNum">    2708 </span>            : guint32   mono_arch_regalloc_cost               (MonoCompile *cfg, MonoMethodVar *vmv);
<span class="lineNum">    2709 </span>            : void      mono_arch_patch_code                  (MonoCompile *cfg, MonoMethod *method, MonoDomain *domain, guint8 *code, MonoJumpInfo *ji, gboolean run_cctors, MonoError *error);
<span class="lineNum">    2710 </span>            : void      mono_arch_patch_code_new              (MonoCompile *cfg, MonoDomain *domain, guint8 *code, MonoJumpInfo *ji, gpointer target);
<span class="lineNum">    2711 </span>            : void      mono_arch_flush_icache                (guint8 *code, gint size);
<span class="lineNum">    2712 </span>            : int       mono_arch_max_epilog_size             (MonoCompile *cfg);
<span class="lineNum">    2713 </span>            : guint8   *mono_arch_emit_prolog                 (MonoCompile *cfg);
<span class="lineNum">    2714 </span>            : void      mono_arch_emit_epilog                 (MonoCompile *cfg);
<span class="lineNum">    2715 </span>            : void      mono_arch_emit_exceptions             (MonoCompile *cfg);
<span class="lineNum">    2716 </span>            : void      mono_arch_lowering_pass               (MonoCompile *cfg, MonoBasicBlock *bb);
<span class="lineNum">    2717 </span>            : void      mono_arch_peephole_pass_1             (MonoCompile *cfg, MonoBasicBlock *bb);
<span class="lineNum">    2718 </span>            : void      mono_arch_peephole_pass_2             (MonoCompile *cfg, MonoBasicBlock *bb);
<span class="lineNum">    2719 </span>            : void      mono_arch_output_basic_block          (MonoCompile *cfg, MonoBasicBlock *bb);
<span class="lineNum">    2720 </span>            : void      mono_arch_free_jit_tls_data           (MonoJitTlsData *tls);
<span class="lineNum">    2721 </span>            : void      mono_arch_fill_argument_info          (MonoCompile *cfg);
<span class="lineNum">    2722 </span>            : void      mono_arch_allocate_vars               (MonoCompile *m);
<span class="lineNum">    2723 </span>            : int       mono_arch_get_argument_info           (MonoMethodSignature *csig, int param_count, MonoJitArgumentInfo *arg_info);
<span class="lineNum">    2724 </span>            : gboolean  mono_arch_print_tree                          (MonoInst *tree, int arity);
<span class="lineNum">    2725 </span>            : void      mono_arch_emit_call                   (MonoCompile *cfg, MonoCallInst *call);
<span class="lineNum">    2726 </span>            : void      mono_arch_emit_outarg_vt              (MonoCompile *cfg, MonoInst *ins, MonoInst *src);
<span class="lineNum">    2727 </span>            : void      mono_arch_emit_setret                 (MonoCompile *cfg, MonoMethod *method, MonoInst *val);
<span class="lineNum">    2728 </span>            : MonoDynCallInfo *mono_arch_dyn_call_prepare     (MonoMethodSignature *sig);
<span class="lineNum">    2729 </span>            : void      mono_arch_dyn_call_free               (MonoDynCallInfo *info);
<span class="lineNum">    2730 </span>            : void      mono_arch_start_dyn_call              (MonoDynCallInfo *info, gpointer **args, guint8 *ret, guint8 *buf, int buf_len);
<span class="lineNum">    2731 </span>            : void      mono_arch_finish_dyn_call             (MonoDynCallInfo *info, guint8 *buf);
<span class="lineNum">    2732 </span>            : MonoInst *mono_arch_emit_inst_for_method        (MonoCompile *cfg, MonoMethod *cmethod, MonoMethodSignature *fsig, MonoInst **args);
<span class="lineNum">    2733 </span>            : void      mono_arch_decompose_opts              (MonoCompile *cfg, MonoInst *ins);
<span class="lineNum">    2734 </span>            : void      mono_arch_decompose_long_opts         (MonoCompile *cfg, MonoInst *ins);
<span class="lineNum">    2735 </span>            : GSList*   mono_arch_get_delegate_invoke_impls   (void);
<span class="lineNum">    2736 </span>            : LLVMCallInfo* mono_arch_get_llvm_call_info      (MonoCompile *cfg, MonoMethodSignature *sig) MONO_LLVM_INTERNAL;
<span class="lineNum">    2737 </span>            : guint8*   mono_arch_emit_load_got_addr          (guint8 *start, guint8 *code, MonoCompile *cfg, MonoJumpInfo **ji);
<span class="lineNum">    2738 </span>            : guint8*   mono_arch_emit_load_aotconst          (guint8 *start, guint8 *code, MonoJumpInfo **ji, MonoJumpInfoType tramp_type, gconstpointer target);
<span class="lineNum">    2739 </span>            : GSList*   mono_arch_get_cie_program             (void);
<span class="lineNum">    2740 </span>            : void      mono_arch_set_target                  (char *mtriple);
<span class="lineNum">    2741 </span>            : gboolean  mono_arch_gsharedvt_sig_supported     (MonoMethodSignature *sig);
<span class="lineNum">    2742 </span>            : gpointer  mono_arch_get_gsharedvt_trampoline    (MonoTrampInfo **info, gboolean aot);
<span class="lineNum">    2743 </span>            : gpointer  mono_arch_get_gsharedvt_call_info     (gpointer addr, MonoMethodSignature *normal_sig, MonoMethodSignature *gsharedvt_sig, gboolean gsharedvt_in, gint32 vcall_offset, gboolean calli);
<span class="lineNum">    2744 </span>            : gboolean  mono_arch_opcode_needs_emulation      (MonoCompile *cfg, int opcode);
<span class="lineNum">    2745 </span>            : gboolean  mono_arch_tail_call_supported         (MonoCompile *cfg, MonoMethodSignature *caller_sig, MonoMethodSignature *callee_sig);
<span class="lineNum">    2746 </span>            : int       mono_arch_translate_tls_offset        (int offset);
<span class="lineNum">    2747 </span>            : gboolean  mono_arch_opcode_supported            (int opcode);
<span class="lineNum">    2748 </span>            : void     mono_arch_setup_resume_sighandler_ctx  (MonoContext *ctx, gpointer func);
<span class="lineNum">    2749 </span>            : gboolean  mono_arch_have_fast_tls               (void);
<span class="lineNum">    2750 </span>            : 
<span class="lineNum">    2751 </span>            : #ifdef MONO_ARCH_SOFT_FLOAT_FALLBACK
<span class="lineNum">    2752 </span>            : gboolean  mono_arch_is_soft_float               (void);
<a name="2753"><span class="lineNum">    2753 </span>            : #else</a>
<span class="lineNum">    2754 </span>            : static inline MONO_ALWAYS_INLINE gboolean
<span class="lineNum">    2755 </span>            : mono_arch_is_soft_float (void)
<span class="lineNum">    2756 </span>            : {
<span class="lineNum">    2757 </span><span class="lineCov">  433810300 :         return FALSE;</span>
<span class="lineNum">    2758 </span>            : }
<span class="lineNum">    2759 </span>            : #endif
<span class="lineNum">    2760 </span>            : 
<span class="lineNum">    2761 </span>            : /* Soft Debug support */
<span class="lineNum">    2762 </span>            : #ifdef MONO_ARCH_SOFT_DEBUG_SUPPORTED
<span class="lineNum">    2763 </span>            : void      mono_arch_set_breakpoint              (MonoJitInfo *ji, guint8 *ip);
<span class="lineNum">    2764 </span>            : void      mono_arch_clear_breakpoint            (MonoJitInfo *ji, guint8 *ip);
<span class="lineNum">    2765 </span>            : void      mono_arch_start_single_stepping       (void);
<span class="lineNum">    2766 </span>            : void      mono_arch_stop_single_stepping        (void);
<span class="lineNum">    2767 </span>            : gboolean  mono_arch_is_single_step_event        (void *info, void *sigctx);
<span class="lineNum">    2768 </span>            : gboolean  mono_arch_is_breakpoint_event         (void *info, void *sigctx);
<span class="lineNum">    2769 </span>            : void     mono_arch_skip_breakpoint              (MonoContext *ctx, MonoJitInfo *ji);
<span class="lineNum">    2770 </span>            : void     mono_arch_skip_single_step             (MonoContext *ctx);
<span class="lineNum">    2771 </span>            : gpointer mono_arch_get_seq_point_info           (MonoDomain *domain, guint8 *code);
<span class="lineNum">    2772 </span>            : void     mono_arch_init_lmf_ext                 (MonoLMFExt *ext, gpointer prev_lmf);
<span class="lineNum">    2773 </span>            : #endif
<span class="lineNum">    2774 </span>            : 
<span class="lineNum">    2775 </span>            : gboolean
<span class="lineNum">    2776 </span>            : mono_arch_unwind_frame (MonoDomain *domain, MonoJitTlsData *jit_tls, 
<span class="lineNum">    2777 </span>            :                                                 MonoJitInfo *ji, MonoContext *ctx, 
<span class="lineNum">    2778 </span>            :                                                 MonoContext *new_ctx, MonoLMF **lmf,
<span class="lineNum">    2779 </span>            :                                                 mgreg_t **save_locations,
<span class="lineNum">    2780 </span>            :                                                 StackFrameInfo *frame_info);
<span class="lineNum">    2781 </span>            : gpointer  mono_arch_get_throw_exception_by_name (void);
<span class="lineNum">    2782 </span>            : gpointer mono_arch_get_call_filter              (MonoTrampInfo **info, gboolean aot);
<span class="lineNum">    2783 </span>            : gpointer mono_arch_get_restore_context          (MonoTrampInfo **info, gboolean aot);
<span class="lineNum">    2784 </span>            : gpointer  mono_arch_get_throw_exception         (MonoTrampInfo **info, gboolean aot);
<span class="lineNum">    2785 </span>            : gpointer  mono_arch_get_rethrow_exception       (MonoTrampInfo **info, gboolean aot);
<span class="lineNum">    2786 </span>            : gpointer  mono_arch_get_throw_corlib_exception  (MonoTrampInfo **info, gboolean aot);
<span class="lineNum">    2787 </span>            : gpointer  mono_arch_get_throw_pending_exception (MonoTrampInfo **info, gboolean aot);
<span class="lineNum">    2788 </span>            : gboolean mono_arch_handle_exception             (void *sigctx, gpointer obj);
<span class="lineNum">    2789 </span>            : void     mono_arch_handle_altstack_exception    (void *sigctx, MONO_SIG_HANDLER_INFO_TYPE *siginfo, gpointer fault_addr, gboolean stack_ovf);
<span class="lineNum">    2790 </span>            : gboolean mono_handle_soft_stack_ovf             (MonoJitTlsData *jit_tls, MonoJitInfo *ji, void *ctx, MONO_SIG_HANDLER_INFO_TYPE *siginfo, guint8* fault_addr);
<span class="lineNum">    2791 </span>            : void     mono_handle_hard_stack_ovf             (MonoJitTlsData *jit_tls, MonoJitInfo *ji, void *ctx, guint8* fault_addr);
<span class="lineNum">    2792 </span>            : gpointer mono_arch_ip_from_context              (void *sigctx);
<span class="lineNum">    2793 </span>            : mgreg_t mono_arch_context_get_int_reg               (MonoContext *ctx, int reg);
<span class="lineNum">    2794 </span>            : void     mono_arch_context_set_int_reg              (MonoContext *ctx, int reg, mgreg_t val);
<span class="lineNum">    2795 </span>            : void     mono_arch_flush_register_windows       (void);
<span class="lineNum">    2796 </span>            : gboolean mono_arch_is_inst_imm                  (gint64 imm);
<span class="lineNum">    2797 </span>            : gboolean mono_arch_is_int_overflow              (void *sigctx, void *info);
<span class="lineNum">    2798 </span>            : void     mono_arch_invalidate_method            (MonoJitInfo *ji, void *func, gpointer func_arg);
<span class="lineNum">    2799 </span>            : guint32  mono_arch_get_patch_offset             (guint8 *code);
<span class="lineNum">    2800 </span>            : gpointer*mono_arch_get_delegate_method_ptr_addr (guint8* code, mgreg_t *regs);
<span class="lineNum">    2801 </span>            : void     mono_arch_create_vars                  (MonoCompile *cfg) MONO_LLVM_INTERNAL;
<span class="lineNum">    2802 </span>            : void     mono_arch_save_unwind_info             (MonoCompile *cfg);
<span class="lineNum">    2803 </span>            : void     mono_arch_register_lowlevel_calls      (void);
<span class="lineNum">    2804 </span>            : gpointer mono_arch_get_unbox_trampoline         (MonoMethod *m, gpointer addr);
<span class="lineNum">    2805 </span>            : gpointer mono_arch_get_static_rgctx_trampoline  (MonoMethod *m, MonoMethodRuntimeGenericContext *mrgctx, gpointer addr);
<span class="lineNum">    2806 </span>            : gpointer  mono_arch_get_llvm_imt_trampoline     (MonoDomain *domain, MonoMethod *method, int vt_offset);
<span class="lineNum">    2807 </span>            : gpointer mono_arch_get_gsharedvt_arg_trampoline (MonoDomain *domain, gpointer arg, gpointer addr);
<span class="lineNum">    2808 </span>            : void     mono_arch_patch_callsite               (guint8 *method_start, guint8 *code, guint8 *addr);
<span class="lineNum">    2809 </span>            : void     mono_arch_patch_plt_entry              (guint8 *code, gpointer *got, mgreg_t *regs, guint8 *addr);
<span class="lineNum">    2810 </span>            : void     mono_arch_nullify_class_init_trampoline(guint8 *code, mgreg_t *regs);
<span class="lineNum">    2811 </span>            : int      mono_arch_get_this_arg_reg             (guint8 *code);
<span class="lineNum">    2812 </span>            : gpointer mono_arch_get_this_arg_from_call       (mgreg_t *regs, guint8 *code);
<span class="lineNum">    2813 </span>            : gpointer mono_arch_get_delegate_invoke_impl     (MonoMethodSignature *sig, gboolean has_target);
<span class="lineNum">    2814 </span>            : gpointer mono_arch_get_delegate_virtual_invoke_impl (MonoMethodSignature *sig, MonoMethod *method, int offset, gboolean load_imt_reg);
<span class="lineNum">    2815 </span>            : gpointer mono_arch_create_specific_trampoline   (gpointer arg1, MonoTrampolineType tramp_type, MonoDomain *domain, guint32 *code_len);
<span class="lineNum">    2816 </span>            : MonoMethod* mono_arch_find_imt_method           (mgreg_t *regs, guint8 *code);
<span class="lineNum">    2817 </span>            : MonoVTable* mono_arch_find_static_call_vtable   (mgreg_t *regs, guint8 *code);
<span class="lineNum">    2818 </span>            : gpointer    mono_arch_build_imt_trampoline      (MonoVTable *vtable, MonoDomain *domain, MonoIMTCheckItem **imt_entries, int count, gpointer fail_tramp);
<span class="lineNum">    2819 </span>            : void    mono_arch_notify_pending_exc            (MonoThreadInfo *info);
<span class="lineNum">    2820 </span>            : guint8* mono_arch_get_call_target               (guint8 *code);
<span class="lineNum">    2821 </span>            : guint32 mono_arch_get_plt_info_offset           (guint8 *plt_entry, mgreg_t *regs, guint8 *code);
<span class="lineNum">    2822 </span>            : GSList *mono_arch_get_trampolines               (gboolean aot);
<span class="lineNum">    2823 </span>            : #ifdef ENABLE_INTERPRETER
<span class="lineNum">    2824 </span>            : gpointer mono_arch_get_enter_icall_trampoline (MonoTrampInfo **info);
<span class="lineNum">    2825 </span>            : #endif
<span class="lineNum">    2826 </span>            : 
<span class="lineNum">    2827 </span>            : /* Handle block guard */
<span class="lineNum">    2828 </span>            : gpointer mono_arch_install_handler_block_guard (MonoJitInfo *ji, MonoJitExceptionInfo *clause, MonoContext *ctx, gpointer new_value);
<span class="lineNum">    2829 </span>            : gpointer mono_arch_create_handler_block_trampoline (MonoTrampInfo **info, gboolean aot);
<span class="lineNum">    2830 </span>            : gpointer mono_create_handler_block_trampoline (void);
<span class="lineNum">    2831 </span>            : gboolean mono_install_handler_block_guard (MonoThreadUnwindState *ctx);
<span class="lineNum">    2832 </span>            : 
<span class="lineNum">    2833 </span>            : /*New interruption machinery */
<span class="lineNum">    2834 </span>            : void
<span class="lineNum">    2835 </span>            : mono_setup_async_callback (MonoContext *ctx, void (*async_cb)(void *fun), gpointer user_data);
<span class="lineNum">    2836 </span>            : 
<span class="lineNum">    2837 </span>            : void
<span class="lineNum">    2838 </span>            : mono_arch_setup_async_callback (MonoContext *ctx, void (*async_cb)(void *fun), gpointer user_data);
<span class="lineNum">    2839 </span>            : 
<span class="lineNum">    2840 </span>            : gboolean
<span class="lineNum">    2841 </span>            : mono_thread_state_init_from_handle (MonoThreadUnwindState *tctx, MonoThreadInfo *info);
<span class="lineNum">    2842 </span>            : 
<span class="lineNum">    2843 </span>            : 
<span class="lineNum">    2844 </span>            : /* Exception handling */
<span class="lineNum">    2845 </span>            : typedef gboolean (*MonoJitStackWalk)            (StackFrameInfo *frame, MonoContext *ctx, gpointer data);
<span class="lineNum">    2846 </span>            : 
<span class="lineNum">    2847 </span>            : void     mono_exceptions_init                   (void);
<span class="lineNum">    2848 </span>            : gboolean mono_handle_exception                  (MonoContext *ctx, MonoObject *obj);
<span class="lineNum">    2849 </span>            : void     mono_handle_native_crash               (const char *signal, void *sigctx, MONO_SIG_HANDLER_INFO_TYPE *siginfo);
<span class="lineNum">    2850 </span>            : MONO_API void     mono_print_thread_dump                 (void *sigctx);
<span class="lineNum">    2851 </span>            : MONO_API void     mono_print_thread_dump_from_ctx        (MonoContext *ctx);
<span class="lineNum">    2852 </span>            : void     mono_walk_stack_with_ctx               (MonoJitStackWalk func, MonoContext *start_ctx, MonoUnwindOptions unwind_options, void *user_data);
<span class="lineNum">    2853 </span>            : void     mono_walk_stack_with_state             (MonoJitStackWalk func, MonoThreadUnwindState *state, MonoUnwindOptions unwind_options, void *user_data);
<span class="lineNum">    2854 </span>            : void     mono_walk_stack                        (MonoJitStackWalk func, MonoUnwindOptions options, void *user_data);
<span class="lineNum">    2855 </span>            : gboolean mono_thread_state_init_from_sigctx     (MonoThreadUnwindState *ctx, void *sigctx);
<span class="lineNum">    2856 </span>            : void     mono_thread_state_init                 (MonoThreadUnwindState *ctx);
<span class="lineNum">    2857 </span>            : gboolean mono_thread_state_init_from_current    (MonoThreadUnwindState *ctx);
<span class="lineNum">    2858 </span>            : gboolean mono_thread_state_init_from_monoctx    (MonoThreadUnwindState *ctx, MonoContext *mctx);
<span class="lineNum">    2859 </span>            : 
<span class="lineNum">    2860 </span>            : void     mono_setup_altstack                    (MonoJitTlsData *tls);
<span class="lineNum">    2861 </span>            : void     mono_free_altstack                     (MonoJitTlsData *tls);
<span class="lineNum">    2862 </span>            : gpointer mono_altstack_restore_prot             (mgreg_t *regs, guint8 *code, gpointer *tramp_data, guint8* tramp);
<span class="lineNum">    2863 </span>            : MonoJitInfo* mini_jit_info_table_find           (MonoDomain *domain, char *addr, MonoDomain **out_domain);
<span class="lineNum">    2864 </span>            : MonoJitInfo* mini_jit_info_table_find_ext       (MonoDomain *domain, char *addr, gboolean allow_trampolines, MonoDomain **out_domain);
<span class="lineNum">    2865 </span>            : void     mono_resume_unwind                     (MonoContext *ctx) MONO_LLVM_INTERNAL;
<span class="lineNum">    2866 </span>            : 
<span class="lineNum">    2867 </span>            : MonoJitInfo * mono_find_jit_info                (MonoDomain *domain, MonoJitTlsData *jit_tls, MonoJitInfo *res, MonoJitInfo *prev_ji, MonoContext *ctx, MonoContext *new_ctx, char **trace, MonoLMF **lmf, int *native_offset, gboolean *managed);
<span class="lineNum">    2868 </span>            : 
<span class="lineNum">    2869 </span>            : typedef gboolean (*MonoExceptionFrameWalk)      (MonoMethod *method, gpointer ip, size_t native_offset, gboolean managed, gpointer user_data);
<span class="lineNum">    2870 </span>            : MONO_API gboolean mono_exception_walk_trace     (MonoException *ex, MonoExceptionFrameWalk func, gpointer user_data);
<span class="lineNum">    2871 </span>            : void mono_restore_context                       (MonoContext *ctx);
<span class="lineNum">    2872 </span>            : guint8* mono_jinfo_get_unwind_info              (MonoJitInfo *ji, guint32 *unwind_info_len);
<span class="lineNum">    2873 </span>            : int  mono_jinfo_get_epilog_size                 (MonoJitInfo *ji);
<span class="lineNum">    2874 </span>            : void     mono_llvm_rethrow_exception            (MonoObject *ex);
<span class="lineNum">    2875 </span>            : void     mono_llvm_throw_exception              (MonoObject *ex);
<span class="lineNum">    2876 </span>            : void     mono_llvm_throw_corlib_exception       (guint32 ex_token_index);
<span class="lineNum">    2877 </span>            : void     mono_llvm_resume_exception             (void);
<span class="lineNum">    2878 </span>            : void     mono_llvm_clear_exception              (void);
<span class="lineNum">    2879 </span>            : MonoObject *mono_llvm_load_exception            (void);
<span class="lineNum">    2880 </span>            : void     mono_llvm_reset_exception              (void);
<span class="lineNum">    2881 </span>            : void     mono_llvm_raise_exception              (MonoException *e);
<span class="lineNum">    2882 </span>            : gint32 mono_llvm_match_exception                (MonoJitInfo *jinfo, guint32 region_start, guint32 region_end, gpointer rgctx, MonoObject *this_obj);
<span class="lineNum">    2883 </span>            : 
<span class="lineNum">    2884 </span>            : gboolean
<span class="lineNum">    2885 </span>            : mono_find_jit_info_ext (MonoDomain *domain, MonoJitTlsData *jit_tls, 
<span class="lineNum">    2886 </span>            :                                                 MonoJitInfo *prev_ji, MonoContext *ctx,
<span class="lineNum">    2887 </span>            :                                                 MonoContext *new_ctx, char **trace, MonoLMF **lmf,
<span class="lineNum">    2888 </span>            :                                                 mgreg_t **save_locations,
<span class="lineNum">    2889 </span>            :                                                 StackFrameInfo *frame);
<span class="lineNum">    2890 </span>            : 
<span class="lineNum">    2891 </span>            : gpointer mono_get_throw_exception               (void);
<span class="lineNum">    2892 </span>            : gpointer mono_get_rethrow_exception             (void);
<span class="lineNum">    2893 </span>            : gpointer mono_get_call_filter                   (void);
<span class="lineNum">    2894 </span>            : gpointer mono_get_restore_context               (void);
<span class="lineNum">    2895 </span>            : gpointer mono_get_throw_exception_by_name       (void);
<span class="lineNum">    2896 </span>            : gpointer mono_get_throw_corlib_exception        (void);
<span class="lineNum">    2897 </span>            : gpointer mono_get_throw_exception_addr          (void);
<span class="lineNum">    2898 </span>            : MonoArray *ves_icall_get_trace                  (MonoException *exc, gint32 skip, MonoBoolean need_file_info);
<span class="lineNum">    2899 </span>            : MonoBoolean ves_icall_get_frame_info            (gint32 skip, MonoBoolean need_file_info, 
<span class="lineNum">    2900 </span>            :                                                  MonoReflectionMethod **method, 
<span class="lineNum">    2901 </span>            :                                                  gint32 *iloffset, gint32 *native_offset,
<span class="lineNum">    2902 </span>            :                                                  MonoString **file, gint32 *line, gint32 *column);
<span class="lineNum">    2903 </span>            : void mono_set_cast_details                      (MonoClass *from, MonoClass *to);
<span class="lineNum">    2904 </span>            : 
<span class="lineNum">    2905 </span>            : void mono_decompose_typechecks (MonoCompile *cfg);
<span class="lineNum">    2906 </span>            : /* Dominator/SSA methods */
<span class="lineNum">    2907 </span>            : void        mono_compile_dominator_info         (MonoCompile *cfg, int dom_flags);
<span class="lineNum">    2908 </span>            : void        mono_compute_natural_loops          (MonoCompile *cfg);
<span class="lineNum">    2909 </span>            : MonoBitSet* mono_compile_iterated_dfrontier     (MonoCompile *cfg, MonoBitSet *set);
<span class="lineNum">    2910 </span>            : void        mono_ssa_compute                    (MonoCompile *cfg);
<span class="lineNum">    2911 </span>            : void        mono_ssa_remove                     (MonoCompile *cfg);
<span class="lineNum">    2912 </span>            : void        mono_ssa_remove_gsharedvt           (MonoCompile *cfg);
<span class="lineNum">    2913 </span>            : void        mono_ssa_cprop                      (MonoCompile *cfg);
<span class="lineNum">    2914 </span>            : void        mono_ssa_deadce                     (MonoCompile *cfg);
<span class="lineNum">    2915 </span>            : void        mono_ssa_strength_reduction         (MonoCompile *cfg);
<span class="lineNum">    2916 </span>            : void        mono_free_loop_info                 (MonoCompile *cfg);
<span class="lineNum">    2917 </span>            : void        mono_ssa_loop_invariant_code_motion (MonoCompile *cfg);
<span class="lineNum">    2918 </span>            : 
<span class="lineNum">    2919 </span>            : void        mono_ssa_compute2                   (MonoCompile *cfg);
<span class="lineNum">    2920 </span>            : void        mono_ssa_remove2                    (MonoCompile *cfg);
<span class="lineNum">    2921 </span>            : void        mono_ssa_cprop2                     (MonoCompile *cfg);
<span class="lineNum">    2922 </span>            : void        mono_ssa_deadce2                    (MonoCompile *cfg);
<span class="lineNum">    2923 </span>            : 
<span class="lineNum">    2924 </span>            : /* debugging support */
<span class="lineNum">    2925 </span>            : void      mono_debug_init_method                (MonoCompile *cfg, MonoBasicBlock *start_block,
<span class="lineNum">    2926 </span>            :                                                  guint32 breakpoint_id);
<span class="lineNum">    2927 </span>            : void      mono_debug_open_method                (MonoCompile *cfg);
<span class="lineNum">    2928 </span>            : void      mono_debug_close_method               (MonoCompile *cfg);
<span class="lineNum">    2929 </span>            : void      mono_debug_free_method                (MonoCompile *cfg);
<span class="lineNum">    2930 </span>            : void      mono_debug_open_block                 (MonoCompile *cfg, MonoBasicBlock *bb, guint32 address);
<span class="lineNum">    2931 </span>            : void      mono_debug_record_line_number         (MonoCompile *cfg, MonoInst *ins, guint32 address);
<span class="lineNum">    2932 </span>            : void      mono_debug_serialize_debug_info       (MonoCompile *cfg, guint8 **out_buf, guint32 *buf_len);
<span class="lineNum">    2933 </span>            : void      mono_debug_add_aot_method             (MonoDomain *domain,
<span class="lineNum">    2934 </span>            :                                                  MonoMethod *method, guint8 *code_start, 
<span class="lineNum">    2935 </span>            :                                                  guint8 *debug_info, guint32 debug_info_len);
<span class="lineNum">    2936 </span>            : MONO_API void      mono_debug_print_vars                 (gpointer ip, gboolean only_arguments);
<span class="lineNum">    2937 </span>            : MONO_API void      mono_debugger_run_finally             (MonoContext *start_ctx);
<span class="lineNum">    2938 </span>            : 
<span class="lineNum">    2939 </span>            : MONO_API gboolean mono_breakpoint_clean_code (guint8 *method_start, guint8 *code, int offset, guint8 *buf, int size);
<span class="lineNum">    2940 </span>            : 
<span class="lineNum">    2941 </span>            : /* Tracing */
<span class="lineNum">    2942 </span>            : MonoTraceSpec *mono_trace_parse_options         (const char *options);
<span class="lineNum">    2943 </span>            : void           mono_trace_set_assembly          (MonoAssembly *assembly);
<span class="lineNum">    2944 </span>            : gboolean       mono_trace_eval                  (MonoMethod *method);
<span class="lineNum">    2945 </span>            : 
<span class="lineNum">    2946 </span>            : extern void
<span class="lineNum">    2947 </span>            : mono_perform_abc_removal (MonoCompile *cfg);
<span class="lineNum">    2948 </span>            : extern void
<span class="lineNum">    2949 </span>            : mono_perform_abc_removal (MonoCompile *cfg);
<span class="lineNum">    2950 </span>            : extern void
<span class="lineNum">    2951 </span>            : mono_perform_ssapre (MonoCompile *cfg);
<span class="lineNum">    2952 </span>            : extern void
<span class="lineNum">    2953 </span>            : mono_local_cprop (MonoCompile *cfg);
<span class="lineNum">    2954 </span>            : extern void
<span class="lineNum">    2955 </span>            : mono_local_cprop (MonoCompile *cfg);
<span class="lineNum">    2956 </span>            : extern void
<span class="lineNum">    2957 </span>            : mono_local_deadce (MonoCompile *cfg);
<span class="lineNum">    2958 </span>            : void
<span class="lineNum">    2959 </span>            : mono_local_alias_analysis (MonoCompile *cfg);
<span class="lineNum">    2960 </span>            : 
<span class="lineNum">    2961 </span>            : /* Generic sharing */
<span class="lineNum">    2962 </span>            : 
<span class="lineNum">    2963 </span>            : void
<span class="lineNum">    2964 </span>            : mono_set_generic_sharing_supported (gboolean supported);
<span class="lineNum">    2965 </span>            : 
<span class="lineNum">    2966 </span>            : void
<span class="lineNum">    2967 </span>            : mono_set_generic_sharing_vt_supported (gboolean supported);
<span class="lineNum">    2968 </span>            : 
<span class="lineNum">    2969 </span>            : void
<span class="lineNum">    2970 </span>            : mono_set_partial_sharing_supported (gboolean supported);
<span class="lineNum">    2971 </span>            : 
<span class="lineNum">    2972 </span>            : gboolean
<span class="lineNum">    2973 </span>            : mono_class_generic_sharing_enabled (MonoClass *klass);
<span class="lineNum">    2974 </span>            : 
<span class="lineNum">    2975 </span>            : gpointer
<span class="lineNum">    2976 </span>            : mono_class_fill_runtime_generic_context (MonoVTable *class_vtable, guint32 slot, MonoError *error);
<span class="lineNum">    2977 </span>            : 
<span class="lineNum">    2978 </span>            : gpointer
<span class="lineNum">    2979 </span>            : mono_method_fill_runtime_generic_context (MonoMethodRuntimeGenericContext *mrgctx, guint32 slot, MonoError *error);
<span class="lineNum">    2980 </span>            : 
<span class="lineNum">    2981 </span>            : MonoMethodRuntimeGenericContext*
<span class="lineNum">    2982 </span>            : mono_method_lookup_rgctx (MonoVTable *class_vtable, MonoGenericInst *method_inst);
<span class="lineNum">    2983 </span>            : 
<span class="lineNum">    2984 </span>            : const char*
<span class="lineNum">    2985 </span>            : mono_rgctx_info_type_to_str (MonoRgctxInfoType type);
<span class="lineNum">    2986 </span>            : 
<span class="lineNum">    2987 </span>            : MonoJumpInfoType
<span class="lineNum">    2988 </span>            : mini_rgctx_info_type_to_patch_info_type (MonoRgctxInfoType info_type);
<span class="lineNum">    2989 </span>            : 
<span class="lineNum">    2990 </span>            : gboolean
<span class="lineNum">    2991 </span>            : mono_method_needs_static_rgctx_invoke (MonoMethod *method, gboolean allow_type_vars);
<span class="lineNum">    2992 </span>            : 
<span class="lineNum">    2993 </span>            : int
<span class="lineNum">    2994 </span>            : mono_class_rgctx_get_array_size (int n, gboolean mrgctx);
<span class="lineNum">    2995 </span>            : 
<span class="lineNum">    2996 </span>            : guint32
<span class="lineNum">    2997 </span>            : mono_method_lookup_or_register_info (MonoMethod *method, gboolean in_mrgctx, gpointer data,
<span class="lineNum">    2998 </span>            :         MonoRgctxInfoType info_type, MonoGenericContext *generic_context);
<span class="lineNum">    2999 </span>            : 
<span class="lineNum">    3000 </span>            : MonoGenericContext
<span class="lineNum">    3001 </span>            : mono_method_construct_object_context (MonoMethod *method);
<span class="lineNum">    3002 </span>            : 
<span class="lineNum">    3003 </span>            : MonoMethod*
<span class="lineNum">    3004 </span>            : mono_method_get_declaring_generic_method (MonoMethod *method);
<span class="lineNum">    3005 </span>            : 
<span class="lineNum">    3006 </span>            : int
<span class="lineNum">    3007 </span>            : mono_generic_context_check_used (MonoGenericContext *context);
<span class="lineNum">    3008 </span>            : 
<span class="lineNum">    3009 </span>            : int
<span class="lineNum">    3010 </span>            : mono_class_check_context_used (MonoClass *klass);
<span class="lineNum">    3011 </span>            : 
<span class="lineNum">    3012 </span>            : gboolean
<span class="lineNum">    3013 </span>            : mono_generic_context_is_sharable (MonoGenericContext *context, gboolean allow_type_vars);
<span class="lineNum">    3014 </span>            : 
<span class="lineNum">    3015 </span>            : gboolean
<span class="lineNum">    3016 </span>            : mono_generic_context_is_sharable_full (MonoGenericContext *context, gboolean allow_type_vars, gboolean allow_partial);
<span class="lineNum">    3017 </span>            : 
<span class="lineNum">    3018 </span>            : gboolean
<span class="lineNum">    3019 </span>            : mono_method_is_generic_impl (MonoMethod *method);
<span class="lineNum">    3020 </span>            : 
<span class="lineNum">    3021 </span>            : gboolean
<span class="lineNum">    3022 </span>            : mono_method_is_generic_sharable (MonoMethod *method, gboolean allow_type_vars);
<span class="lineNum">    3023 </span>            : 
<span class="lineNum">    3024 </span>            : gboolean
<span class="lineNum">    3025 </span>            : mono_method_is_generic_sharable_full (MonoMethod *method, gboolean allow_type_vars, gboolean allow_partial, gboolean allow_gsharedvt);
<span class="lineNum">    3026 </span>            : 
<span class="lineNum">    3027 </span>            : gboolean
<span class="lineNum">    3028 </span>            : mini_class_is_generic_sharable (MonoClass *klass);
<span class="lineNum">    3029 </span>            : 
<span class="lineNum">    3030 </span>            : 
<span class="lineNum">    3031 </span>            : gboolean
<span class="lineNum">    3032 </span>            : mini_generic_inst_is_sharable (MonoGenericInst *inst, gboolean allow_type_vars, gboolean allow_partial);
<span class="lineNum">    3033 </span>            : 
<span class="lineNum">    3034 </span>            : gboolean
<span class="lineNum">    3035 </span>            : mono_is_partially_sharable_inst (MonoGenericInst *inst);
<span class="lineNum">    3036 </span>            : 
<span class="lineNum">    3037 </span>            : gboolean
<span class="lineNum">    3038 </span>            : mini_is_gsharedvt_gparam (MonoType *t);
<span class="lineNum">    3039 </span>            : 
<span class="lineNum">    3040 </span>            : MonoGenericContext* mini_method_get_context (MonoMethod *method);
<span class="lineNum">    3041 </span>            : 
<span class="lineNum">    3042 </span>            : int mono_method_check_context_used (MonoMethod *method);
<span class="lineNum">    3043 </span>            : 
<span class="lineNum">    3044 </span>            : gboolean mono_generic_context_equal_deep (MonoGenericContext *context1, MonoGenericContext *context2);
<span class="lineNum">    3045 </span>            : 
<span class="lineNum">    3046 </span>            : gpointer mono_helper_get_rgctx_other_ptr (MonoClass *caller_class, MonoVTable *vtable,
<span class="lineNum">    3047 </span>            :                                           guint32 token, guint32 token_source, guint32 rgctx_type,
<span class="lineNum">    3048 </span>            :                                           gint32 rgctx_index);
<span class="lineNum">    3049 </span>            : 
<span class="lineNum">    3050 </span>            : void mono_generic_sharing_init (void);
<span class="lineNum">    3051 </span>            : void mono_generic_sharing_cleanup (void);
<span class="lineNum">    3052 </span>            : 
<span class="lineNum">    3053 </span>            : MonoClass* mini_class_get_container_class (MonoClass *klass);
<span class="lineNum">    3054 </span>            : MonoGenericContext* mini_class_get_context (MonoClass *klass);
<span class="lineNum">    3055 </span>            : 
<span class="lineNum">    3056 </span>            : MonoType* mini_get_underlying_type (MonoType *type) MONO_LLVM_INTERNAL;
<span class="lineNum">    3057 </span>            : MonoType* mini_type_get_underlying_type (MonoType *type);
<span class="lineNum">    3058 </span>            : MonoMethod* mini_get_shared_method (MonoMethod *method);
<span class="lineNum">    3059 </span>            : MonoMethod* mini_get_shared_method_to_register (MonoMethod *method);
<span class="lineNum">    3060 </span>            : MonoMethod* mini_get_shared_method_full (MonoMethod *method, gboolean all_vt, gboolean is_gsharedvt);
<span class="lineNum">    3061 </span>            : MonoType* mini_get_shared_gparam (MonoType *t, MonoType *constraint);
<span class="lineNum">    3062 </span>            : int mini_get_rgctx_entry_slot (MonoJumpInfoRgctxEntry *entry);
<span class="lineNum">    3063 </span>            : 
<span class="lineNum">    3064 </span>            : int mini_type_stack_size (MonoType *t, int *align);
<span class="lineNum">    3065 </span>            : int mini_type_stack_size_full (MonoType *t, guint32 *align, gboolean pinvoke);
<span class="lineNum">    3066 </span>            : void type_to_eval_stack_type (MonoCompile *cfg, MonoType *type, MonoInst *inst);
<span class="lineNum">    3067 </span>            : guint mono_type_to_regmove (MonoCompile *cfg, MonoType *type) MONO_LLVM_INTERNAL;
<span class="lineNum">    3068 </span>            : 
<span class="lineNum">    3069 </span>            : void mono_cfg_add_try_hole (MonoCompile *cfg, MonoExceptionClause *clause, guint8 *start, MonoBasicBlock *bb);
<span class="lineNum">    3070 </span>            : 
<span class="lineNum">    3071 </span>            : void mono_cfg_set_exception (MonoCompile *cfg, int type);
<span class="lineNum">    3072 </span>            : void mono_cfg_set_exception_invalid_program (MonoCompile *cfg, char *msg);
<span class="lineNum">    3073 </span>            : 
<span class="lineNum">    3074 </span>            : #define MONO_TIME_TRACK(a, phase) \
<span class="lineNum">    3075 </span>            :         { \
<span class="lineNum">    3076 </span>            :                 GTimer *timer = mono_time_track_start (); \
<span class="lineNum">    3077 </span>            :                 (phase) ; \
<span class="lineNum">    3078 </span>            :                 mono_time_track_end (&amp;(a), timer); \
<span class="lineNum">    3079 </span>            :         }
<span class="lineNum">    3080 </span>            : 
<span class="lineNum">    3081 </span>            : GTimer *mono_time_track_start (void);
<span class="lineNum">    3082 </span>            : void mono_time_track_end (double *time, GTimer *timer);
<span class="lineNum">    3083 </span>            : 
<span class="lineNum">    3084 </span>            : void mono_update_jit_stats (MonoCompile *cfg);
<span class="lineNum">    3085 </span>            : 
<span class="lineNum">    3086 </span>            : gboolean mini_type_is_reference (MonoType *type);
<span class="lineNum">    3087 </span>            : gboolean mini_type_is_vtype (MonoType *t) MONO_LLVM_INTERNAL;
<span class="lineNum">    3088 </span>            : gboolean mini_type_var_is_vt (MonoType *type) MONO_LLVM_INTERNAL;
<span class="lineNum">    3089 </span>            : gboolean mini_is_gsharedvt_type (MonoType *t);
<span class="lineNum">    3090 </span>            : gboolean mini_is_gsharedvt_klass (MonoClass *klass) MONO_LLVM_INTERNAL;
<span class="lineNum">    3091 </span>            : gboolean mini_is_gsharedvt_signature (MonoMethodSignature *sig);
<span class="lineNum">    3092 </span>            : gboolean mini_is_gsharedvt_variable_type (MonoType *t) MONO_LLVM_INTERNAL;
<span class="lineNum">    3093 </span>            : gboolean mini_is_gsharedvt_variable_klass (MonoClass *klass) MONO_LLVM_INTERNAL;
<span class="lineNum">    3094 </span>            : gboolean mini_is_gsharedvt_sharable_method (MonoMethod *method);
<span class="lineNum">    3095 </span>            : gboolean mini_is_gsharedvt_variable_signature (MonoMethodSignature *sig);
<span class="lineNum">    3096 </span>            : gboolean mini_is_gsharedvt_sharable_inst (MonoGenericInst *inst);
<span class="lineNum">    3097 </span>            : gpointer mini_method_get_rgctx (MonoMethod *m);
<span class="lineNum">    3098 </span>            : void mini_init_gsctx (MonoDomain *domain, MonoMemPool *mp, MonoGenericContext *context, MonoGenericSharingContext *gsctx);
<span class="lineNum">    3099 </span>            : 
<span class="lineNum">    3100 </span>            : gpointer mini_get_gsharedvt_wrapper (gboolean gsharedvt_in, gpointer addr, MonoMethodSignature *normal_sig, MonoMethodSignature *gsharedvt_sig,
<span class="lineNum">    3101 </span>            :                                                                          gint32 vcall_offset, gboolean calli);
<span class="lineNum">    3102 </span>            : MonoMethod* mini_get_gsharedvt_in_sig_wrapper (MonoMethodSignature *sig);
<span class="lineNum">    3103 </span>            : MonoMethod* mini_get_gsharedvt_out_sig_wrapper (MonoMethodSignature *sig);
<span class="lineNum">    3104 </span>            : MonoMethodSignature* mini_get_gsharedvt_out_sig_wrapper_signature (gboolean has_this, gboolean has_ret, int param_count);
<span class="lineNum">    3105 </span>            : gboolean mini_gsharedvt_runtime_invoke_supported (MonoMethodSignature *sig);
<span class="lineNum">    3106 </span>            : 
<span class="lineNum">    3107 </span>            : /* SIMD support */
<span class="lineNum">    3108 </span>            : 
<span class="lineNum">    3109 </span>            : /*
<span class="lineNum">    3110 </span>            : This enum MUST be kept in sync with its managed mirror Mono.Simd.AccelMode.
<span class="lineNum">    3111 </span>            :  */
<span class="lineNum">    3112 </span>            : enum {
<span class="lineNum">    3113 </span>            :         SIMD_VERSION_SSE1       = 1 &lt;&lt; 0,
<span class="lineNum">    3114 </span>            :         SIMD_VERSION_SSE2       = 1 &lt;&lt; 1,
<span class="lineNum">    3115 </span>            :         SIMD_VERSION_SSE3       = 1 &lt;&lt; 2,
<span class="lineNum">    3116 </span>            :         SIMD_VERSION_SSSE3      = 1 &lt;&lt; 3,
<span class="lineNum">    3117 </span>            :         SIMD_VERSION_SSE41      = 1 &lt;&lt; 4,
<span class="lineNum">    3118 </span>            :         SIMD_VERSION_SSE42      = 1 &lt;&lt; 5,
<span class="lineNum">    3119 </span>            :         SIMD_VERSION_SSE4a      = 1 &lt;&lt; 6,
<span class="lineNum">    3120 </span>            :         SIMD_VERSION_ALL        = SIMD_VERSION_SSE1 | SIMD_VERSION_SSE2 |
<span class="lineNum">    3121 </span>            :                           SIMD_VERSION_SSE3 | SIMD_VERSION_SSSE3 |
<span class="lineNum">    3122 </span>            :                           SIMD_VERSION_SSE41 | SIMD_VERSION_SSE42 |
<span class="lineNum">    3123 </span>            :                           SIMD_VERSION_SSE4a,
<span class="lineNum">    3124 </span>            : 
<span class="lineNum">    3125 </span>            :         /* this value marks the end of the bit indexes used in 
<span class="lineNum">    3126 </span>            :          * this emum.
<span class="lineNum">    3127 </span>            :          */
<span class="lineNum">    3128 </span>            :         SIMD_VERSION_INDEX_END = 6 
<span class="lineNum">    3129 </span>            : };
<span class="lineNum">    3130 </span>            : 
<span class="lineNum">    3131 </span>            : enum {
<span class="lineNum">    3132 </span>            :         SIMD_COMP_EQ,
<span class="lineNum">    3133 </span>            :         SIMD_COMP_LT,
<span class="lineNum">    3134 </span>            :         SIMD_COMP_LE,
<span class="lineNum">    3135 </span>            :         SIMD_COMP_UNORD,
<span class="lineNum">    3136 </span>            :         SIMD_COMP_NEQ,
<span class="lineNum">    3137 </span>            :         SIMD_COMP_NLT,
<span class="lineNum">    3138 </span>            :         SIMD_COMP_NLE,
<span class="lineNum">    3139 </span>            :         SIMD_COMP_ORD
<span class="lineNum">    3140 </span>            : };
<span class="lineNum">    3141 </span>            : 
<span class="lineNum">    3142 </span>            : enum {
<span class="lineNum">    3143 </span>            :         SIMD_PREFETCH_MODE_NTA,
<span class="lineNum">    3144 </span>            :         SIMD_PREFETCH_MODE_0,
<span class="lineNum">    3145 </span>            :         SIMD_PREFETCH_MODE_1,
<span class="lineNum">    3146 </span>            :         SIMD_PREFETCH_MODE_2,
<span class="lineNum">    3147 </span>            : };
<span class="lineNum">    3148 </span>            : 
<span class="lineNum">    3149 </span>            : const char *mono_arch_xregname (int reg);
<span class="lineNum">    3150 </span>            : void        mono_simd_simplify_indirection (MonoCompile *cfg);
<span class="lineNum">    3151 </span>            : MonoInst*   mono_emit_simd_intrinsics (MonoCompile *cfg, MonoMethod *cmethod, MonoMethodSignature *fsig, MonoInst **args);
<span class="lineNum">    3152 </span>            : MonoInst*   mono_emit_simd_field_load (MonoCompile *cfg, MonoClassField *field, MonoInst *addr);
<span class="lineNum">    3153 </span>            : guint32     mono_arch_cpu_enumerate_simd_versions (void);
<span class="lineNum">    3154 </span>            : void        mono_simd_intrinsics_init (void);
<span class="lineNum">    3155 </span>            : 
<span class="lineNum">    3156 </span>            : MonoInst*   mono_emit_native_types_intrinsics (MonoCompile *cfg, MonoMethod *cmethod, MonoMethodSignature *fsig, MonoInst **args);
<span class="lineNum">    3157 </span>            : MonoType*   mini_native_type_replace_type (MonoType *type) MONO_LLVM_INTERNAL;
<span class="lineNum">    3158 </span>            : 
<span class="lineNum">    3159 </span>            : #ifdef __linux__
<span class="lineNum">    3160 </span>            : #define XDEBUG_ENABLED 1
<span class="lineNum">    3161 </span>            : #endif
<span class="lineNum">    3162 </span>            : 
<span class="lineNum">    3163 </span>            : #ifdef __linux__
<span class="lineNum">    3164 </span>            : /* maybe enable also for other systems? */
<span class="lineNum">    3165 </span>            : #define ENABLE_JIT_MAP 1
<span class="lineNum">    3166 </span>            : void mono_enable_jit_map (void);
<span class="lineNum">    3167 </span>            : void mono_emit_jit_map   (MonoJitInfo *jinfo);
<span class="lineNum">    3168 </span>            : void mono_emit_jit_tramp (void *start, int size, const char *desc);
<span class="lineNum">    3169 </span>            : gboolean mono_jit_map_is_enabled (void);
<span class="lineNum">    3170 </span>            : #else
<span class="lineNum">    3171 </span>            : #define mono_enable_jit_map()
<span class="lineNum">    3172 </span>            : #define mono_emit_jit_map(ji)
<span class="lineNum">    3173 </span>            : #define mono_emit_jit_tramp(s,z,d)
<span class="lineNum">    3174 </span>            : #define mono_jit_map_is_enabled() (0)
<span class="lineNum">    3175 </span>            : #endif
<span class="lineNum">    3176 </span>            : 
<span class="lineNum">    3177 </span>            : /*
<span class="lineNum">    3178 </span>            :  * Per-OS implementation functions.
<span class="lineNum">    3179 </span>            :  */
<span class="lineNum">    3180 </span>            : void mono_runtime_install_handlers (void);
<span class="lineNum">    3181 </span>            : gboolean mono_runtime_install_custom_handlers (const char *handlers);
<span class="lineNum">    3182 </span>            : void mono_runtime_install_custom_handlers_usage (void);
<span class="lineNum">    3183 </span>            : void mono_runtime_cleanup_handlers (void);
<span class="lineNum">    3184 </span>            : void mono_runtime_setup_stat_profiler (void);
<span class="lineNum">    3185 </span>            : void mono_runtime_shutdown_stat_profiler (void);
<span class="lineNum">    3186 </span>            : void mono_runtime_posix_install_handlers (void);
<span class="lineNum">    3187 </span>            : void mono_gdb_render_native_backtraces (pid_t crashed_pid);
<span class="lineNum">    3188 </span>            : 
<span class="lineNum">    3189 </span>            : void mono_cross_helpers_run (void);
<span class="lineNum">    3190 </span>            : 
<span class="lineNum">    3191 </span>            : /*
<span class="lineNum">    3192 </span>            :  * Signal handling
<span class="lineNum">    3193 </span>            :  */
<span class="lineNum">    3194 </span>            : 
<span class="lineNum">    3195 </span>            : #if defined(DISABLE_HW_TRAPS) || defined(MONO_ARCH_DISABLE_HW_TRAPS)
<span class="lineNum">    3196 </span>            :  // Signal handlers not available
<span class="lineNum">    3197 </span>            : #define MONO_ARCH_NEED_DIV_CHECK 1
<span class="lineNum">    3198 </span>            : #endif
<span class="lineNum">    3199 </span>            : 
<span class="lineNum">    3200 </span>            : void MONO_SIG_HANDLER_SIGNATURE (mono_sigfpe_signal_handler) ;
<span class="lineNum">    3201 </span>            : void MONO_SIG_HANDLER_SIGNATURE (mono_sigill_signal_handler) ;
<span class="lineNum">    3202 </span>            : void MONO_SIG_HANDLER_SIGNATURE (mono_sigsegv_signal_handler);
<span class="lineNum">    3203 </span>            : void MONO_SIG_HANDLER_SIGNATURE (mono_sigint_signal_handler) ;
<span class="lineNum">    3204 </span>            : gboolean MONO_SIG_HANDLER_SIGNATURE (mono_chain_signal);
<span class="lineNum">    3205 </span>            : 
<span class="lineNum">    3206 </span>            : #ifdef MONO_ARCH_VARARG_ICALLS
<span class="lineNum">    3207 </span>            : #define ARCH_VARARG_ICALLS 1
<span class="lineNum">    3208 </span>            : #else
<span class="lineNum">    3209 </span>            : #define ARCH_VARARG_ICALLS 0
<span class="lineNum">    3210 </span>            : #endif
<span class="lineNum">    3211 </span>            : 
<span class="lineNum">    3212 </span>            : /*
<span class="lineNum">    3213 </span>            :  * Coop support for trampolines
<span class="lineNum">    3214 </span>            :  */
<span class="lineNum">    3215 </span>            : void mono_interruption_checkpoint_from_trampoline (void);
<span class="lineNum">    3216 </span>            : 
<span class="lineNum">    3217 </span>            : #endif /* __MONO_MINI_H__ */
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
