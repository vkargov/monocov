<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - mono.info - sgen/sgen-gchandles.c</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">sgen</a> - sgen-gchandles.c<span style="font-size: 80%;"> (source / <a href="sgen-gchandles.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">mono.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">131</td>
            <td class="headerCovTableEntry">176</td>
            <td class="headerCovTableEntryLo">74.4 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-01-18 17:24:17</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">19</td>
            <td class="headerCovTableEntry">23</td>
            <td class="headerCovTableEntryMed">82.6 %</td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :  * sgen-gchandles.c: SGen GC handles.
<span class="lineNum">       3 </span>            :  *
<span class="lineNum">       4 </span>            :  * Copyright (C) 2015 Xamarin Inc
<span class="lineNum">       5 </span>            :  *
<span class="lineNum">       6 </span>            :  * Licensed under the MIT license. See LICENSE file in the project root for full license information.
<span class="lineNum">       7 </span>            :  */
<span class="lineNum">       8 </span>            : 
<span class="lineNum">       9 </span>            : #include &quot;config.h&quot;
<span class="lineNum">      10 </span>            : #ifdef HAVE_SGEN_GC
<span class="lineNum">      11 </span>            : 
<span class="lineNum">      12 </span>            : #include &quot;mono/sgen/sgen-gc.h&quot;
<span class="lineNum">      13 </span>            : #include &quot;mono/sgen/sgen-client.h&quot;
<span class="lineNum">      14 </span>            : #include &quot;mono/sgen/sgen-array-list.h&quot;
<span class="lineNum">      15 </span>            : #include &quot;mono/utils/mono-membar.h&quot;
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            : #ifdef HEAVY_STATISTICS
<span class="lineNum">      18 </span>            : static volatile guint32 stat_gc_handles_allocated = 0;
<span class="lineNum">      19 </span>            : static volatile guint32 stat_gc_handles_max_allocated = 0;
<span class="lineNum">      20 </span>            : #endif
<span class="lineNum">      21 </span>            : 
<span class="lineNum">      22 </span>            : /*
<span class="lineNum">      23 </span>            :  * A table of GC handle data, implementing a simple lock-free bitmap allocator.
<span class="lineNum">      24 </span>            :  *
<span class="lineNum">      25 </span>            :  * Each entry in a bucket is a pointer with two tag bits: if
<span class="lineNum">      26 </span>            :  * 'GC_HANDLE_OCCUPIED' returns true for a slot, then the slot is occupied; if
<span class="lineNum">      27 </span>            :  * so, then 'GC_HANDLE_VALID' gives whether the entry refers to a valid (1) or
<span class="lineNum">      28 </span>            :  * NULL (0) object reference. If the reference is valid, then the pointer is an
<span class="lineNum">      29 </span>            :  * object pointer. If the reference is NULL, and 'GC_HANDLE_TYPE_IS_WEAK' is
<span class="lineNum">      30 </span>            :  * true for 'type', then the pointer is a metadata pointer--this allows us to
<span class="lineNum">      31 </span>            :  * retrieve the domain ID of an expired weak reference in Mono.
<span class="lineNum">      32 </span>            :  */
<span class="lineNum">      33 </span>            : 
<span class="lineNum">      34 </span>            : typedef struct {
<span class="lineNum">      35 </span>            :         SgenArrayList entries_array;
<span class="lineNum">      36 </span>            :         guint8 type;
<span class="lineNum">      37 </span>            : } HandleData;
<a name="38"><span class="lineNum">      38 </span>            : </a>
<span class="lineNum">      39 </span>            : static void
<span class="lineNum">      40 </span>            : protocol_gchandle_update (int handle_type, gpointer link, gpointer old_value, gpointer new_value)
<span class="lineNum">      41 </span>            : {
<span class="lineNum">      42 </span><span class="lineCov">   76551131 :         gboolean old = MONO_GC_HANDLE_IS_OBJECT_POINTER (old_value);</span>
<span class="lineNum">      43 </span><span class="lineCov">   76551131 :         gboolean new_ = MONO_GC_HANDLE_IS_OBJECT_POINTER (new_value);</span>
<span class="lineNum">      44 </span><span class="lineCov">   76551131 :         gboolean track = handle_type == HANDLE_WEAK_TRACK;</span>
<span class="lineNum">      45 </span>            : 
<span class="lineNum">      46 </span><span class="lineCov">   76551131 :         if (!MONO_GC_HANDLE_TYPE_IS_WEAK (handle_type))</span>
<span class="lineNum">      47 </span><span class="lineCov">       1284 :                 return;</span>
<span class="lineNum">      48 </span>            : 
<span class="lineNum">      49 </span><span class="lineCov">  141745514 :         if (!old &amp;&amp; new_)</span>
<span class="lineNum">      50 </span><span class="lineCov">    2469462 :                 binary_protocol_dislink_add (link, MONO_GC_REVEAL_POINTER (new_value, TRUE), track);</span>
<span class="lineNum">      51 </span><span class="lineCov">   85434622 :         else if (old &amp;&amp; !new_)</span>
<span class="lineNum">      52 </span><span class="lineCov">    2469395 :                 binary_protocol_dislink_remove (link, track);</span>
<span class="lineNum">      53 </span><span class="lineCov">   89380647 :         else if (old &amp;&amp; new_ &amp;&amp; old_value != new_value)</span>
<span class="lineNum">      54 </span><span class="lineCov">     528594 :                 binary_protocol_dislink_update (link, MONO_GC_REVEAL_POINTER (new_value, TRUE), track);</span>
<span class="lineNum">      55 </span><span class="lineCov">   76551126 : }</span>
<span class="lineNum">      56 </span>            : 
<a name="57"><span class="lineNum">      57 </span>            : /* Returns the new value in the slot, or NULL if the CAS failed. */</a>
<span class="lineNum">      58 </span>            : static inline gpointer
<span class="lineNum">      59 </span>            : try_set_slot (volatile gpointer *slot, GCObject *obj, gpointer old, GCHandleType type)
<span class="lineNum">      60 </span>            : {
<span class="lineNum">      61 </span>            :         gpointer new_;
<span class="lineNum">      62 </span><span class="lineCov">    2506884 :         if (obj)</span>
<span class="lineNum">      63 </span><span class="lineCov">    2472162 :                 new_ = MONO_GC_HANDLE_OBJECT_POINTER (obj, GC_HANDLE_TYPE_IS_WEAK (type));</span>
<span class="lineNum">      64 </span>            :         else
<span class="lineNum">      65 </span><span class="lineCov">      34740 :                 new_ = MONO_GC_HANDLE_METADATA_POINTER (sgen_client_default_metadata (), GC_HANDLE_TYPE_IS_WEAK (type));</span>
<span class="lineNum">      66 </span><span class="lineCov">    7520945 :         SGEN_ASSERT (0, new_, &quot;Why is the occupied bit not set?&quot;);</span>
<span class="lineNum">      67 </span><span class="lineCov">    2507233 :         if (InterlockedCompareExchangePointer (slot, new_, old) == old) {</span>
<span class="lineNum">      68 </span><span class="lineCov">    2504844 :                 protocol_gchandle_update (type, (gpointer)slot, old, new_);</span>
<span class="lineNum">      69 </span><span class="lineCov">    2504844 :                 return new_;</span>
<span class="lineNum">      70 </span>            :         }
<span class="lineNum">      71 </span><span class="lineCov">       2386 :         return NULL;</span>
<span class="lineNum">      72 </span><span class="lineCov">    2506639 : }</span>
<a name="73"><span class="lineNum">      73 </span>            : </a>
<span class="lineNum">      74 </span>            : static inline gboolean
<span class="lineNum">      75 </span>            : is_slot_set (volatile gpointer *slot)
<span class="lineNum">      76 </span>            : {
<span class="lineNum">      77 </span><span class="lineCov">   13749810 :         gpointer entry = *slot;</span>
<span class="lineNum">      78 </span><span class="lineCov">   13749810 :         if (MONO_GC_HANDLE_OCCUPIED (entry))</span>
<span class="lineNum">      79 </span><span class="lineCov">    9011907 :                 return TRUE;</span>
<span class="lineNum">      80 </span><span class="lineCov">    4946315 :         return FALSE;</span>
<span class="lineNum">      81 </span><span class="lineCov">   14098385 : }</span>
<span class="lineNum">      82 </span>            : 
<a name="83"><span class="lineNum">      83 </span>            : /* Try to claim a slot by setting its occupied bit. */</a>
<span class="lineNum">      84 </span>            : static inline gboolean
<span class="lineNum">      85 </span>            : try_occupy_slot (volatile gpointer *slot, gpointer obj, int data)
<span class="lineNum">      86 </span>            : {
<span class="lineNum">      87 </span><span class="lineCov">    2474356 :         if (is_slot_set (slot))</span>
<span class="lineNum">      88 </span><span class="lineCov">       1975 :                 return FALSE;</span>
<span class="lineNum">      89 </span><span class="lineCov">    2472354 :         return try_set_slot (slot, (GCObject *)obj, NULL, (GCHandleType)data) != NULL;</span>
<span class="lineNum">      90 </span><span class="lineCov">    2473495 : }</span>
<a name="91"><span class="lineNum">      91 </span>            : </a>
<span class="lineNum">      92 </span>            : static void
<span class="lineNum">      93 </span>            : bucket_alloc_callback (gpointer *bucket, guint32 new_bucket_size, gboolean alloc)
<span class="lineNum">      94 </span>            : {
<span class="lineNum">      95 </span><span class="lineCov">          6 :         if (alloc)</span>
<span class="lineNum">      96 </span><span class="lineCov">          6 :                 sgen_register_root ((char *)bucket, new_bucket_size, SGEN_DESCRIPTOR_NULL, ROOT_TYPE_PINNED, MONO_ROOT_SOURCE_GC_HANDLE, &quot;pinned gc handles&quot;);</span>
<span class="lineNum">      97 </span>            :         else
<span class="lineNum">      98 </span><span class="lineNoCov">          0 :                 sgen_deregister_root ((char *)bucket);</span>
<span class="lineNum">      99 </span><span class="lineCov">          6 : }</span>
<span class="lineNum">     100 </span>            : 
<span class="lineNum">     101 </span>            : static HandleData gc_handles [] = {
<span class="lineNum">     102 </span>            :         { SGEN_ARRAY_LIST_INIT (NULL, is_slot_set, try_occupy_slot, -1), (HANDLE_WEAK) },
<span class="lineNum">     103 </span>            :         { SGEN_ARRAY_LIST_INIT (NULL, is_slot_set, try_occupy_slot, -1), (HANDLE_WEAK_TRACK) },
<span class="lineNum">     104 </span>            :         { SGEN_ARRAY_LIST_INIT (NULL, is_slot_set, try_occupy_slot, -1), (HANDLE_NORMAL) },
<span class="lineNum">     105 </span>            :         { SGEN_ARRAY_LIST_INIT (bucket_alloc_callback, is_slot_set, try_occupy_slot, -1), (HANDLE_PINNED) }
<span class="lineNum">     106 </span>            : };
<a name="107"><span class="lineNum">     107 </span>            : </a>
<span class="lineNum">     108 </span>            : static HandleData *
<span class="lineNum">     109 </span>            : gc_handles_for_type (GCHandleType type)
<span class="lineNum">     110 </span>            : {
<span class="lineNum">     111 </span><span class="lineCov">   39483928 :         return type &lt; HANDLE_TYPE_MAX ? &amp;gc_handles [type] : NULL;</span>
<span class="lineNum">     112 </span>            : }
<span class="lineNum">     113 </span>            : 
<a name="114"><span class="lineNum">     114 </span>            : /* This assumes that the world is stopped. */</a>
<span class="lineNum">     115 </span>            : void
<span class="lineNum">     116 </span>            : sgen_mark_normal_gc_handles (void *addr, SgenUserMarkFunc mark_func, void *gc_data)
<span class="lineNum">     117 </span>            : {
<span class="lineNum">     118 </span><span class="lineCov">     189997 :         HandleData *handles = gc_handles_for_type (HANDLE_NORMAL);</span>
<span class="lineNum">     119 </span><span class="lineCov">     189997 :         SgenArrayList *array = &amp;handles-&gt;entries_array;</span>
<span class="lineNum">     120 </span>            :         volatile gpointer *slot;
<span class="lineNum">     121 </span>            :         gpointer hidden, revealed;
<span class="lineNum">     122 </span>            : 
<span class="lineNum">     123 </span><span class="lineCov">     424278 :         SGEN_ARRAY_LIST_FOREACH_SLOT (array, slot) {</span>
<span class="lineNum">     124 </span><span class="lineCov">       7870 :                 hidden = *slot;</span>
<span class="lineNum">     125 </span><span class="lineCov">       7870 :                 revealed = MONO_GC_REVEAL_POINTER (hidden, FALSE);</span>
<span class="lineNum">     126 </span><span class="lineCov">       7870 :                 if (!MONO_GC_HANDLE_IS_OBJECT_POINTER (hidden))</span>
<span class="lineNum">     127 </span><span class="lineCov">        744 :                         continue;</span>
<span class="lineNum">     128 </span><span class="lineCov">       7126 :                 mark_func ((MonoObject **)&amp;revealed, gc_data);</span>
<span class="lineNum">     129 </span><span class="lineCov">      21378 :                 g_assert (revealed);</span>
<span class="lineNum">     130 </span><span class="lineCov">       7126 :                 *slot = MONO_GC_HANDLE_OBJECT_POINTER (revealed, FALSE);</span>
<span class="lineNum">     131 </span><span class="lineCov">       9260 :         } SGEN_ARRAY_LIST_END_FOREACH_SLOT;</span>
<span class="lineNum">     132 </span><span class="lineCov">     189997 : }</span>
<span class="lineNum">     133 </span>            : 
<a name="134"><span class="lineNum">     134 </span>            : </a>
<span class="lineNum">     135 </span>            : static guint32
<span class="lineNum">     136 </span>            : alloc_handle (HandleData *handles, GCObject *obj, gboolean track)
<span class="lineNum">     137 </span>            : {
<span class="lineNum">     138 </span>            :         guint32 res, index;
<span class="lineNum">     139 </span><span class="lineCov">    2469560 :         SgenArrayList *array = &amp;handles-&gt;entries_array;</span>
<span class="lineNum">     140 </span>            : 
<span class="lineNum">     141 </span>            :         /*
<span class="lineNum">     142 </span>            :          * If a GC happens shortly after a new bucket is allocated, the entire
<span class="lineNum">     143 </span>            :          * bucket could be scanned even though it's mostly empty. To avoid this,
<span class="lineNum">     144 </span>            :          * we track the maximum index seen so far, so that we can skip the empty
<span class="lineNum">     145 </span>            :          * slots.
<span class="lineNum">     146 </span>            :          *
<span class="lineNum">     147 </span>            :          * Note that we update `next_slot` before we even try occupying the
<span class="lineNum">     148 </span>            :          * slot.  If we did it the other way around and a GC happened in
<span class="lineNum">     149 </span>            :          * between, the GC wouldn't know that the slot was occupied.  This is
<span class="lineNum">     150 </span>            :          * not a huge deal since `obj` is on the stack and thus pinned anyway,
<span class="lineNum">     151 </span>            :          * but hopefully some day it won't be anymore.
<span class="lineNum">     152 </span>            :          */
<span class="lineNum">     153 </span><span class="lineCov">    2469560 :         index = sgen_array_list_add (array, obj, handles-&gt;type, TRUE);</span>
<span class="lineNum">     154 </span>            : #ifdef HEAVY_STATISTICS
<span class="lineNum">     155 </span>            :         InterlockedIncrement ((volatile gint32 *)&amp;stat_gc_handles_allocated);
<span class="lineNum">     156 </span>            :         if (stat_gc_handles_allocated &gt; stat_gc_handles_max_allocated)
<span class="lineNum">     157 </span>            :                 stat_gc_handles_max_allocated = stat_gc_handles_allocated;
<span class="lineNum">     158 </span>            : #endif
<span class="lineNum">     159 </span>            :         /* Ensure that a GC handle cannot be given to another thread without the slot having been set. */
<span class="lineNum">     160 </span><span class="lineCov">    2469560 :         mono_memory_write_barrier ();</span>
<span class="lineNum">     161 </span><span class="lineCov">    2469560 :         res = MONO_GC_HANDLE (index, handles-&gt;type);</span>
<span class="lineNum">     162 </span><span class="lineCov">    2469560 :         sgen_client_gchandle_created (handles-&gt;type, obj, res);</span>
<span class="lineNum">     163 </span><span class="lineCov">    2469560 :         return res;</span>
<span class="lineNum">     164 </span>            : }
<a name="165"><span class="lineNum">     165 </span>            : </a>
<span class="lineNum">     166 </span>            : static gboolean
<span class="lineNum">     167 </span>            : object_older_than (GCObject *object, int generation)
<span class="lineNum">     168 </span>            : {
<span class="lineNum">     169 </span><span class="lineCov">   32290157 :         return generation == GENERATION_NURSERY &amp;&amp; !sgen_ptr_in_nursery (object);</span>
<span class="lineNum">     170 </span>            : }
<span class="lineNum">     171 </span>            : 
<span class="lineNum">     172 </span>            : /*
<span class="lineNum">     173 </span>            :  * Maps a function over all GC handles.
<span class="lineNum">     174 </span>            :  * This assumes that the world is stopped!
<a name="175"><span class="lineNum">     175 </span>            :  */</a>
<span class="lineNum">     176 </span>            : void
<span class="lineNum">     177 </span>            : sgen_gchandle_iterate (GCHandleType handle_type, int max_generation, SgenGCHandleIterateCallback callback, gpointer user)
<span class="lineNum">     178 </span>            : {
<span class="lineNum">     179 </span><span class="lineCov">     752912 :         HandleData *handle_data = gc_handles_for_type (handle_type);</span>
<span class="lineNum">     180 </span><span class="lineCov">     752912 :         SgenArrayList *array = &amp;handle_data-&gt;entries_array;</span>
<span class="lineNum">     181 </span>            :         gpointer hidden, result, occupied;
<span class="lineNum">     182 </span>            :         volatile gpointer *slot;
<span class="lineNum">     183 </span>            : 
<span class="lineNum">     184 </span>            :         /* If a new bucket has been allocated, but the capacity has not yet been
<span class="lineNum">     185 </span>            :          * increased, nothing can yet have been allocated in the bucket because the
<span class="lineNum">     186 </span>            :          * world is stopped, so we shouldn't miss any handles during iteration.
<span class="lineNum">     187 </span>            :          */
<span class="lineNum">     188 </span><span class="lineCov">  304393060 :         SGEN_ARRAY_LIST_FOREACH_SLOT (array, slot) {</span>
<span class="lineNum">     189 </span><span class="lineCov">   74542492 :                 hidden = *slot;</span>
<span class="lineNum">     190 </span><span class="lineCov">   74542492 :                 occupied = (gpointer) MONO_GC_HANDLE_OCCUPIED (hidden);</span>
<span class="lineNum">     191 </span><span class="lineCov">  372712460 :                 g_assert (hidden ? !!occupied : !occupied);</span>
<span class="lineNum">     192 </span><span class="lineCov">   74542492 :                 if (!occupied)</span>
<span class="lineNum">     193 </span><span class="lineCov">    2276704 :                         continue;</span>
<span class="lineNum">     194 </span><span class="lineCov">   72265788 :                 result = callback (hidden, handle_type, max_generation, user);</span>
<span class="lineNum">     195 </span><span class="lineCov">   72265788 :                 if (result)</span>
<span class="lineNum">     196 </span><span class="lineCov">  286304968 :                         SGEN_ASSERT (0, MONO_GC_HANDLE_OCCUPIED (result), &quot;Why did the callback return an unoccupied entry?&quot;);</span>
<span class="lineNum">     197 </span>            :                 else
<span class="lineNum">     198 </span>            :                         HEAVY_STAT (InterlockedDecrement ((volatile gint32 *)&amp;stat_gc_handles_allocated));
<span class="lineNum">     199 </span><span class="lineCov">   72265788 :                 protocol_gchandle_update (handle_type, (gpointer)slot, hidden, result);</span>
<span class="lineNum">     200 </span><span class="lineCov">   72265788 :                 *slot = result;</span>
<span class="lineNum">     201 </span><span class="lineCov">   73074876 :         } SGEN_ARRAY_LIST_END_FOREACH_SLOT;</span>
<span class="lineNum">     202 </span><span class="lineCov">     752912 : }</span>
<span class="lineNum">     203 </span>            : 
<span class="lineNum">     204 </span>            : /**
<span class="lineNum">     205 </span>            :  * mono_gchandle_new:
<span class="lineNum">     206 </span>            :  * @obj: managed object to get a handle for
<span class="lineNum">     207 </span>            :  * @pinned: whether the object should be pinned
<span class="lineNum">     208 </span>            :  *
<span class="lineNum">     209 </span>            :  * This returns a handle that wraps the object, this is used to keep a
<span class="lineNum">     210 </span>            :  * reference to a managed object from the unmanaged world and preventing the
<span class="lineNum">     211 </span>            :  * object from being disposed.
<span class="lineNum">     212 </span>            :  * 
<span class="lineNum">     213 </span>            :  * If @pinned is false the address of the object can not be obtained, if it is
<span class="lineNum">     214 </span>            :  * true the address of the object can be obtained.  This will also pin the
<span class="lineNum">     215 </span>            :  * object so it will not be possible by a moving garbage collector to move the
<span class="lineNum">     216 </span>            :  * object. 
<span class="lineNum">     217 </span>            :  * 
<span class="lineNum">     218 </span>            :  * Returns: a handle that can be used to access the object from
<span class="lineNum">     219 </span>            :  * unmanaged code.
<a name="220"><span class="lineNum">     220 </span>            :  */</a>
<span class="lineNum">     221 </span>            : guint32
<span class="lineNum">     222 </span>            : mono_gchandle_new (GCObject *obj, gboolean pinned)
<span class="lineNum">     223 </span>            : {
<span class="lineNum">     224 </span><span class="lineCov">        642 :         return alloc_handle (gc_handles_for_type (pinned ? HANDLE_PINNED : HANDLE_NORMAL), obj, FALSE);</span>
<span class="lineNum">     225 </span>            : }
<span class="lineNum">     226 </span>            : 
<span class="lineNum">     227 </span>            : /**
<span class="lineNum">     228 </span>            :  * mono_gchandle_new_weakref:
<span class="lineNum">     229 </span>            :  * @obj: managed object to get a handle for
<span class="lineNum">     230 </span>            :  * @track_resurrection: Determines how long to track the object, if this is set to TRUE, the object is tracked after finalization, if FALSE, the object is only tracked up until the point of finalization.
<span class="lineNum">     231 </span>            :  *
<span class="lineNum">     232 </span>            :  * This returns a weak handle that wraps the object, this is used to
<span class="lineNum">     233 </span>            :  * keep a reference to a managed object from the unmanaged world.
<span class="lineNum">     234 </span>            :  * Unlike the mono_gchandle_new the object can be reclaimed by the
<span class="lineNum">     235 </span>            :  * garbage collector.  In this case the value of the GCHandle will be
<span class="lineNum">     236 </span>            :  * set to zero.
<span class="lineNum">     237 </span>            :  * 
<span class="lineNum">     238 </span>            :  * If @track_resurrection is TRUE the object will be tracked through
<span class="lineNum">     239 </span>            :  * finalization and if the object is resurrected during the execution
<span class="lineNum">     240 </span>            :  * of the finalizer, then the returned weakref will continue to hold
<span class="lineNum">     241 </span>            :  * a reference to the object.   If @track_resurrection is FALSE, then
<span class="lineNum">     242 </span>            :  * the weak reference's target will become NULL as soon as the object
<span class="lineNum">     243 </span>            :  * is passed on to the finalizer.
<span class="lineNum">     244 </span>            :  * 
<span class="lineNum">     245 </span>            :  * Returns: a handle that can be used to access the object from
<span class="lineNum">     246 </span>            :  * unmanaged code.
<a name="247"><span class="lineNum">     247 </span>            :  */</a>
<span class="lineNum">     248 </span>            : guint32
<span class="lineNum">     249 </span>            : mono_gchandle_new_weakref (GCObject *obj, gboolean track_resurrection)
<span class="lineNum">     250 </span>            : {
<span class="lineNum">     251 </span><span class="lineCov">    2468959 :         return alloc_handle (gc_handles_for_type (track_resurrection ? HANDLE_WEAK_TRACK : HANDLE_WEAK), obj, track_resurrection);</span>
<span class="lineNum">     252 </span>            : }
<a name="253"><span class="lineNum">     253 </span>            : </a>
<span class="lineNum">     254 </span>            : static GCObject *
<span class="lineNum">     255 </span>            : link_get (volatile gpointer *link_addr, gboolean is_weak)
<span class="lineNum">     256 </span>            : {
<span class="lineNum">     257 </span>            :         void *volatile *link_addr_volatile;
<span class="lineNum">     258 </span>            :         void *ptr;
<span class="lineNum">     259 </span><span class="lineCov">    7937847 :         GCObject *obj;</span>
<span class="lineNum">     260 </span>            : retry:
<span class="lineNum">     261 </span><span class="lineCov">    7939235 :         link_addr_volatile = link_addr;</span>
<span class="lineNum">     262 </span><span class="lineCov">    7939235 :         ptr = (void*)*link_addr_volatile;</span>
<span class="lineNum">     263 </span>            :         /*
<span class="lineNum">     264 </span>            :          * At this point we have a hidden pointer.  If the GC runs
<span class="lineNum">     265 </span>            :          * here, it will not recognize the hidden pointer as a
<span class="lineNum">     266 </span>            :          * reference, and if the object behind it is not referenced
<span class="lineNum">     267 </span>            :          * elsewhere, it will be freed.  Once the world is restarted
<span class="lineNum">     268 </span>            :          * we reveal the pointer, giving us a pointer to a freed
<span class="lineNum">     269 </span>            :          * object.  To make sure we don't return it, we load the
<span class="lineNum">     270 </span>            :          * hidden pointer again.  If it's still the same, we can be
<span class="lineNum">     271 </span>            :          * sure the object reference is valid.
<span class="lineNum">     272 </span>            :          */
<span class="lineNum">     273 </span><span class="lineCov">   15879485 :         if (ptr &amp;&amp; MONO_GC_HANDLE_IS_OBJECT_POINTER (ptr))</span>
<span class="lineNum">     274 </span><span class="lineCov">    7591804 :                 obj = (GCObject *)MONO_GC_REVEAL_POINTER (ptr, is_weak);</span>
<span class="lineNum">     275 </span>            :         else
<span class="lineNum">     276 </span><span class="lineCov">     348715 :                 return NULL;</span>
<span class="lineNum">     277 </span>            : 
<span class="lineNum">     278 </span>            :         /* Note [dummy use]:
<span class="lineNum">     279 </span>            :          *
<span class="lineNum">     280 </span>            :          * If a GC happens here, obj needs to be on the stack or in a
<span class="lineNum">     281 </span>            :          * register, so we need to prevent this from being reordered
<span class="lineNum">     282 </span>            :          * wrt the check.
<span class="lineNum">     283 </span>            :          */
<span class="lineNum">     284 </span><span class="lineCov">    7592287 :         sgen_dummy_use (obj);</span>
<span class="lineNum">     285 </span><span class="lineCov">    7592287 :         mono_memory_barrier ();</span>
<span class="lineNum">     286 </span>            : 
<span class="lineNum">     287 </span><span class="lineCov">    7592287 :         if (is_weak)</span>
<span class="lineNum">     288 </span><span class="lineCov">    7591030 :                 sgen_client_ensure_weak_gchandles_accessible ();</span>
<span class="lineNum">     289 </span>            : 
<span class="lineNum">     290 </span><span class="lineCov">    7590121 :         if ((void*)*link_addr_volatile != ptr)</span>
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :                 goto retry;</span>
<span class="lineNum">     292 </span>            : 
<span class="lineNum">     293 </span><span class="lineCov">    7590420 :         return obj;</span>
<span class="lineNum">     294 </span><span class="lineCov">    7939340 : }</span>
<span class="lineNum">     295 </span>            : 
<span class="lineNum">     296 </span>            : /**
<span class="lineNum">     297 </span>            :  * mono_gchandle_get_target:
<span class="lineNum">     298 </span>            :  * @gchandle: a GCHandle's handle.
<span class="lineNum">     299 </span>            :  *
<span class="lineNum">     300 </span>            :  * The handle was previously created by calling `mono_gchandle_new` or
<span class="lineNum">     301 </span>            :  * `mono_gchandle_new_weakref`. 
<span class="lineNum">     302 </span>            :  *
<span class="lineNum">     303 </span>            :  * Returns a pointer to the `MonoObject*` represented by the handle or
<span class="lineNum">     304 </span>            :  * NULL for a collected object if using a weakref handle.
<a name="305"><span class="lineNum">     305 </span>            :  */</a>
<span class="lineNum">     306 </span>            : GCObject*
<span class="lineNum">     307 </span>            : mono_gchandle_get_target (guint32 gchandle)
<span class="lineNum">     308 </span>            : {
<span class="lineNum">     309 </span><span class="lineCov">    7933909 :         guint index = MONO_GC_HANDLE_SLOT (gchandle);</span>
<span class="lineNum">     310 </span><span class="lineCov">    7933909 :         GCHandleType type = MONO_GC_HANDLE_TYPE (gchandle);</span>
<span class="lineNum">     311 </span><span class="lineCov">    7933909 :         HandleData *handles = gc_handles_for_type (type);</span>
<span class="lineNum">     312 </span>            :         /* Invalid handles are possible; accessing one should produce NULL. (#34276) */
<span class="lineNum">     313 </span><span class="lineCov">    7933909 :         if (!handles)</span>
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">     315 </span><span class="lineCov">    7933828 :         return link_get (sgen_array_list_get_slot (&amp;handles-&gt;entries_array, index), MONO_GC_HANDLE_TYPE_IS_WEAK (type));</span>
<span class="lineNum">     316 </span><span class="lineCov">    7939344 : }</span>
<a name="317"><span class="lineNum">     317 </span>            : </a>
<span class="lineNum">     318 </span>            : void
<span class="lineNum">     319 </span>            : sgen_gchandle_set_target (guint32 gchandle, GCObject *obj)
<span class="lineNum">     320 </span>            : {
<span class="lineNum">     321 </span><span class="lineCov">      34689 :         guint32 index = MONO_GC_HANDLE_SLOT (gchandle);</span>
<span class="lineNum">     322 </span><span class="lineCov">      34689 :         GCHandleType type = MONO_GC_HANDLE_TYPE (gchandle);</span>
<span class="lineNum">     323 </span><span class="lineCov">      34689 :         HandleData *handles = gc_handles_for_type (type);</span>
<span class="lineNum">     324 </span>            :         volatile gpointer *slot;
<span class="lineNum">     325 </span>            :         gpointer entry;
<span class="lineNum">     326 </span>            : 
<span class="lineNum">     327 </span><span class="lineCov">      34689 :         if (!handles)</span>
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">     329 </span>            : 
<span class="lineNum">     330 </span><span class="lineCov">      34689 :         slot = sgen_array_list_get_slot (&amp;handles-&gt;entries_array, index);</span>
<span class="lineNum">     331 </span>            : 
<span class="lineNum">     332 </span><span class="lineCov">      34689 :         do {</span>
<span class="lineNum">     333 </span><span class="lineCov">      34689 :                 entry = *slot;</span>
<span class="lineNum">     334 </span><span class="lineCov">     104067 :                 SGEN_ASSERT (0, MONO_GC_HANDLE_OCCUPIED (entry), &quot;Why are we setting the target on an unoccupied slot?&quot;);</span>
<span class="lineNum">     335 </span><span class="lineCov">      69378 :         } while (!try_set_slot (slot, obj, entry, (GCHandleType)handles-&gt;type));</span>
<span class="lineNum">     336 </span><span class="lineCov">      34689 : }</span>
<a name="337"><span class="lineNum">     337 </span>            : </a>
<span class="lineNum">     338 </span>            : static gpointer
<span class="lineNum">     339 </span>            : mono_gchandle_slot_metadata (volatile gpointer *slot, gboolean is_weak)
<span class="lineNum">     340 </span>            : {
<span class="lineNum">     341 </span>            :         gpointer entry;
<span class="lineNum">     342 </span><span class="lineNoCov">          0 :         gpointer metadata;</span>
<span class="lineNum">     343 </span>            : retry:
<span class="lineNum">     344 </span><span class="lineNoCov">          0 :         entry = *slot;</span>
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :         if (!MONO_GC_HANDLE_OCCUPIED (entry))</span>
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :         if (MONO_GC_HANDLE_IS_OBJECT_POINTER (entry)) {</span>
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :                 GCObject *obj = (GCObject *)MONO_GC_REVEAL_POINTER (entry, is_weak);</span>
<span class="lineNum">     349 </span>            :                 /* See note [dummy use]. */
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :                 sgen_dummy_use (obj);</span>
<span class="lineNum">     351 </span>            :                 /*
<span class="lineNum">     352 </span>            :                  * FIXME: The compiler could technically not carry a reference to obj around
<span class="lineNum">     353 </span>            :                  * at this point and recompute it later, in which case we would still use
<span class="lineNum">     354 </span>            :                  * it.
<span class="lineNum">     355 </span>            :                  */
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :                 if (*slot != entry)</span>
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :                         goto retry;</span>
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :                 return sgen_client_metadata_for_object (obj);</span>
<span class="lineNum">     359 </span>            :         }
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :         metadata = MONO_GC_REVEAL_POINTER (entry, is_weak);</span>
<span class="lineNum">     361 </span>            :         /* See note [dummy use]. */
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :         sgen_dummy_use (metadata);</span>
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :         if (*slot != entry)</span>
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :                 goto retry;</span>
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :         return metadata;</span>
<span class="lineNum">     366 </span><span class="lineNoCov">          0 : }</span>
<a name="367"><span class="lineNum">     367 </span>            : </a>
<span class="lineNum">     368 </span>            : gpointer
<span class="lineNum">     369 </span>            : sgen_gchandle_get_metadata (guint32 gchandle)
<span class="lineNum">     370 </span>            : {
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :         guint32 index = MONO_GC_HANDLE_SLOT (gchandle);</span>
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :         GCHandleType type = MONO_GC_HANDLE_TYPE (gchandle);</span>
<span class="lineNum">     373 </span><span class="lineNoCov">          0 :         HandleData *handles = gc_handles_for_type (type);</span>
<span class="lineNum">     374 </span>            :         volatile gpointer *slot;
<span class="lineNum">     375 </span>            : 
<span class="lineNum">     376 </span><span class="lineNoCov">          0 :         if (!handles)</span>
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :         if (index &gt;= handles-&gt;entries_array.capacity)</span>
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">     380 </span>            : 
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :         slot = sgen_array_list_get_slot (&amp;handles-&gt;entries_array, index);</span>
<span class="lineNum">     382 </span>            : 
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :         return mono_gchandle_slot_metadata (slot, MONO_GC_HANDLE_TYPE_IS_WEAK (type));</span>
<span class="lineNum">     384 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     385 </span>            : 
<span class="lineNum">     386 </span>            : /**
<span class="lineNum">     387 </span>            :  * mono_gchandle_free:
<span class="lineNum">     388 </span>            :  * @gchandle: a GCHandle's handle.
<span class="lineNum">     389 </span>            :  *
<span class="lineNum">     390 </span>            :  * Frees the @gchandle handle.  If there are no outstanding
<span class="lineNum">     391 </span>            :  * references, the garbage collector can reclaim the memory of the
<span class="lineNum">     392 </span>            :  * object wrapped. 
<a name="393"><span class="lineNum">     393 </span>            :  */</a>
<span class="lineNum">     394 </span>            : void
<span class="lineNum">     395 </span>            : mono_gchandle_free (guint32 gchandle)
<span class="lineNum">     396 </span>            : {
<span class="lineNum">     397 </span><span class="lineCov">    1782590 :         guint32 index = MONO_GC_HANDLE_SLOT (gchandle);</span>
<span class="lineNum">     398 </span><span class="lineCov">    1782590 :         GCHandleType type = MONO_GC_HANDLE_TYPE (gchandle);</span>
<span class="lineNum">     399 </span><span class="lineCov">    1782590 :         HandleData *handles = gc_handles_for_type (type);</span>
<span class="lineNum">     400 </span>            :         volatile gpointer *slot;
<span class="lineNum">     401 </span>            :         gpointer entry;
<span class="lineNum">     402 </span><span class="lineCov">    1782590 :         if (!handles)</span>
<span class="lineNum">     403 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">     404 </span>            : 
<span class="lineNum">     405 </span><span class="lineCov">    1782590 :         slot = sgen_array_list_get_slot (&amp;handles-&gt;entries_array, index);</span>
<span class="lineNum">     406 </span><span class="lineCov">    1782590 :         entry = *slot;</span>
<span class="lineNum">     407 </span>            : 
<span class="lineNum">     408 </span><span class="lineCov">    3565180 :         if (index &lt; handles-&gt;entries_array.capacity &amp;&amp; MONO_GC_HANDLE_OCCUPIED (entry)) {</span>
<span class="lineNum">     409 </span><span class="lineCov">    1780528 :                 *slot = NULL;</span>
<span class="lineNum">     410 </span><span class="lineCov">    1780528 :                 protocol_gchandle_update (handles-&gt;type, (gpointer)slot, entry, NULL);</span>
<span class="lineNum">     411 </span>            :                 HEAVY_STAT (InterlockedDecrement ((volatile gint32 *)&amp;stat_gc_handles_allocated));
<span class="lineNum">     412 </span><span class="lineCov">    1780528 :         } else {</span>
<span class="lineNum">     413 </span>            :                 /* print a warning? */
<span class="lineNum">     414 </span>            :         }
<span class="lineNum">     415 </span><span class="lineCov">    1782590 :         sgen_client_gchandle_destroyed (handles-&gt;type, gchandle);</span>
<span class="lineNum">     416 </span><span class="lineCov">    3565179 : }</span>
<span class="lineNum">     417 </span>            : 
<span class="lineNum">     418 </span>            : /*
<span class="lineNum">     419 </span>            :  * Returns whether to remove the link from its hash.
<a name="420"><span class="lineNum">     420 </span>            :  */</a>
<span class="lineNum">     421 </span>            : static gpointer
<span class="lineNum">     422 </span>            : null_link_if_necessary (gpointer hidden, GCHandleType handle_type, int max_generation, gpointer user)
<span class="lineNum">     423 </span>            : {
<span class="lineNum">     424 </span><span class="lineCov">   71572251 :         const gboolean is_weak = GC_HANDLE_TYPE_IS_WEAK (handle_type);</span>
<span class="lineNum">     425 </span><span class="lineCov">   71572251 :         ScanCopyContext *ctx = (ScanCopyContext *)user;</span>
<span class="lineNum">     426 </span>            :         GCObject *obj;
<span class="lineNum">     427 </span>            :         GCObject *copy;
<span class="lineNum">     428 </span>            : 
<span class="lineNum">     429 </span><span class="lineCov">   71572251 :         if (!MONO_GC_HANDLE_VALID (hidden))</span>
<span class="lineNum">     430 </span><span class="lineCov">   60320094 :                 return hidden;</span>
<span class="lineNum">     431 </span>            : 
<span class="lineNum">     432 </span><span class="lineCov">   11252157 :         obj = (GCObject *)MONO_GC_REVEAL_POINTER (hidden, MONO_GC_HANDLE_TYPE_IS_WEAK (handle_type));</span>
<span class="lineNum">     433 </span><span class="lineCov">   33756471 :         SGEN_ASSERT (0, obj, &quot;Why is the hidden pointer NULL?&quot;);</span>
<span class="lineNum">     434 </span>            : 
<span class="lineNum">     435 </span><span class="lineCov">   11252157 :         if (object_older_than (obj, max_generation))</span>
<span class="lineNum">     436 </span><span class="lineCov">    7702491 :                 return hidden;</span>
<span class="lineNum">     437 </span>            : 
<span class="lineNum">     438 </span><span class="lineCov">    3549666 :         if (major_collector.is_object_live (obj))</span>
<span class="lineNum">     439 </span><span class="lineCov">     584641 :                 return hidden;</span>
<span class="lineNum">     440 </span>            : 
<span class="lineNum">     441 </span>            :         /* Clear link if object is ready for finalization. This check may be redundant wrt is_object_live(). */
<span class="lineNum">     442 </span><span class="lineCov">    2965025 :         if (sgen_gc_is_object_ready_for_finalization (obj))</span>
<span class="lineNum">     443 </span><span class="lineCov">    2370998 :                 return MONO_GC_HANDLE_METADATA_POINTER (sgen_client_metadata_for_object (obj), is_weak);</span>
<span class="lineNum">     444 </span>            : 
<span class="lineNum">     445 </span><span class="lineCov">     594027 :         copy = obj;</span>
<span class="lineNum">     446 </span><span class="lineCov">     594027 :         ctx-&gt;ops-&gt;copy_or_mark_object (&amp;copy, ctx-&gt;queue);</span>
<span class="lineNum">     447 </span><span class="lineCov">    1782081 :         SGEN_ASSERT (0, copy, &quot;Why couldn't we copy the object?&quot;);</span>
<span class="lineNum">     448 </span>            :         /* Update link if object was moved. */
<span class="lineNum">     449 </span><span class="lineCov">     594027 :         return MONO_GC_HANDLE_OBJECT_POINTER (copy, is_weak);</span>
<span class="lineNum">     450 </span><span class="lineCov">   71572251 : }</span>
<span class="lineNum">     451 </span>            : 
<a name="452"><span class="lineNum">     452 </span>            : /* LOCKING: requires that the GC lock is held */</a>
<span class="lineNum">     453 </span>            : void
<span class="lineNum">     454 </span>            : sgen_null_link_in_range (int generation, ScanCopyContext ctx, gboolean track)
<span class="lineNum">     455 </span>            : {
<span class="lineNum">     456 </span><span class="lineCov">     738972 :         sgen_gchandle_iterate (track ? HANDLE_WEAK_TRACK : HANDLE_WEAK, generation, null_link_if_necessary, &amp;ctx);</span>
<span class="lineNum">     457 </span><span class="lineCov">     738972 : }</span>
<span class="lineNum">     458 </span>            : 
<span class="lineNum">     459 </span>            : typedef struct {
<span class="lineNum">     460 </span>            :         SgenObjectPredicateFunc predicate;
<span class="lineNum">     461 </span>            :         gpointer data;
<span class="lineNum">     462 </span>            : } WeakLinkAlivePredicateClosure;
<a name="463"><span class="lineNum">     463 </span>            : </a>
<span class="lineNum">     464 </span>            : static gpointer
<span class="lineNum">     465 </span>            : null_link_if (gpointer hidden, GCHandleType handle_type, int max_generation, gpointer user)
<span class="lineNum">     466 </span>            : {
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :         WeakLinkAlivePredicateClosure *closure = (WeakLinkAlivePredicateClosure *)user;</span>
<span class="lineNum">     468 </span>            :         GCObject *obj;
<span class="lineNum">     469 </span>            : 
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :         if (!MONO_GC_HANDLE_VALID (hidden))</span>
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :                 return hidden;</span>
<span class="lineNum">     472 </span>            : 
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :         obj = (GCObject *)MONO_GC_REVEAL_POINTER (hidden, MONO_GC_HANDLE_TYPE_IS_WEAK (handle_type));</span>
<span class="lineNum">     474 </span><span class="lineNoCov">          0 :         SGEN_ASSERT (0, obj, &quot;Why is the hidden pointer NULL?&quot;);</span>
<span class="lineNum">     475 </span>            : 
<span class="lineNum">     476 </span><span class="lineNoCov">          0 :         if (object_older_than (obj, max_generation))</span>
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :                 return hidden;</span>
<span class="lineNum">     478 </span>            : 
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :         if (closure-&gt;predicate (obj, closure-&gt;data))</span>
<span class="lineNum">     480 </span><span class="lineNoCov">          0 :                 return MONO_GC_HANDLE_METADATA_POINTER (sgen_client_default_metadata (), GC_HANDLE_TYPE_IS_WEAK (handle_type));</span>
<span class="lineNum">     481 </span>            : 
<span class="lineNum">     482 </span><span class="lineNoCov">          0 :         return hidden;</span>
<span class="lineNum">     483 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     484 </span>            : 
<a name="485"><span class="lineNum">     485 </span>            : /* LOCKING: requires that the GC lock is held */</a>
<span class="lineNum">     486 </span>            : void
<span class="lineNum">     487 </span>            : sgen_null_links_if (SgenObjectPredicateFunc predicate, void *data, int generation, gboolean track)
<span class="lineNum">     488 </span>            : {
<span class="lineNum">     489 </span><span class="lineNoCov">          0 :         WeakLinkAlivePredicateClosure closure = { predicate, data };</span>
<span class="lineNum">     490 </span><span class="lineNoCov">          0 :         sgen_gchandle_iterate (track ? HANDLE_WEAK_TRACK : HANDLE_WEAK, generation, null_link_if, &amp;closure);</span>
<span class="lineNum">     491 </span><span class="lineNoCov">          0 : }</span>
<a name="492"><span class="lineNum">     492 </span>            : </a>
<span class="lineNum">     493 </span>            : void
<span class="lineNum">     494 </span>            : sgen_init_gchandles (void)
<span class="lineNum">     495 </span>            : {
<span class="lineNum">     496 </span>            : #ifdef HEAVY_STATISTICS
<span class="lineNum">     497 </span>            :         mono_counters_register (&quot;GC handles allocated&quot;, MONO_COUNTER_GC | MONO_COUNTER_UINT, (void *)&amp;stat_gc_handles_allocated);
<span class="lineNum">     498 </span>            :         mono_counters_register (&quot;max GC handles allocated&quot;, MONO_COUNTER_GC | MONO_COUNTER_UINT, (void *)&amp;stat_gc_handles_max_allocated);
<span class="lineNum">     499 </span>            : #endif
<span class="lineNum">     500 </span><span class="lineCov">       3285 : }</span>
<span class="lineNum">     501 </span>            : 
<span class="lineNum">     502 </span>            : #endif
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
