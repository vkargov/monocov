<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - mono.info - utils/mono-threads.c</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">utils</a> - mono-threads.c<span style="font-size: 80%;"> (source / <a href="mono-threads.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">mono.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">454</td>
            <td class="headerCovTableEntry">627</td>
            <td class="headerCovTableEntryLo">72.4 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-01-18 17:24:17</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">69</td>
            <td class="headerCovTableEntry">81</td>
            <td class="headerCovTableEntryMed">85.2 %</td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :  * mono-threads.c: Low-level threading
<span class="lineNum">       3 </span>            :  *
<span class="lineNum">       4 </span>            :  * Author:
<span class="lineNum">       5 </span>            :  *      Rodrigo Kumpera (kumpera@gmail.com)
<span class="lineNum">       6 </span>            :  *
<span class="lineNum">       7 </span>            :  * Copyright 2011 Novell, Inc (http://www.novell.com)
<span class="lineNum">       8 </span>            :  * Copyright 2011 Xamarin, Inc (http://www.xamarin.com)
<span class="lineNum">       9 </span>            :  * Licensed under the MIT license. See LICENSE file in the project root for full license information.
<span class="lineNum">      10 </span>            :  */
<span class="lineNum">      11 </span>            : 
<span class="lineNum">      12 </span>            : #include &lt;config.h&gt;
<span class="lineNum">      13 </span>            : 
<span class="lineNum">      14 </span>            : /* enable pthread extensions */
<span class="lineNum">      15 </span>            : #ifdef TARGET_MACH
<span class="lineNum">      16 </span>            : #define _DARWIN_C_SOURCE
<span class="lineNum">      17 </span>            : #endif
<span class="lineNum">      18 </span>            : 
<span class="lineNum">      19 </span>            : #include &lt;mono/utils/mono-compiler.h&gt;
<span class="lineNum">      20 </span>            : #include &lt;mono/utils/mono-os-semaphore.h&gt;
<span class="lineNum">      21 </span>            : #include &lt;mono/utils/mono-threads.h&gt;
<span class="lineNum">      22 </span>            : #include &lt;mono/utils/mono-tls.h&gt;
<span class="lineNum">      23 </span>            : #include &lt;mono/utils/hazard-pointer.h&gt;
<span class="lineNum">      24 </span>            : #include &lt;mono/utils/mono-memory-model.h&gt;
<span class="lineNum">      25 </span>            : #include &lt;mono/utils/mono-mmap.h&gt;
<span class="lineNum">      26 </span>            : #include &lt;mono/utils/atomic.h&gt;
<span class="lineNum">      27 </span>            : #include &lt;mono/utils/mono-time.h&gt;
<span class="lineNum">      28 </span>            : #include &lt;mono/utils/mono-lazy-init.h&gt;
<span class="lineNum">      29 </span>            : #include &lt;mono/utils/mono-coop-mutex.h&gt;
<span class="lineNum">      30 </span>            : #include &lt;mono/utils/mono-coop-semaphore.h&gt;
<span class="lineNum">      31 </span>            : #include &lt;mono/utils/mono-threads-coop.h&gt;
<span class="lineNum">      32 </span>            : #include &lt;mono/utils/mono-threads-debug.h&gt;
<span class="lineNum">      33 </span>            : #include &lt;mono/utils/os-event.h&gt;
<span class="lineNum">      34 </span>            : 
<span class="lineNum">      35 </span>            : #include &lt;mono/io-layer/io-layer.h&gt;
<span class="lineNum">      36 </span>            : 
<span class="lineNum">      37 </span>            : #include &lt;errno.h&gt;
<span class="lineNum">      38 </span>            : 
<span class="lineNum">      39 </span>            : #if defined(__MACH__)
<span class="lineNum">      40 </span>            : #include &lt;mono/utils/mach-support.h&gt;
<span class="lineNum">      41 </span>            : #endif
<span class="lineNum">      42 </span>            : 
<span class="lineNum">      43 </span>            : /*
<span class="lineNum">      44 </span>            : Mutex that makes sure only a single thread can be suspending others.
<span class="lineNum">      45 </span>            : Suspend is a very racy operation since it requires restarting until
<span class="lineNum">      46 </span>            : the target thread is not on an unsafe region.
<span class="lineNum">      47 </span>            : 
<span class="lineNum">      48 </span>            : We could implement this using critical regions, but would be much much
<span class="lineNum">      49 </span>            : harder for an operation that is hardly performance critical.
<span class="lineNum">      50 </span>            : 
<span class="lineNum">      51 </span>            : The GC has to acquire this lock before starting a STW to make sure
<span class="lineNum">      52 </span>            : a runtime suspend won't make it wronly see a thread in a safepoint
<span class="lineNum">      53 </span>            : when it is in fact not.
<span class="lineNum">      54 </span>            : 
<span class="lineNum">      55 </span>            : This has to be a naked locking primitive, and not a coop aware one, as
<span class="lineNum">      56 </span>            : it needs to be usable when destroying thread_info_key, the TLS key for
<span class="lineNum">      57 </span>            : the current MonoThreadInfo. In this case, mono_thread_info_current_unchecked,
<span class="lineNum">      58 </span>            : (which is used inside MONO_ENTER_GC_SAFE), would return NULL, leading
<span class="lineNum">      59 </span>            : to an assertion error. We then simply switch state manually in
<span class="lineNum">      60 </span>            : mono_thread_info_suspend_lock_with_info.
<span class="lineNum">      61 </span>            : */
<span class="lineNum">      62 </span>            : static MonoSemType global_suspend_semaphore;
<span class="lineNum">      63 </span>            : 
<span class="lineNum">      64 </span>            : static size_t thread_info_size;
<span class="lineNum">      65 </span>            : static MonoThreadInfoCallbacks threads_callbacks;
<span class="lineNum">      66 </span>            : static MonoThreadInfoRuntimeCallbacks runtime_callbacks;
<span class="lineNum">      67 </span>            : static MonoNativeTlsKey thread_info_key, thread_exited_key;
<span class="lineNum">      68 </span>            : #ifdef HAVE_KW_THREAD
<span class="lineNum">      69 </span>            : static __thread guint32 tls_small_id;
<span class="lineNum">      70 </span>            : #else
<span class="lineNum">      71 </span>            : static MonoNativeTlsKey small_id_key;
<span class="lineNum">      72 </span>            : #endif
<span class="lineNum">      73 </span>            : static MonoLinkedListSet thread_list;
<span class="lineNum">      74 </span>            : static gboolean mono_threads_inited = FALSE;
<span class="lineNum">      75 </span>            : 
<span class="lineNum">      76 </span>            : static MonoSemType suspend_semaphore;
<span class="lineNum">      77 </span>            : static size_t pending_suspends;
<span class="lineNum">      78 </span>            : 
<span class="lineNum">      79 </span>            : #define mono_thread_info_run_state(info) (((MonoThreadInfo*)info)-&gt;thread_state &amp; THREAD_STATE_MASK)
<span class="lineNum">      80 </span>            : 
<span class="lineNum">      81 </span>            : /*warn at 50 ms*/
<span class="lineNum">      82 </span>            : #define SLEEP_DURATION_BEFORE_WARNING (50)
<span class="lineNum">      83 </span>            : /*never aborts */
<span class="lineNum">      84 </span>            : #define SLEEP_DURATION_BEFORE_ABORT MONO_INFINITE_WAIT
<span class="lineNum">      85 </span>            : 
<span class="lineNum">      86 </span>            : static guint32 sleepWarnDuration = SLEEP_DURATION_BEFORE_WARNING,
<span class="lineNum">      87 </span>            :             sleepAbortDuration = SLEEP_DURATION_BEFORE_ABORT;
<span class="lineNum">      88 </span>            : 
<span class="lineNum">      89 </span>            : static int suspend_posts, resume_posts, abort_posts, waits_done, pending_ops;
<a name="90"><span class="lineNum">      90 </span>            : </a>
<span class="lineNum">      91 </span>            : void
<span class="lineNum">      92 </span>            : mono_threads_notify_initiator_of_abort (MonoThreadInfo* info)
<span class="lineNum">      93 </span>            : {
<span class="lineNum">      94 </span>            :         THREADS_SUSPEND_DEBUG (&quot;[INITIATOR-NOTIFY-ABORT] %p\n&quot;, mono_thread_info_get_tid (info));
<span class="lineNum">      95 </span><span class="lineNoCov">          0 :         InterlockedIncrement (&amp;abort_posts);</span>
<span class="lineNum">      96 </span><span class="lineNoCov">          0 :         mono_os_sem_post (&amp;suspend_semaphore);</span>
<span class="lineNum">      97 </span><span class="lineNoCov">          0 : }</span>
<a name="98"><span class="lineNum">      98 </span>            : </a>
<span class="lineNum">      99 </span>            : void
<span class="lineNum">     100 </span>            : mono_threads_notify_initiator_of_suspend (MonoThreadInfo* info)
<span class="lineNum">     101 </span>            : {
<span class="lineNum">     102 </span>            :         THREADS_SUSPEND_DEBUG (&quot;[INITIATOR-NOTIFY-SUSPEND] %p\n&quot;, mono_thread_info_get_tid (info));
<span class="lineNum">     103 </span><span class="lineNoCov">          0 :         InterlockedIncrement (&amp;suspend_posts);</span>
<span class="lineNum">     104 </span><span class="lineNoCov">          0 :         mono_os_sem_post (&amp;suspend_semaphore);</span>
<span class="lineNum">     105 </span><span class="lineNoCov">          0 : }</span>
<a name="106"><span class="lineNum">     106 </span>            : </a>
<span class="lineNum">     107 </span>            : void
<span class="lineNum">     108 </span>            : mono_threads_notify_initiator_of_resume (MonoThreadInfo* info)
<span class="lineNum">     109 </span>            : {
<span class="lineNum">     110 </span>            :         THREADS_SUSPEND_DEBUG (&quot;[INITIATOR-NOTIFY-RESUME] %p\n&quot;, mono_thread_info_get_tid (info));
<span class="lineNum">     111 </span><span class="lineNoCov">          0 :         InterlockedIncrement (&amp;resume_posts);</span>
<span class="lineNum">     112 </span><span class="lineNoCov">          0 :         mono_os_sem_post (&amp;suspend_semaphore);</span>
<span class="lineNum">     113 </span><span class="lineNoCov">          0 : }</span>
<a name="114"><span class="lineNum">     114 </span>            : </a>
<span class="lineNum">     115 </span>            : static gboolean
<span class="lineNum">     116 </span>            : begin_async_suspend (MonoThreadInfo *info, gboolean interrupt_kernel)
<span class="lineNum">     117 </span>            : {
<span class="lineNum">     118 </span><span class="lineCov">     469168 :         if (mono_threads_is_coop_enabled ()) {</span>
<span class="lineNum">     119 </span>            :                 /* There's nothing else to do after we async request the thread to suspend */
<span class="lineNum">     120 </span><span class="lineNoCov">          0 :                 mono_threads_add_to_pending_operation_set (info);</span>
<span class="lineNum">     121 </span><span class="lineNoCov">          0 :                 return TRUE;</span>
<span class="lineNum">     122 </span>            :         }
<span class="lineNum">     123 </span>            : 
<span class="lineNum">     124 </span><span class="lineCov">     469168 :         return mono_threads_suspend_begin_async_suspend (info, interrupt_kernel);</span>
<span class="lineNum">     125 </span><span class="lineCov">     469168 : }</span>
<a name="126"><span class="lineNum">     126 </span>            : </a>
<span class="lineNum">     127 </span>            : static gboolean
<span class="lineNum">     128 </span>            : check_async_suspend (MonoThreadInfo *info)
<span class="lineNum">     129 </span>            : {
<span class="lineNum">     130 </span><span class="lineCov">      86294 :         if (mono_threads_is_coop_enabled ()) {</span>
<span class="lineNum">     131 </span>            :                 /* Async suspend can't async fail on coop */
<span class="lineNum">     132 </span><span class="lineNoCov">          0 :                 return TRUE;</span>
<span class="lineNum">     133 </span>            :         }
<span class="lineNum">     134 </span>            : 
<span class="lineNum">     135 </span><span class="lineCov">      86294 :         return mono_threads_suspend_check_suspend_result (info);</span>
<span class="lineNum">     136 </span><span class="lineCov">      86294 : }</span>
<a name="137"><span class="lineNum">     137 </span>            : </a>
<span class="lineNum">     138 </span>            : static void
<span class="lineNum">     139 </span>            : resume_async_suspended (MonoThreadInfo *info)
<span class="lineNum">     140 </span>            : {
<span class="lineNum">     141 </span><span class="lineCov">     469168 :         if (mono_threads_is_coop_enabled ())</span>
<span class="lineNum">     142 </span><span class="lineNoCov">          0 :                 g_assert_not_reached ();</span>
<span class="lineNum">     143 </span>            : 
<span class="lineNum">     144 </span><span class="lineCov">    1407504 :         g_assert (mono_threads_suspend_begin_async_resume (info));</span>
<span class="lineNum">     145 </span><span class="lineCov">     469168 : }</span>
<a name="146"><span class="lineNum">     146 </span>            : </a>
<span class="lineNum">     147 </span>            : static void
<span class="lineNum">     148 </span>            : resume_self_suspended (MonoThreadInfo* info)
<span class="lineNum">     149 </span>            : {
<span class="lineNum">     150 </span>            :         THREADS_SUSPEND_DEBUG (&quot;**BEGIN self-resume %p\n&quot;, mono_thread_info_get_tid (info));
<span class="lineNum">     151 </span><span class="lineNoCov">          0 :         mono_os_sem_post (&amp;info-&gt;resume_semaphore);</span>
<span class="lineNum">     152 </span><span class="lineNoCov">          0 : }</span>
<a name="153"><span class="lineNum">     153 </span>            : </a>
<span class="lineNum">     154 </span>            : void
<span class="lineNum">     155 </span>            : mono_thread_info_wait_for_resume (MonoThreadInfo* info)
<span class="lineNum">     156 </span>            : {
<span class="lineNum">     157 </span>            :         int res;
<span class="lineNum">     158 </span>            :         THREADS_SUSPEND_DEBUG (&quot;**WAIT self-resume %p\n&quot;, mono_thread_info_get_tid (info));
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :         res = mono_os_sem_wait (&amp;info-&gt;resume_semaphore, MONO_SEM_FLAGS_NONE);</span>
<span class="lineNum">     160 </span><span class="lineNoCov">          0 :         g_assert (res != -1);</span>
<span class="lineNum">     161 </span><span class="lineNoCov">          0 : }</span>
<a name="162"><span class="lineNum">     162 </span>            : </a>
<span class="lineNum">     163 </span>            : static void
<span class="lineNum">     164 </span>            : resume_blocking_suspended (MonoThreadInfo* info)
<span class="lineNum">     165 </span>            : {
<span class="lineNum">     166 </span>            :         THREADS_SUSPEND_DEBUG (&quot;**BEGIN blocking-resume %p\n&quot;, mono_thread_info_get_tid (info));
<span class="lineNum">     167 </span><span class="lineNoCov">          0 :         mono_os_sem_post (&amp;info-&gt;resume_semaphore);</span>
<span class="lineNum">     168 </span><span class="lineNoCov">          0 : }</span>
<a name="169"><span class="lineNum">     169 </span>            : </a>
<span class="lineNum">     170 </span>            : void
<span class="lineNum">     171 </span>            : mono_threads_add_to_pending_operation_set (MonoThreadInfo* info)
<span class="lineNum">     172 </span>            : {
<span class="lineNum">     173 </span>            :         THREADS_SUSPEND_DEBUG (&quot;added %p to pending suspend\n&quot;, mono_thread_info_get_tid (info));
<span class="lineNum">     174 </span><span class="lineNoCov">          0 :         ++pending_suspends;</span>
<span class="lineNum">     175 </span><span class="lineNoCov">          0 :         InterlockedIncrement (&amp;pending_ops);</span>
<span class="lineNum">     176 </span><span class="lineNoCov">          0 : }</span>
<a name="177"><span class="lineNum">     177 </span>            : </a>
<span class="lineNum">     178 </span>            : void
<span class="lineNum">     179 </span>            : mono_threads_begin_global_suspend (void)
<span class="lineNum">     180 </span>            : {
<span class="lineNum">     181 </span><span class="lineCov">     279499 :         size_t ps = pending_suspends;</span>
<span class="lineNum">     182 </span><span class="lineCov">     279499 :         if (G_UNLIKELY (ps != 0))</span>
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :                 g_error (&quot;pending_suspends = %d, but must be 0&quot;, ps);</span>
<span class="lineNum">     184 </span>            :         THREADS_SUSPEND_DEBUG (&quot;------ BEGIN GLOBAL OP sp %d rp %d ap %d wd %d po %d (sp + rp + ap == wd) (wd == po)\n&quot;, suspend_posts, resume_posts,
<span class="lineNum">     185 </span>            :                 abort_posts, waits_done, pending_ops);
<span class="lineNum">     186 </span><span class="lineCov">     838497 :         g_assert ((suspend_posts + resume_posts + abort_posts) == waits_done);</span>
<span class="lineNum">     187 </span><span class="lineCov">     279499 :         mono_threads_coop_begin_global_suspend ();</span>
<span class="lineNum">     188 </span><span class="lineCov">     279499 : }</span>
<a name="189"><span class="lineNum">     189 </span>            : </a>
<span class="lineNum">     190 </span>            : void
<span class="lineNum">     191 </span>            : mono_threads_end_global_suspend (void) 
<span class="lineNum">     192 </span>            : {
<span class="lineNum">     193 </span><span class="lineCov">     279499 :         size_t ps = pending_suspends;</span>
<span class="lineNum">     194 </span><span class="lineCov">     279499 :         if (G_UNLIKELY (ps != 0))</span>
<span class="lineNum">     195 </span><span class="lineNoCov">          0 :                 g_error (&quot;pending_suspends = %d, but must be 0&quot;, ps);</span>
<span class="lineNum">     196 </span>            :         THREADS_SUSPEND_DEBUG (&quot;------ END GLOBAL OP sp %d rp %d ap %d wd %d po %d\n&quot;, suspend_posts, resume_posts,
<span class="lineNum">     197 </span>            :                 abort_posts, waits_done, pending_ops);
<span class="lineNum">     198 </span><span class="lineCov">     838497 :         g_assert ((suspend_posts + resume_posts + abort_posts) == waits_done);</span>
<span class="lineNum">     199 </span><span class="lineCov">     279499 :         mono_threads_coop_end_global_suspend ();</span>
<span class="lineNum">     200 </span><span class="lineCov">     279499 : }</span>
<a name="201"><span class="lineNum">     201 </span>            : </a>
<span class="lineNum">     202 </span>            : static void
<span class="lineNum">     203 </span>            : dump_threads (void)
<span class="lineNum">     204 </span>            : {
<span class="lineNum">     205 </span><span class="lineNoCov">          0 :         MonoThreadInfo *cur = mono_thread_info_current ();</span>
<span class="lineNum">     206 </span>            : 
<span class="lineNum">     207 </span><span class="lineNoCov">          0 :         MOSTLY_ASYNC_SAFE_PRINTF (&quot;STATE CUE CARD: (? means a positive number, usually 1 or 2, * means any number)\n&quot;);</span>
<span class="lineNum">     208 </span><span class="lineNoCov">          0 :         MOSTLY_ASYNC_SAFE_PRINTF (&quot;\t0x0\t- starting (GOOD, unless the thread is running managed code)\n&quot;);</span>
<span class="lineNum">     209 </span><span class="lineNoCov">          0 :         MOSTLY_ASYNC_SAFE_PRINTF (&quot;\t0x1\t- running (BAD, unless it's the gc thread)\n&quot;);</span>
<span class="lineNum">     210 </span><span class="lineNoCov">          0 :         MOSTLY_ASYNC_SAFE_PRINTF (&quot;\t0x2\t- detached (GOOD, unless the thread is running managed code)\n&quot;);</span>
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :         MOSTLY_ASYNC_SAFE_PRINTF (&quot;\t0x?03\t- async suspended (GOOD)\n&quot;);</span>
<span class="lineNum">     212 </span><span class="lineNoCov">          0 :         MOSTLY_ASYNC_SAFE_PRINTF (&quot;\t0x?04\t- self suspended (GOOD)\n&quot;);</span>
<span class="lineNum">     213 </span><span class="lineNoCov">          0 :         MOSTLY_ASYNC_SAFE_PRINTF (&quot;\t0x?05\t- async suspend requested (BAD)\n&quot;);</span>
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :         MOSTLY_ASYNC_SAFE_PRINTF (&quot;\t0x?06\t- self suspend requested (BAD)\n&quot;);</span>
<span class="lineNum">     215 </span><span class="lineNoCov">          0 :         MOSTLY_ASYNC_SAFE_PRINTF (&quot;\t0x*07\t- blocking (GOOD)\n&quot;);</span>
<span class="lineNum">     216 </span><span class="lineNoCov">          0 :         MOSTLY_ASYNC_SAFE_PRINTF (&quot;\t0x?08\t- blocking with pending suspend (GOOD)\n&quot;);</span>
<span class="lineNum">     217 </span>            : 
<span class="lineNum">     218 </span><span class="lineNoCov">          0 :         FOREACH_THREAD_SAFE (info) {</span>
<span class="lineNum">     219 </span>            : #ifdef TARGET_MACH
<span class="lineNum">     220 </span><span class="lineNoCov">          0 :                 char thread_name [256] = { 0 };</span>
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :                 pthread_getname_np (mono_thread_info_get_tid (info), thread_name, 255);</span>
<span class="lineNum">     222 </span>            : 
<span class="lineNum">     223 </span><span class="lineNoCov">          0 :                 MOSTLY_ASYNC_SAFE_PRINTF (&quot;--thread %p id %p [%p] (%s) state %x  %s\n&quot;, info, (void *) mono_thread_info_get_tid (info), (void*)(size_t)info-&gt;native_handle, thread_name, info-&gt;thread_state, info == cur ? &quot;GC INITIATOR&quot; : &quot;&quot; );</span>
<span class="lineNum">     224 </span>            : #else
<span class="lineNum">     225 </span>            :                 MOSTLY_ASYNC_SAFE_PRINTF (&quot;--thread %p id %p [%p] state %x  %s\n&quot;, info, (void *) mono_thread_info_get_tid (info), (void*)(size_t)info-&gt;native_handle, info-&gt;thread_state, info == cur ? &quot;GC INITIATOR&quot; : &quot;&quot; );
<span class="lineNum">     226 </span>            : #endif
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :         } FOREACH_THREAD_SAFE_END</span>
<span class="lineNum">     228 </span><span class="lineNoCov">          0 : }</span>
<a name="229"><span class="lineNum">     229 </span>            : </a>
<span class="lineNum">     230 </span>            : gboolean
<span class="lineNum">     231 </span>            : mono_threads_wait_pending_operations (void)
<span class="lineNum">     232 </span>            : {
<span class="lineNum">     233 </span>            :         int i;
<span class="lineNum">     234 </span><span class="lineCov">     754679 :         int c = pending_suspends;</span>
<span class="lineNum">     235 </span>            : 
<span class="lineNum">     236 </span>            :         /* Wait threads to park */
<span class="lineNum">     237 </span>            :         THREADS_SUSPEND_DEBUG (&quot;[INITIATOR-WAIT-COUNT] %d\n&quot;, c);
<span class="lineNum">     238 </span><span class="lineCov">     754679 :         if (pending_suspends) {</span>
<span class="lineNum">     239 </span>            :                 MonoStopwatch suspension_time;
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :                 mono_stopwatch_start (&amp;suspension_time);</span>
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :                 for (i = 0; i &lt; pending_suspends; ++i) {</span>
<span class="lineNum">     242 </span>            :                         THREADS_SUSPEND_DEBUG (&quot;[INITIATOR-WAIT-WAITING]\n&quot;);
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :                         InterlockedIncrement (&amp;waits_done);</span>
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :                         if (mono_os_sem_timedwait (&amp;suspend_semaphore, sleepAbortDuration, MONO_SEM_FLAGS_NONE) == MONO_SEM_TIMEDWAIT_RET_SUCCESS)</span>
<span class="lineNum">     245 </span><span class="lineNoCov">          0 :                                 continue;</span>
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :                         mono_stopwatch_stop (&amp;suspension_time);</span>
<span class="lineNum">     247 </span>            : 
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :                         dump_threads ();</span>
<span class="lineNum">     249 </span>            : 
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :                         MOSTLY_ASYNC_SAFE_PRINTF (&quot;WAITING for %d threads, got %d suspended\n&quot;, (int)pending_suspends, i);</span>
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :                         g_error (&quot;suspend_thread suspend took %d ms, which is more than the allowed %d ms&quot;, (int)mono_stopwatch_elapsed_ms (&amp;suspension_time), sleepAbortDuration);</span>
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :                 }</span>
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :                 mono_stopwatch_stop (&amp;suspension_time);</span>
<span class="lineNum">     254 </span>            :                 THREADS_SUSPEND_DEBUG (&quot;Suspending %d threads took %d ms.\n&quot;, (int)pending_suspends, (int)mono_stopwatch_elapsed_ms (&amp;suspension_time));
<span class="lineNum">     255 </span>            : 
<span class="lineNum">     256 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     257 </span>            : 
<span class="lineNum">     258 </span><span class="lineCov">     754679 :         pending_suspends = 0;</span>
<span class="lineNum">     259 </span>            : 
<span class="lineNum">     260 </span><span class="lineCov">     754679 :         return c &gt; 0;</span>
<span class="lineNum">     261 </span>            : }
<span class="lineNum">     262 </span>            : 
<span class="lineNum">     263 </span>            : 
<span class="lineNum">     264 </span>            : //Thread initialization code
<a name="265"><span class="lineNum">     265 </span>            : </a>
<span class="lineNum">     266 </span>            : static inline void
<span class="lineNum">     267 </span>            : mono_hazard_pointer_clear_all (MonoThreadHazardPointers *hp, int retain)
<span class="lineNum">     268 </span>            : {
<span class="lineNum">     269 </span><span class="lineCov">     221954 :         if (retain != 0)</span>
<span class="lineNum">     270 </span><span class="lineCov">    1109776 :                 mono_hazard_pointer_clear (hp, 0);</span>
<span class="lineNum">     271 </span><span class="lineCov">     221964 :         if (retain != 1)</span>
<span class="lineNum">     272 </span><span class="lineCov">     195195 :                 mono_hazard_pointer_clear (hp, 1);</span>
<span class="lineNum">     273 </span><span class="lineCov">     221963 :         if (retain != 2)</span>
<span class="lineNum">     274 </span><span class="lineCov">    1109815 :                 mono_hazard_pointer_clear (hp, 2);</span>
<span class="lineNum">     275 </span><span class="lineCov">     221962 : }</span>
<span class="lineNum">     276 </span>            : 
<span class="lineNum">     277 </span>            : /*
<span class="lineNum">     278 </span>            : If return non null Hazard Pointer 1 holds the return value.
<a name="279"><span class="lineNum">     279 </span>            : */</a>
<span class="lineNum">     280 </span>            : MonoThreadInfo*
<span class="lineNum">     281 </span>            : mono_thread_info_lookup (MonoNativeThreadId id)
<span class="lineNum">     282 </span>            : {
<span class="lineNum">     283 </span><span class="lineCov">     182928 :         MonoThreadHazardPointers *hp = mono_hazard_pointer_get ();</span>
<span class="lineNum">     284 </span>            : 
<span class="lineNum">     285 </span><span class="lineCov">     182928 :         if (!mono_lls_find (&amp;thread_list, hp, (uintptr_t)id)) {</span>
<span class="lineNum">     286 </span><span class="lineCov">          4 :                 mono_hazard_pointer_clear_all (hp, -1);</span>
<span class="lineNum">     287 </span><span class="lineCov">          4 :                 return NULL;</span>
<span class="lineNum">     288 </span>            :         } 
<span class="lineNum">     289 </span>            : 
<span class="lineNum">     290 </span><span class="lineCov">     182924 :         mono_hazard_pointer_clear_all (hp, 1);</span>
<span class="lineNum">     291 </span><span class="lineCov">     182924 :         return (MonoThreadInfo *) mono_hazard_pointer_get_val (hp, 1);</span>
<span class="lineNum">     292 </span><span class="lineCov">     182929 : }</span>
<a name="293"><span class="lineNum">     293 </span>            : </a>
<span class="lineNum">     294 </span>            : static gboolean
<span class="lineNum">     295 </span>            : mono_thread_info_insert (MonoThreadInfo *info)
<span class="lineNum">     296 </span>            : {
<span class="lineNum">     297 </span><span class="lineCov">      21193 :         MonoThreadHazardPointers *hp = mono_hazard_pointer_get ();</span>
<span class="lineNum">     298 </span>            : 
<span class="lineNum">     299 </span><span class="lineCov">      21193 :         if (!mono_lls_insert (&amp;thread_list, hp, (MonoLinkedListSetNode*)info)) {</span>
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :                 mono_hazard_pointer_clear_all (hp, -1);</span>
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :                 return FALSE;</span>
<span class="lineNum">     302 </span>            :         } 
<span class="lineNum">     303 </span>            : 
<span class="lineNum">     304 </span><span class="lineCov">      21193 :         mono_hazard_pointer_clear_all (hp, -1);</span>
<span class="lineNum">     305 </span><span class="lineCov">      21193 :         return TRUE;</span>
<span class="lineNum">     306 </span><span class="lineCov">      21193 : }</span>
<a name="307"><span class="lineNum">     307 </span>            : </a>
<span class="lineNum">     308 </span>            : static gboolean
<span class="lineNum">     309 </span>            : mono_thread_info_remove (MonoThreadInfo *info)
<span class="lineNum">     310 </span>            : {
<span class="lineNum">     311 </span><span class="lineCov">      17842 :         MonoThreadHazardPointers *hp = mono_hazard_pointer_get ();</span>
<span class="lineNum">     312 </span>            :         gboolean res;
<span class="lineNum">     313 </span>            : 
<span class="lineNum">     314 </span>            :         THREADS_DEBUG (&quot;removing info %p\n&quot;, info);
<span class="lineNum">     315 </span><span class="lineCov">      17842 :         res = mono_lls_remove (&amp;thread_list, hp, (MonoLinkedListSetNode*)info);</span>
<span class="lineNum">     316 </span><span class="lineCov">      17842 :         mono_hazard_pointer_clear_all (hp, -1);</span>
<span class="lineNum">     317 </span><span class="lineCov">      17842 :         return res;</span>
<span class="lineNum">     318 </span>            : }
<a name="319"><span class="lineNum">     319 </span>            : </a>
<span class="lineNum">     320 </span>            : static void
<span class="lineNum">     321 </span>            : free_thread_info (gpointer mem)
<span class="lineNum">     322 </span>            : {
<span class="lineNum">     323 </span><span class="lineCov">      17841 :         MonoThreadInfo *info = (MonoThreadInfo *) mem;</span>
<span class="lineNum">     324 </span>            : 
<span class="lineNum">     325 </span><span class="lineCov">      17841 :         mono_os_sem_destroy (&amp;info-&gt;resume_semaphore);</span>
<span class="lineNum">     326 </span><span class="lineCov">      17841 :         mono_threads_suspend_free (info);</span>
<span class="lineNum">     327 </span>            : 
<span class="lineNum">     328 </span><span class="lineCov">      17841 :         g_free (info);</span>
<span class="lineNum">     329 </span><span class="lineCov">      17841 : }</span>
<a name="330"><span class="lineNum">     330 </span>            : </a>
<span class="lineNum">     331 </span>            : int
<span class="lineNum">     332 </span>            : mono_thread_info_register_small_id (void)
<span class="lineNum">     333 </span>            : {
<span class="lineNum">     334 </span><span class="lineCov">      24493 :         int small_id = mono_thread_small_id_alloc ();</span>
<span class="lineNum">     335 </span>            : #ifdef HAVE_KW_THREAD
<span class="lineNum">     336 </span>            :         tls_small_id = small_id;
<span class="lineNum">     337 </span>            : #else
<span class="lineNum">     338 </span><span class="lineCov">      24493 :         mono_native_tls_set_value (small_id_key, GUINT_TO_POINTER (small_id + 1));</span>
<span class="lineNum">     339 </span>            : #endif
<span class="lineNum">     340 </span><span class="lineCov">      24493 :         return small_id;</span>
<span class="lineNum">     341 </span>            : }
<a name="342"><span class="lineNum">     342 </span>            : </a>
<span class="lineNum">     343 </span>            : static void
<span class="lineNum">     344 </span>            : thread_handle_destroy (gpointer data)
<span class="lineNum">     345 </span>            : {
<span class="lineNum">     346 </span>            :         MonoThreadHandle *thread_handle;
<span class="lineNum">     347 </span>            : 
<span class="lineNum">     348 </span><span class="lineCov">      14576 :         thread_handle = (MonoThreadHandle*) data;</span>
<span class="lineNum">     349 </span>            : 
<span class="lineNum">     350 </span><span class="lineCov">      14576 :         mono_os_event_destroy (&amp;thread_handle-&gt;event);</span>
<span class="lineNum">     351 </span><span class="lineCov">      14576 :         g_free (thread_handle);</span>
<span class="lineNum">     352 </span><span class="lineCov">      14576 : }</span>
<a name="353"><span class="lineNum">     353 </span>            : </a>
<span class="lineNum">     354 </span>            : static void*
<span class="lineNum">     355 </span>            : register_thread (MonoThreadInfo *info, gpointer baseptr)
<span class="lineNum">     356 </span>            : {
<span class="lineNum">     357 </span><span class="lineCov">      21192 :         size_t stsize = 0;</span>
<span class="lineNum">     358 </span><span class="lineCov">      21192 :         guint8 *staddr = NULL;</span>
<span class="lineNum">     359 </span><span class="lineCov">      21192 :         int small_id = mono_thread_info_register_small_id ();</span>
<span class="lineNum">     360 </span>            :         gboolean result;
<span class="lineNum">     361 </span><span class="lineCov">      21192 :         mono_thread_info_set_tid (info, mono_native_thread_id_get ());</span>
<span class="lineNum">     362 </span><span class="lineCov">      21192 :         info-&gt;small_id = small_id;</span>
<span class="lineNum">     363 </span>            : 
<span class="lineNum">     364 </span><span class="lineCov">      21192 :         info-&gt;handle = g_new0 (MonoThreadHandle, 1);</span>
<span class="lineNum">     365 </span><span class="lineCov">      42385 :         mono_refcount_init (info-&gt;handle, thread_handle_destroy);</span>
<span class="lineNum">     366 </span><span class="lineCov">      21193 :         mono_os_event_init (&amp;info-&gt;handle-&gt;event, FALSE);</span>
<span class="lineNum">     367 </span>            : 
<span class="lineNum">     368 </span><span class="lineCov">      21193 :         mono_os_sem_init (&amp;info-&gt;resume_semaphore, 0);</span>
<span class="lineNum">     369 </span>            : 
<span class="lineNum">     370 </span>            :         /*set TLS early so SMR works */
<span class="lineNum">     371 </span><span class="lineCov">      21193 :         mono_native_tls_set_value (thread_info_key, info);</span>
<span class="lineNum">     372 </span>            : 
<span class="lineNum">     373 </span>            :         THREADS_DEBUG (&quot;registering info %p tid %p small id %x\n&quot;, info, mono_thread_info_get_tid (info), info-&gt;small_id);
<span class="lineNum">     374 </span>            : 
<span class="lineNum">     375 </span><span class="lineCov">      21193 :         if (threads_callbacks.thread_register) {</span>
<span class="lineNum">     376 </span><span class="lineCov">      21155 :                 if (threads_callbacks.thread_register (info, baseptr) == NULL) {</span>
<span class="lineNum">     377 </span>            :                         // g_warning (&quot;thread registation failed\n&quot;);
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :                         mono_native_tls_set_value (thread_info_key, NULL);</span>
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :                         g_free (info);</span>
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :                         return NULL;</span>
<span class="lineNum">     381 </span>            :                 }
<span class="lineNum">     382 </span><span class="lineCov">      21155 :         }</span>
<span class="lineNum">     383 </span>            : 
<span class="lineNum">     384 </span><span class="lineCov">      21193 :         mono_thread_info_get_stack_bounds (&amp;staddr, &amp;stsize);</span>
<span class="lineNum">     385 </span><span class="lineCov">      63579 :         g_assert (staddr);</span>
<span class="lineNum">     386 </span><span class="lineCov">      63579 :         g_assert (stsize);</span>
<span class="lineNum">     387 </span><span class="lineCov">      21193 :         info-&gt;stack_start_limit = staddr;</span>
<span class="lineNum">     388 </span><span class="lineCov">      21193 :         info-&gt;stack_end = staddr + stsize;</span>
<span class="lineNum">     389 </span>            : 
<span class="lineNum">     390 </span><span class="lineCov">      21193 :         info-&gt;stackdata = g_byte_array_new ();</span>
<span class="lineNum">     391 </span>            : 
<span class="lineNum">     392 </span><span class="lineCov">      21193 :         mono_threads_suspend_register (info);</span>
<span class="lineNum">     393 </span>            : 
<span class="lineNum">     394 </span>            :         /*
<span class="lineNum">     395 </span>            :         Transition it before taking any locks or publishing itself to reduce the chance
<span class="lineNum">     396 </span>            :         of others witnessing a detached thread.
<span class="lineNum">     397 </span>            :         We can reasonably expect that until this thread gets published, no other thread will
<span class="lineNum">     398 </span>            :         try to manipulate it.
<span class="lineNum">     399 </span>            :         */
<span class="lineNum">     400 </span><span class="lineCov">      21193 :         mono_threads_transition_attach (info);</span>
<span class="lineNum">     401 </span><span class="lineCov">      21193 :         mono_thread_info_suspend_lock ();</span>
<span class="lineNum">     402 </span>            :         /*If this fail it means a given thread has been registered twice, which doesn't make sense. */
<span class="lineNum">     403 </span><span class="lineCov">      21193 :         result = mono_thread_info_insert (info);</span>
<span class="lineNum">     404 </span><span class="lineCov">      63579 :         g_assert (result);</span>
<span class="lineNum">     405 </span><span class="lineCov">      21193 :         mono_thread_info_suspend_unlock ();</span>
<span class="lineNum">     406 </span><span class="lineCov">      21193 :         return info;</span>
<span class="lineNum">     407 </span><span class="lineCov">      21193 : }</span>
<span class="lineNum">     408 </span>            : 
<span class="lineNum">     409 </span>            : static void
<span class="lineNum">     410 </span>            : mono_thread_info_suspend_lock_with_info (MonoThreadInfo *info);
<span class="lineNum">     411 </span>            : 
<span class="lineNum">     412 </span>            : static void
<span class="lineNum">     413 </span>            : mono_threads_signal_thread_handle (MonoThreadHandle* thread_handle);
<a name="414"><span class="lineNum">     414 </span>            : </a>
<span class="lineNum">     415 </span>            : static void
<span class="lineNum">     416 </span>            : unregister_thread (void *arg)
<span class="lineNum">     417 </span>            : {
<span class="lineNum">     418 </span>            :         gpointer gc_unsafe_stackdata;
<span class="lineNum">     419 </span>            :         MonoThreadInfo *info;
<span class="lineNum">     420 </span>            :         int small_id;
<span class="lineNum">     421 </span>            :         gboolean result;
<span class="lineNum">     422 </span>            :         gpointer handle;
<span class="lineNum">     423 </span>            : 
<span class="lineNum">     424 </span><span class="lineCov">      17840 :         info = (MonoThreadInfo *) arg;</span>
<span class="lineNum">     425 </span><span class="lineCov">      53523 :         g_assert (info);</span>
<span class="lineNum">     426 </span><span class="lineCov">      53526 :         g_assert (mono_thread_info_is_current (info));</span>
<span class="lineNum">     427 </span><span class="lineCov">      53526 :         g_assert (mono_thread_info_is_live (info));</span>
<span class="lineNum">     428 </span>            : 
<span class="lineNum">     429 </span>            :         /* Pump the HP queue while the thread is alive.*/
<span class="lineNum">     430 </span><span class="lineCov">      17836 :         mono_thread_hazardous_try_free_some ();</span>
<span class="lineNum">     431 </span>            : 
<span class="lineNum">     432 </span><span class="lineCov">      17836 :         small_id = info-&gt;small_id;</span>
<span class="lineNum">     433 </span>            : 
<span class="lineNum">     434 </span>            :         /* We only enter the GC unsafe region, as when exiting this function, the thread
<span class="lineNum">     435 </span>            :          * will be detached, and the current MonoThreadInfo* will be destroyed. */
<span class="lineNum">     436 </span><span class="lineCov">      17836 :         mono_threads_enter_gc_unsafe_region_unbalanced_with_info (info, &amp;gc_unsafe_stackdata);</span>
<span class="lineNum">     437 </span>            : 
<span class="lineNum">     438 </span>            :         THREADS_DEBUG (&quot;unregistering info %p\n&quot;, info);
<span class="lineNum">     439 </span>            : 
<span class="lineNum">     440 </span><span class="lineCov">      17836 :         mono_native_tls_set_value (thread_exited_key, GUINT_TO_POINTER (1));</span>
<span class="lineNum">     441 </span>            : 
<span class="lineNum">     442 </span>            :         /*
<span class="lineNum">     443 </span>            :          * TLS destruction order is not reliable so small_id might be cleaned up
<span class="lineNum">     444 </span>            :          * before us.
<span class="lineNum">     445 </span>            :          */
<span class="lineNum">     446 </span>            : #ifndef HAVE_KW_THREAD
<span class="lineNum">     447 </span><span class="lineCov">      17836 :         mono_native_tls_set_value (small_id_key, GUINT_TO_POINTER (info-&gt;small_id + 1));</span>
<span class="lineNum">     448 </span>            : #endif
<span class="lineNum">     449 </span>            : 
<span class="lineNum">     450 </span>            :         /* we need to duplicate it, as the info-&gt;handle is going
<span class="lineNum">     451 </span>            :          * to be closed when unregistering from the platform */
<span class="lineNum">     452 </span><span class="lineCov">      17836 :         handle = mono_threads_open_thread_handle (info-&gt;handle);</span>
<span class="lineNum">     453 </span>            : 
<span class="lineNum">     454 </span>            :         /*
<span class="lineNum">     455 </span>            :         First perform the callback that requires no locks.
<span class="lineNum">     456 </span>            :         This callback has the potential of taking other locks, so we do it before.
<span class="lineNum">     457 </span>            :         After it completes, the thread remains functional.
<span class="lineNum">     458 </span>            :         */
<span class="lineNum">     459 </span><span class="lineCov">      17836 :         if (threads_callbacks.thread_detach)</span>
<span class="lineNum">     460 </span><span class="lineCov">      17802 :                 threads_callbacks.thread_detach (info);</span>
<span class="lineNum">     461 </span>            : 
<span class="lineNum">     462 </span><span class="lineCov">      17842 :         mono_thread_info_suspend_lock_with_info (info);</span>
<span class="lineNum">     463 </span>            : 
<span class="lineNum">     464 </span>            :         /*
<span class="lineNum">     465 </span>            :         Now perform the callback that must be done under locks.
<span class="lineNum">     466 </span>            :         This will render the thread useless and non-suspendable, so it must
<span class="lineNum">     467 </span>            :         be done while holding the suspend lock to give no other thread chance
<span class="lineNum">     468 </span>            :         to suspend it.
<span class="lineNum">     469 </span>            :         */
<span class="lineNum">     470 </span><span class="lineCov">      17842 :         if (threads_callbacks.thread_unregister)</span>
<span class="lineNum">     471 </span><span class="lineCov">      17806 :                 threads_callbacks.thread_unregister (info);</span>
<span class="lineNum">     472 </span>            : 
<span class="lineNum">     473 </span>            :         /* The thread is no longer active, so unref its handle */
<span class="lineNum">     474 </span><span class="lineCov">      17842 :         mono_threads_close_thread_handle (info-&gt;handle);</span>
<span class="lineNum">     475 </span><span class="lineCov">      17842 :         info-&gt;handle = NULL;</span>
<span class="lineNum">     476 </span>            : 
<span class="lineNum">     477 </span><span class="lineCov">      17842 :         result = mono_thread_info_remove (info);</span>
<span class="lineNum">     478 </span><span class="lineCov">      53526 :         g_assert (result);</span>
<span class="lineNum">     479 </span><span class="lineCov">      17842 :         mono_threads_transition_detach (info);</span>
<span class="lineNum">     480 </span>            : 
<span class="lineNum">     481 </span><span class="lineCov">      17842 :         mono_thread_info_suspend_unlock ();</span>
<span class="lineNum">     482 </span>            : 
<span class="lineNum">     483 </span><span class="lineCov">      17842 :         g_byte_array_free (info-&gt;stackdata, /*free_segment=*/TRUE);</span>
<span class="lineNum">     484 </span>            : 
<span class="lineNum">     485 </span>            :         /*now it's safe to free the thread info.*/
<span class="lineNum">     486 </span><span class="lineCov">      17842 :         mono_thread_hazardous_try_free (info, free_thread_info);</span>
<span class="lineNum">     487 </span>            : 
<span class="lineNum">     488 </span><span class="lineCov">      17842 :         mono_thread_small_id_free (small_id);</span>
<span class="lineNum">     489 </span>            : 
<span class="lineNum">     490 </span><span class="lineCov">      17842 :         mono_threads_signal_thread_handle (handle);</span>
<span class="lineNum">     491 </span>            : 
<span class="lineNum">     492 </span><span class="lineCov">      17842 :         mono_threads_close_thread_handle (handle);</span>
<span class="lineNum">     493 </span><span class="lineCov">      17842 : }</span>
<a name="494"><span class="lineNum">     494 </span>            : </a>
<span class="lineNum">     495 </span>            : static void
<span class="lineNum">     496 </span>            : thread_exited_dtor (void *arg)
<span class="lineNum">     497 </span>            : {
<span class="lineNum">     498 </span>            : #if defined(__MACH__)
<span class="lineNum">     499 </span>            :         /*
<span class="lineNum">     500 </span>            :          * Since we use pthread dtors to clean up thread data, if a thread
<span class="lineNum">     501 </span>            :          * is attached to the runtime by another pthread dtor after our dtor
<span class="lineNum">     502 </span>            :          * has ran, it will never be detached, leading to various problems
<span class="lineNum">     503 </span>            :          * since the thread ids etc. will be reused while they are still in
<span class="lineNum">     504 </span>            :          * the threads hashtables etc.
<span class="lineNum">     505 </span>            :          * Dtors are called in a loop until all user tls entries are 0,
<span class="lineNum">     506 </span>            :          * but the loop has a maximum count (4), so if we set the tls
<span class="lineNum">     507 </span>            :          * variable every time, it will remain set when system tls dtors
<span class="lineNum">     508 </span>            :          * are ran. This allows mono_thread_info_is_exiting () to detect
<span class="lineNum">     509 </span>            :          * whenever the thread is exiting, even if it is executed from a
<span class="lineNum">     510 </span>            :          * system tls dtor (i.e. obj-c dealloc methods).
<span class="lineNum">     511 </span>            :          */
<span class="lineNum">     512 </span><span class="lineCov">      71279 :         mono_native_tls_set_value (thread_exited_key, GUINT_TO_POINTER (1));</span>
<span class="lineNum">     513 </span>            : #endif
<span class="lineNum">     514 </span><span class="lineCov">      71279 : }</span>
<a name="515"><span class="lineNum">     515 </span>            : </a>
<span class="lineNum">     516 </span>            : MonoThreadInfo*
<span class="lineNum">     517 </span>            : mono_thread_info_current_unchecked (void)
<span class="lineNum">     518 </span>            : {
<span class="lineNum">     519 </span><span class="lineCov">  284755253 :         return mono_threads_inited ? (MonoThreadInfo*)mono_native_tls_get_value (thread_info_key) : NULL;</span>
<span class="lineNum">     520 </span>            : }
<span class="lineNum">     521 </span>            : 
<a name="522"><span class="lineNum">     522 </span>            : </a>
<span class="lineNum">     523 </span>            : MonoThreadInfo*
<span class="lineNum">     524 </span>            : mono_thread_info_current (void)
<span class="lineNum">     525 </span>            : {
<span class="lineNum">     526 </span><span class="lineCov">  882806592 :         MonoThreadInfo *info = (MonoThreadInfo*)mono_native_tls_get_value (thread_info_key);</span>
<span class="lineNum">     527 </span><span class="lineCov">  882806592 :         if (info)</span>
<span class="lineNum">     528 </span><span class="lineCov">  886376183 :                 return info;</span>
<span class="lineNum">     529 </span>            : 
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :         info = mono_thread_info_lookup (mono_native_thread_id_get ()); /*info on HP1*/</span>
<span class="lineNum">     531 </span>            : 
<span class="lineNum">     532 </span>            :         /*
<span class="lineNum">     533 </span>            :         We might be called during thread cleanup, but we cannot be called after cleanup as happened.
<span class="lineNum">     534 </span>            :         The way to distinguish between before, during and after cleanup is the following:
<span class="lineNum">     535 </span>            : 
<span class="lineNum">     536 </span>            :         -If the TLS key is set, cleanup has not begun;
<span class="lineNum">     537 </span>            :         -If the TLS key is clean, but the thread remains registered, cleanup is in progress;
<span class="lineNum">     538 </span>            :         -If the thread is nowhere to be found, cleanup has finished.
<span class="lineNum">     539 </span>            : 
<span class="lineNum">     540 </span>            :         We cannot function after cleanup since there's no way to ensure what will happen.
<span class="lineNum">     541 </span>            :         */
<span class="lineNum">     542 </span><span class="lineNoCov">          0 :         g_assert (info);</span>
<span class="lineNum">     543 </span>            : 
<span class="lineNum">     544 </span>            :         /*We're looking up the current thread which will not be freed until we finish running, so no need to keep it on a HP */
<span class="lineNum">     545 </span><span class="lineNoCov">          0 :         mono_hazard_pointer_clear (mono_hazard_pointer_get (), 1);</span>
<span class="lineNum">     546 </span>            : 
<span class="lineNum">     547 </span><span class="lineNoCov">          0 :         return info;</span>
<span class="lineNum">     548 </span><span class="lineCov">  880605963 : }</span>
<a name="549"><span class="lineNum">     549 </span>            : </a>
<span class="lineNum">     550 </span>            : int
<span class="lineNum">     551 </span>            : mono_thread_info_get_small_id (void)
<span class="lineNum">     552 </span>            : {
<span class="lineNum">     553 </span>            : #ifdef HAVE_KW_THREAD
<span class="lineNum">     554 </span>            :         return tls_small_id;
<span class="lineNum">     555 </span>            : #else
<span class="lineNum">     556 </span><span class="lineCov">  253083121 :         gpointer val = mono_native_tls_get_value (small_id_key);</span>
<span class="lineNum">     557 </span><span class="lineCov">  253083121 :         if (!val)</span>
<span class="lineNum">     558 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">     559 </span><span class="lineCov">  253094813 :         return GPOINTER_TO_INT (val) - 1;</span>
<span class="lineNum">     560 </span>            : #endif
<span class="lineNum">     561 </span><span class="lineCov">  253108959 : }</span>
<a name="562"><span class="lineNum">     562 </span>            : </a>
<span class="lineNum">     563 </span>            : MonoLinkedListSet*
<span class="lineNum">     564 </span>            : mono_thread_info_list_head (void)
<span class="lineNum">     565 </span>            : {
<span class="lineNum">     566 </span><span class="lineCov">    1538297 :         return &amp;thread_list;</span>
<span class="lineNum">     567 </span>            : }
<span class="lineNum">     568 </span>            : 
<span class="lineNum">     569 </span>            : /**
<span class="lineNum">     570 </span>            :  * mono_threads_attach_tools_thread
<span class="lineNum">     571 </span>            :  *
<span class="lineNum">     572 </span>            :  * Attach the current thread as a tool thread. DON'T USE THIS FUNCTION WITHOUT READING ALL DISCLAIMERS.
<span class="lineNum">     573 </span>            :  *
<span class="lineNum">     574 </span>            :  * A tools thread is a very special kind of thread that needs access to core runtime facilities but should
<span class="lineNum">     575 </span>            :  * not be counted as a regular thread for high order facilities such as executing managed code or accessing
<span class="lineNum">     576 </span>            :  * the managed heap.
<span class="lineNum">     577 </span>            :  *
<span class="lineNum">     578 </span>            :  * This is intended only to tools such as a profiler than needs to be able to use our lock-free support when
<span class="lineNum">     579 </span>            :  * doing things like resolving backtraces in their background processing thread.
<a name="580"><span class="lineNum">     580 </span>            :  */</a>
<span class="lineNum">     581 </span>            : void
<span class="lineNum">     582 </span>            : mono_threads_attach_tools_thread (void)
<span class="lineNum">     583 </span>            : {
<span class="lineNum">     584 </span><span class="lineCov">         56 :         int dummy = 0;</span>
<span class="lineNum">     585 </span>            :         MonoThreadInfo *info;
<span class="lineNum">     586 </span>            : 
<span class="lineNum">     587 </span>            :         /* Must only be called once */
<span class="lineNum">     588 </span><span class="lineCov">        168 :         g_assert (!mono_native_tls_get_value (thread_info_key));</span>
<span class="lineNum">     589 </span>            :         
<span class="lineNum">     590 </span><span class="lineCov">        112 :         while (!mono_threads_inited) { </span>
<span class="lineNum">     591 </span><span class="lineNoCov">          0 :                 mono_thread_info_usleep (10);</span>
<span class="lineNum">     592 </span>            :         }
<span class="lineNum">     593 </span>            : 
<span class="lineNum">     594 </span><span class="lineCov">         56 :         info = mono_thread_info_attach (&amp;dummy);</span>
<span class="lineNum">     595 </span><span class="lineCov">        168 :         g_assert (info);</span>
<span class="lineNum">     596 </span>            : 
<span class="lineNum">     597 </span><span class="lineCov">         56 :         info-&gt;tools_thread = TRUE;</span>
<span class="lineNum">     598 </span><span class="lineCov">         56 : }</span>
<a name="599"><span class="lineNum">     599 </span>            : </a>
<span class="lineNum">     600 </span>            : MonoThreadInfo*
<span class="lineNum">     601 </span>            : mono_thread_info_attach (void *baseptr)
<span class="lineNum">     602 </span>            : {
<span class="lineNum">     603 </span>            :         MonoThreadInfo *info;
<span class="lineNum">     604 </span><span class="lineCov">      27975 :         if (!mono_threads_inited)</span>
<span class="lineNum">     605 </span>            :         {
<span class="lineNum">     606 </span>            : #ifdef HOST_WIN32
<span class="lineNum">     607 </span>            :                 /* This can happen from DllMain(DLL_THREAD_ATTACH) on Windows, if a
<span class="lineNum">     608 </span>            :                  * thread is created before an embedding API user initialized Mono. */
<span class="lineNum">     609 </span>            :                 THREADS_DEBUG (&quot;mono_thread_info_attach called before mono_threads_init\n&quot;);
<span class="lineNum">     610 </span>            :                 return NULL;
<span class="lineNum">     611 </span>            : #else
<span class="lineNum">     612 </span><span class="lineNoCov">          0 :                 g_assert (mono_threads_inited);</span>
<span class="lineNum">     613 </span>            : #endif
<span class="lineNum">     614 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     615 </span><span class="lineCov">      27976 :         info = (MonoThreadInfo *) mono_native_tls_get_value (thread_info_key);</span>
<span class="lineNum">     616 </span><span class="lineCov">      27976 :         if (!info) {</span>
<span class="lineNum">     617 </span><span class="lineCov">      21193 :                 info = (MonoThreadInfo *) g_malloc0 (thread_info_size);</span>
<span class="lineNum">     618 </span>            :                 THREADS_DEBUG (&quot;attaching %p\n&quot;, info);
<span class="lineNum">     619 </span><span class="lineCov">      21193 :                 if (!register_thread (info, baseptr))</span>
<span class="lineNum">     620 </span><span class="lineNoCov">          0 :                         return NULL;</span>
<span class="lineNum">     621 </span><span class="lineCov">      27976 :         } else if (threads_callbacks.thread_attach) {</span>
<span class="lineNum">     622 </span><span class="lineCov">       6783 :                 threads_callbacks.thread_attach (info);</span>
<span class="lineNum">     623 </span><span class="lineCov">       6783 :         }</span>
<span class="lineNum">     624 </span><span class="lineCov">      27976 :         return info;</span>
<span class="lineNum">     625 </span><span class="lineCov">      27976 : }</span>
<a name="626"><span class="lineNum">     626 </span>            : </a>
<span class="lineNum">     627 </span>            : void
<span class="lineNum">     628 </span>            : mono_thread_info_detach (void)
<span class="lineNum">     629 </span>            : {
<span class="lineNum">     630 </span>            :         MonoThreadInfo *info;
<span class="lineNum">     631 </span><span class="lineCov">      34621 :         if (!mono_threads_inited)</span>
<span class="lineNum">     632 </span>            :         {
<span class="lineNum">     633 </span>            :                 /* This can happen from DllMain(THREAD_DETACH) on Windows, if a thread
<span class="lineNum">     634 </span>            :                  * is created before an embedding API user initialized Mono. */
<span class="lineNum">     635 </span>            :                 THREADS_DEBUG (&quot;mono_thread_info_detach called before mono_threads_init\n&quot;);
<span class="lineNum">     636 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">     637 </span>            :         }
<span class="lineNum">     638 </span><span class="lineCov">      34631 :         info = (MonoThreadInfo *) mono_native_tls_get_value (thread_info_key);</span>
<span class="lineNum">     639 </span><span class="lineCov">      34631 :         if (info) {</span>
<span class="lineNum">     640 </span>            :                 THREADS_DEBUG (&quot;detaching %p\n&quot;, info);
<span class="lineNum">     641 </span><span class="lineCov">      16800 :                 unregister_thread (info);</span>
<span class="lineNum">     642 </span><span class="lineCov">      16800 :                 mono_native_tls_set_value (thread_info_key, NULL);</span>
<span class="lineNum">     643 </span><span class="lineCov">      16800 :         }</span>
<span class="lineNum">     644 </span><span class="lineCov">      34609 : }</span>
<span class="lineNum">     645 </span>            : 
<span class="lineNum">     646 </span>            : /*
<span class="lineNum">     647 </span>            :  * mono_thread_info_is_exiting:
<span class="lineNum">     648 </span>            :  *
<span class="lineNum">     649 </span>            :  *   Return whenever the current thread is exiting, i.e. it is running pthread
<span class="lineNum">     650 </span>            :  * dtors.
<a name="651"><span class="lineNum">     651 </span>            :  */</a>
<span class="lineNum">     652 </span>            : gboolean
<span class="lineNum">     653 </span>            : mono_thread_info_is_exiting (void)
<span class="lineNum">     654 </span>            : {
<span class="lineNum">     655 </span>            : #if defined(__MACH__)
<span class="lineNum">     656 </span><span class="lineNoCov">          0 :         if (mono_native_tls_get_value (thread_exited_key) == GUINT_TO_POINTER (1))</span>
<span class="lineNum">     657 </span><span class="lineNoCov">          0 :                 return TRUE;</span>
<span class="lineNum">     658 </span>            : #endif
<span class="lineNum">     659 </span><span class="lineNoCov">          0 :         return FALSE;</span>
<span class="lineNum">     660 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     661 </span>            : 
<a name="662"><span class="lineNum">     662 </span>            : #ifndef HOST_WIN32</a>
<span class="lineNum">     663 </span>            : static void
<span class="lineNum">     664 </span>            : thread_info_key_dtor (void *arg)
<span class="lineNum">     665 </span>            : {
<span class="lineNum">     666 </span>            :         /* Put the MonoThreadInfo back for the duration of the
<span class="lineNum">     667 </span>            :          * unregister code.  In some circumstances the thread needs to
<span class="lineNum">     668 </span>            :          * take the GC lock which may block which requires a coop
<span class="lineNum">     669 </span>            :          * state transition. */
<span class="lineNum">     670 </span><span class="lineCov">       1041 :         mono_native_tls_set_value (thread_info_key, arg);</span>
<span class="lineNum">     671 </span><span class="lineCov">       1041 :         unregister_thread (arg);</span>
<span class="lineNum">     672 </span><span class="lineCov">       1041 :         mono_native_tls_set_value (thread_info_key, NULL);</span>
<span class="lineNum">     673 </span><span class="lineCov">       1041 : }</span>
<span class="lineNum">     674 </span>            : #endif
<a name="675"><span class="lineNum">     675 </span>            : </a>
<span class="lineNum">     676 </span>            : void
<span class="lineNum">     677 </span>            : mono_threads_init (MonoThreadInfoCallbacks *callbacks, size_t info_size)
<span class="lineNum">     678 </span>            : {
<span class="lineNum">     679 </span>            :         gboolean res;
<span class="lineNum">     680 </span><span class="lineCov">       3289 :         threads_callbacks = *callbacks;</span>
<span class="lineNum">     681 </span><span class="lineCov">       3289 :         thread_info_size = info_size;</span>
<span class="lineNum">     682 </span>            :         const char *sleepLimit;
<span class="lineNum">     683 </span>            : #ifdef HOST_WIN32
<span class="lineNum">     684 </span>            :         res = mono_native_tls_alloc (&amp;thread_info_key, NULL);
<span class="lineNum">     685 </span>            :         res = mono_native_tls_alloc (&amp;thread_exited_key, NULL);
<span class="lineNum">     686 </span>            : #else
<span class="lineNum">     687 </span><span class="lineCov">       3289 :         res = mono_native_tls_alloc (&amp;thread_info_key, (void *) thread_info_key_dtor);</span>
<span class="lineNum">     688 </span><span class="lineCov">       3289 :         res = mono_native_tls_alloc (&amp;thread_exited_key, (void *) thread_exited_dtor);</span>
<span class="lineNum">     689 </span>            : #endif
<span class="lineNum">     690 </span>            : 
<span class="lineNum">     691 </span><span class="lineCov">       9867 :         g_assert (res);</span>
<span class="lineNum">     692 </span>            : 
<span class="lineNum">     693 </span>            : #ifndef HAVE_KW_THREAD
<span class="lineNum">     694 </span><span class="lineCov">       3289 :         res = mono_native_tls_alloc (&amp;small_id_key, NULL);</span>
<span class="lineNum">     695 </span>            : #endif
<span class="lineNum">     696 </span><span class="lineCov">       9867 :         g_assert (res);</span>
<span class="lineNum">     697 </span>            : 
<span class="lineNum">     698 </span><span class="lineCov">       3289 :         if ((sleepLimit = g_getenv (&quot;MONO_SLEEP_ABORT_LIMIT&quot;)) != NULL) {</span>
<span class="lineNum">     699 </span><span class="lineNoCov">          0 :                 errno = 0;</span>
<span class="lineNum">     700 </span><span class="lineNoCov">          0 :                 long threshold = strtol(sleepLimit, NULL, 10);</span>
<span class="lineNum">     701 </span><span class="lineNoCov">          0 :                 if ((errno == 0) &amp;&amp; (threshold &gt;= 40))  {</span>
<span class="lineNum">     702 </span><span class="lineNoCov">          0 :                         sleepAbortDuration = threshold;</span>
<span class="lineNum">     703 </span><span class="lineNoCov">          0 :                         sleepWarnDuration = threshold / 20;</span>
<span class="lineNum">     704 </span><span class="lineNoCov">          0 :                 } else</span>
<span class="lineNum">     705 </span><span class="lineNoCov">          0 :                         g_warning(&quot;MONO_SLEEP_ABORT_LIMIT must be a number &gt;= 40&quot;);</span>
<span class="lineNum">     706 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     707 </span>            : 
<span class="lineNum">     708 </span><span class="lineCov">       3289 :         mono_os_sem_init (&amp;global_suspend_semaphore, 1);</span>
<span class="lineNum">     709 </span><span class="lineCov">       3289 :         mono_os_sem_init (&amp;suspend_semaphore, 0);</span>
<span class="lineNum">     710 </span>            : 
<span class="lineNum">     711 </span><span class="lineCov">       3289 :         mono_lls_init (&amp;thread_list, NULL);</span>
<span class="lineNum">     712 </span><span class="lineCov">       3289 :         mono_thread_smr_init ();</span>
<span class="lineNum">     713 </span><span class="lineCov">       3289 :         mono_threads_suspend_init ();</span>
<span class="lineNum">     714 </span><span class="lineCov">       3289 :         mono_threads_coop_init ();</span>
<span class="lineNum">     715 </span><span class="lineCov">       3289 :         mono_threads_platform_init ();</span>
<span class="lineNum">     716 </span>            : 
<span class="lineNum">     717 </span>            : #if defined(__MACH__)
<span class="lineNum">     718 </span><span class="lineCov">       3289 :         mono_mach_init (thread_info_key);</span>
<span class="lineNum">     719 </span>            : #endif
<span class="lineNum">     720 </span>            : 
<span class="lineNum">     721 </span><span class="lineCov">       3289 :         mono_threads_inited = TRUE;</span>
<span class="lineNum">     722 </span>            : 
<span class="lineNum">     723 </span><span class="lineCov">       6578 :         g_assert (sizeof (MonoNativeThreadId) &lt;= sizeof (uintptr_t));</span>
<span class="lineNum">     724 </span><span class="lineCov">       3289 : }</span>
<a name="725"><span class="lineNum">     725 </span>            : </a>
<span class="lineNum">     726 </span>            : void
<span class="lineNum">     727 </span>            : mono_threads_signals_init (void)
<span class="lineNum">     728 </span>            : {
<span class="lineNum">     729 </span><span class="lineCov">       3285 :         mono_threads_suspend_init_signals ();</span>
<span class="lineNum">     730 </span><span class="lineCov">       3285 : }</span>
<a name="731"><span class="lineNum">     731 </span>            : </a>
<span class="lineNum">     732 </span>            : void
<span class="lineNum">     733 </span>            : mono_threads_runtime_init (MonoThreadInfoRuntimeCallbacks *callbacks)
<span class="lineNum">     734 </span>            : {
<span class="lineNum">     735 </span><span class="lineCov">       3287 :         runtime_callbacks = *callbacks;</span>
<span class="lineNum">     736 </span><span class="lineCov">       3287 : }</span>
<a name="737"><span class="lineNum">     737 </span>            : </a>
<span class="lineNum">     738 </span>            : MonoThreadInfoRuntimeCallbacks *
<span class="lineNum">     739 </span>            : mono_threads_get_runtime_callbacks (void)
<span class="lineNum">     740 </span>            : {
<span class="lineNum">     741 </span><span class="lineCov">     469168 :         return &amp;runtime_callbacks;</span>
<span class="lineNum">     742 </span>            : }
<a name="743"><span class="lineNum">     743 </span>            : </a>
<span class="lineNum">     744 </span>            : static gboolean
<span class="lineNum">     745 </span>            : mono_thread_info_core_resume (MonoThreadInfo *info)
<span class="lineNum">     746 </span>            : {
<span class="lineNum">     747 </span><span class="lineCov">    1095772 :         gboolean res = FALSE;</span>
<span class="lineNum">     748 </span>            : 
<span class="lineNum">     749 </span><span class="lineCov">    1095772 :         switch (mono_threads_transition_request_resume (info)) {</span>
<span class="lineNum">     750 </span>            :         case ResumeError:
<span class="lineNum">     751 </span><span class="lineNoCov">          0 :                 res = FALSE;</span>
<span class="lineNum">     752 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     753 </span>            :         case ResumeOk:
<span class="lineNum">     754 </span><span class="lineCov">      78718 :                 res = TRUE;</span>
<span class="lineNum">     755 </span><span class="lineCov">      78718 :                 break;</span>
<span class="lineNum">     756 </span>            :         case ResumeInitSelfResume:
<span class="lineNum">     757 </span><span class="lineNoCov">          0 :                 resume_self_suspended (info);</span>
<span class="lineNum">     758 </span><span class="lineNoCov">          0 :                 res = TRUE;</span>
<span class="lineNum">     759 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     760 </span>            :         case ResumeInitAsyncResume:
<span class="lineNum">     761 </span><span class="lineCov">     469168 :                 resume_async_suspended (info);</span>
<span class="lineNum">     762 </span><span class="lineCov">     469168 :                 res = TRUE;</span>
<span class="lineNum">     763 </span><span class="lineCov">     469168 :                 break;</span>
<span class="lineNum">     764 </span>            :         case ResumeInitBlockingResume:
<span class="lineNum">     765 </span><span class="lineNoCov">          0 :                 resume_blocking_suspended (info);</span>
<span class="lineNum">     766 </span><span class="lineNoCov">          0 :                 res = TRUE;</span>
<span class="lineNum">     767 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     768 </span>            :         }
<span class="lineNum">     769 </span>            : 
<span class="lineNum">     770 </span><span class="lineCov">     547886 :         return res;</span>
<span class="lineNum">     771 </span>            : }
<a name="772"><span class="lineNum">     772 </span>            : </a>
<span class="lineNum">     773 </span>            : gboolean
<span class="lineNum">     774 </span>            : mono_thread_info_resume (MonoNativeThreadId tid)
<span class="lineNum">     775 </span>            : {
<span class="lineNum">     776 </span>            :         gboolean result; /* don't initialize it so the compiler can catch unitilized paths. */
<span class="lineNum">     777 </span><span class="lineCov">      79950 :         MonoThreadHazardPointers *hp = mono_hazard_pointer_get ();</span>
<span class="lineNum">     778 </span>            :         MonoThreadInfo *info;
<span class="lineNum">     779 </span>            : 
<span class="lineNum">     780 </span>            :         THREADS_SUSPEND_DEBUG (&quot;RESUMING tid %p\n&quot;, (void*)tid);
<span class="lineNum">     781 </span>            : 
<span class="lineNum">     782 </span><span class="lineCov">      79950 :         mono_thread_info_suspend_lock ();</span>
<span class="lineNum">     783 </span>            : 
<span class="lineNum">     784 </span><span class="lineCov">      79950 :         info = mono_thread_info_lookup (tid); /*info on HP1*/</span>
<span class="lineNum">     785 </span><span class="lineCov">      79950 :         if (!info) {</span>
<span class="lineNum">     786 </span><span class="lineNoCov">          0 :                 result = FALSE;</span>
<span class="lineNum">     787 </span><span class="lineNoCov">          0 :                 goto cleanup;</span>
<span class="lineNum">     788 </span>            :         }
<span class="lineNum">     789 </span>            : 
<span class="lineNum">     790 </span><span class="lineCov">      79950 :         result = mono_thread_info_core_resume (info);</span>
<span class="lineNum">     791 </span>            : 
<span class="lineNum">     792 </span>            :         //Wait for the pending resume to finish
<span class="lineNum">     793 </span><span class="lineCov">      79950 :         mono_threads_wait_pending_operations ();</span>
<span class="lineNum">     794 </span>            : 
<span class="lineNum">     795 </span>            : cleanup:
<span class="lineNum">     796 </span><span class="lineCov">      79950 :         mono_thread_info_suspend_unlock ();</span>
<span class="lineNum">     797 </span><span class="lineCov">     319800 :         mono_hazard_pointer_clear (hp, 1);</span>
<span class="lineNum">     798 </span><span class="lineCov">      79950 :         return result;</span>
<span class="lineNum">     799 </span>            : }
<a name="800"><span class="lineNum">     800 </span>            : </a>
<span class="lineNum">     801 </span>            : gboolean
<span class="lineNum">     802 </span>            : mono_thread_info_begin_suspend (MonoThreadInfo *info)
<span class="lineNum">     803 </span>            : {
<span class="lineNum">     804 </span><span class="lineCov">     461592 :         switch (mono_threads_transition_request_async_suspension (info)) {</span>
<span class="lineNum">     805 </span>            :         case AsyncSuspendAlreadySuspended:
<span class="lineNum">     806 </span>            :         case AsyncSuspendBlocking:
<span class="lineNum">     807 </span><span class="lineCov">      78718 :                 return TRUE;</span>
<span class="lineNum">     808 </span>            :         case AsyncSuspendWait:
<span class="lineNum">     809 </span><span class="lineNoCov">          0 :                 mono_threads_add_to_pending_operation_set (info);</span>
<span class="lineNum">     810 </span><span class="lineNoCov">          0 :                 return TRUE;</span>
<span class="lineNum">     811 </span>            :         case AsyncSuspendInitSuspend:
<span class="lineNum">     812 </span><span class="lineCov">     382874 :                 return begin_async_suspend (info, FALSE);</span>
<span class="lineNum">     813 </span>            :         default:
<span class="lineNum">     814 </span><span class="lineNoCov">          0 :                 g_assert_not_reached ();</span>
<span class="lineNum">     815 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     816 </span><span class="lineCov">     461592 : }</span>
<a name="817"><span class="lineNum">     817 </span>            : </a>
<span class="lineNum">     818 </span>            : gboolean
<span class="lineNum">     819 </span>            : mono_thread_info_begin_resume (MonoThreadInfo *info)
<span class="lineNum">     820 </span>            : {
<span class="lineNum">     821 </span><span class="lineCov">     461592 :         return mono_thread_info_core_resume (info);</span>
<span class="lineNum">     822 </span>            : }
<span class="lineNum">     823 </span>            : 
<span class="lineNum">     824 </span>            : /*
<span class="lineNum">     825 </span>            : FIXME fix cardtable WB to be out of line and check with the runtime if the target is not the
<span class="lineNum">     826 </span>            : WB trampoline. Another option is to encode wb ranges in MonoJitInfo, but that is somewhat hard.
<a name="827"><span class="lineNum">     827 </span>            : */</a>
<span class="lineNum">     828 </span>            : static gboolean
<span class="lineNum">     829 </span>            : is_thread_in_critical_region (MonoThreadInfo *info)
<span class="lineNum">     830 </span>            : {
<span class="lineNum">     831 </span>            :         MonoMethod *method;
<span class="lineNum">     832 </span>            :         MonoJitInfo *ji;
<span class="lineNum">     833 </span>            :         gpointer stack_start;
<span class="lineNum">     834 </span>            :         MonoThreadUnwindState *state;
<span class="lineNum">     835 </span>            : 
<span class="lineNum">     836 </span><span class="lineCov">     547886 :         if (mono_threads_platform_in_critical_region (mono_thread_info_get_tid (info)))</span>
<span class="lineNum">     837 </span><span class="lineNoCov">          0 :                 return TRUE;</span>
<span class="lineNum">     838 </span>            : 
<span class="lineNum">     839 </span>            :         /* Are we inside a system critical region? */
<span class="lineNum">     840 </span><span class="lineCov">     547886 :         if (info-&gt;inside_critical_region)</span>
<span class="lineNum">     841 </span><span class="lineCov">          1 :                 return TRUE;</span>
<span class="lineNum">     842 </span>            : 
<span class="lineNum">     843 </span>            :         /* Are we inside a GC critical region? */
<span class="lineNum">     844 </span><span class="lineCov">    1095770 :         if (threads_callbacks.mono_thread_in_critical_region &amp;&amp; threads_callbacks.mono_thread_in_critical_region (info)) {</span>
<span class="lineNum">     845 </span><span class="lineCov">        342 :                 return TRUE;</span>
<span class="lineNum">     846 </span>            :         }
<span class="lineNum">     847 </span>            : 
<span class="lineNum">     848 </span>            :         /* The target thread might be shutting down and the domain might be null, which means no managed code left to run. */
<span class="lineNum">     849 </span><span class="lineCov">     547543 :         state = mono_thread_info_get_suspend_state (info);</span>
<span class="lineNum">     850 </span><span class="lineCov">     547543 :         if (!state-&gt;unwind_data [MONO_UNWIND_DATA_DOMAIN])</span>
<span class="lineNum">     851 </span><span class="lineCov">       1617 :                 return FALSE;</span>
<span class="lineNum">     852 </span>            : 
<span class="lineNum">     853 </span><span class="lineCov">     545926 :         stack_start = MONO_CONTEXT_GET_SP (&amp;state-&gt;ctx);</span>
<span class="lineNum">     854 </span>            :         /* altstack signal handler, sgen can't handle them, so we treat them as critical */
<span class="lineNum">     855 </span><span class="lineCov">    1090952 :         if (stack_start &lt; info-&gt;stack_start_limit || stack_start &gt;= info-&gt;stack_end)</span>
<span class="lineNum">     856 </span><span class="lineCov">        900 :                 return TRUE;</span>
<span class="lineNum">     857 </span>            : 
<span class="lineNum">     858 </span><span class="lineCov">     545026 :         if (threads_callbacks.ip_in_critical_region)</span>
<span class="lineNum">     859 </span><span class="lineCov">     545026 :                 return threads_callbacks.ip_in_critical_region ((MonoDomain *) state-&gt;unwind_data [MONO_UNWIND_DATA_DOMAIN], (char *) MONO_CONTEXT_GET_IP (&amp;state-&gt;ctx));</span>
<span class="lineNum">     860 </span>            : 
<span class="lineNum">     861 </span><span class="lineNoCov">          0 :         ji = mono_jit_info_table_find (</span>
<span class="lineNum">     862 </span><span class="lineNoCov">          0 :                 (MonoDomain *) state-&gt;unwind_data [MONO_UNWIND_DATA_DOMAIN],</span>
<span class="lineNum">     863 </span><span class="lineNoCov">          0 :                 (char *) MONO_CONTEXT_GET_IP (&amp;state-&gt;ctx));</span>
<span class="lineNum">     864 </span>            : 
<span class="lineNum">     865 </span><span class="lineNoCov">          0 :         if (!ji)</span>
<span class="lineNum">     866 </span><span class="lineNoCov">          0 :                 return FALSE;</span>
<span class="lineNum">     867 </span>            : 
<span class="lineNum">     868 </span><span class="lineNoCov">          0 :         method = mono_jit_info_get_method (ji);</span>
<span class="lineNum">     869 </span>            : 
<span class="lineNum">     870 </span><span class="lineNoCov">          0 :         return threads_callbacks.mono_method_is_critical (method);</span>
<span class="lineNum">     871 </span><span class="lineCov">     547886 : }</span>
<a name="872"><span class="lineNum">     872 </span>            : </a>
<span class="lineNum">     873 </span>            : gboolean
<span class="lineNum">     874 </span>            : mono_thread_info_in_critical_location (MonoThreadInfo *info)
<span class="lineNum">     875 </span>            : {
<span class="lineNum">     876 </span><span class="lineCov">     461592 :         return is_thread_in_critical_region (info);</span>
<span class="lineNum">     877 </span>            : }
<span class="lineNum">     878 </span>            : 
<span class="lineNum">     879 </span>            : /*
<span class="lineNum">     880 </span>            : The return value is only valid until a matching mono_thread_info_resume is called
<a name="881"><span class="lineNum">     881 </span>            : */</a>
<span class="lineNum">     882 </span>            : static MonoThreadInfo*
<span class="lineNum">     883 </span>            : suspend_sync (MonoNativeThreadId tid, gboolean interrupt_kernel)
<span class="lineNum">     884 </span>            : {
<span class="lineNum">     885 </span><span class="lineCov">      86298 :         MonoThreadHazardPointers *hp = mono_hazard_pointer_get ();</span>
<span class="lineNum">     886 </span><span class="lineCov">      86298 :         MonoThreadInfo *info = mono_thread_info_lookup (tid); /*info on HP1*/</span>
<span class="lineNum">     887 </span><span class="lineCov">      86298 :         if (!info)</span>
<span class="lineNum">     888 </span><span class="lineCov">          4 :                 return NULL;</span>
<span class="lineNum">     889 </span>            : 
<span class="lineNum">     890 </span><span class="lineCov">      86294 :         switch (mono_threads_transition_request_async_suspension (info)) {</span>
<span class="lineNum">     891 </span>            :         case AsyncSuspendAlreadySuspended:
<span class="lineNum">     892 </span><span class="lineNoCov">          0 :                 mono_hazard_pointer_clear (hp, 1); //XXX this is questionable we got to clean the suspend/resume nonsense of critical sections</span>
<span class="lineNum">     893 </span><span class="lineNoCov">          0 :                 return info;</span>
<span class="lineNum">     894 </span>            :         case AsyncSuspendWait:
<span class="lineNum">     895 </span><span class="lineNoCov">          0 :                 mono_threads_add_to_pending_operation_set (info);</span>
<span class="lineNum">     896 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     897 </span>            :         case AsyncSuspendInitSuspend:
<span class="lineNum">     898 </span><span class="lineCov">      86294 :                 if (!begin_async_suspend (info, interrupt_kernel)) {</span>
<span class="lineNum">     899 </span><span class="lineNoCov">          0 :                         mono_hazard_pointer_clear (hp, 1);</span>
<span class="lineNum">     900 </span><span class="lineNoCov">          0 :                         return NULL;</span>
<span class="lineNum">     901 </span>            :                 }
<span class="lineNum">     902 </span><span class="lineCov">      86294 :                 break;</span>
<span class="lineNum">     903 </span>            :         case AsyncSuspendBlocking:
<span class="lineNum">     904 </span><span class="lineNoCov">          0 :                 if (interrupt_kernel &amp;&amp; mono_threads_suspend_needs_abort_syscall ())</span>
<span class="lineNum">     905 </span><span class="lineNoCov">          0 :                         mono_threads_suspend_abort_syscall (info);</span>
<span class="lineNum">     906 </span>            : 
<span class="lineNum">     907 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     908 </span>            :         default:
<span class="lineNum">     909 </span><span class="lineNoCov">          0 :                 g_assert_not_reached ();</span>
<span class="lineNum">     910 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     911 </span>            : 
<span class="lineNum">     912 </span>            :         //Wait for the pending suspend to finish
<span class="lineNum">     913 </span><span class="lineCov">      86294 :         mono_threads_wait_pending_operations ();</span>
<span class="lineNum">     914 </span>            : 
<span class="lineNum">     915 </span><span class="lineCov">      86294 :         if (!check_async_suspend (info)) {</span>
<span class="lineNum">     916 </span><span class="lineNoCov">          0 :                 mono_thread_info_core_resume (info);</span>
<span class="lineNum">     917 </span><span class="lineNoCov">          0 :                 mono_threads_wait_pending_operations ();</span>
<span class="lineNum">     918 </span><span class="lineNoCov">          0 :                 mono_hazard_pointer_clear (hp, 1);</span>
<span class="lineNum">     919 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">     920 </span>            :         }
<span class="lineNum">     921 </span><span class="lineCov">      86294 :         return info;</span>
<span class="lineNum">     922 </span><span class="lineCov">      86298 : }</span>
<a name="923"><span class="lineNum">     923 </span>            : </a>
<span class="lineNum">     924 </span>            : static MonoThreadInfo*
<span class="lineNum">     925 </span>            : suspend_sync_nolock (MonoNativeThreadId id, gboolean interrupt_kernel)
<span class="lineNum">     926 </span>            : {
<span class="lineNum">     927 </span><span class="lineCov">      86298 :         MonoThreadInfo *info = NULL;</span>
<span class="lineNum">     928 </span><span class="lineCov">      86298 :         int sleep_duration = 0;</span>
<span class="lineNum">     929 </span><span class="lineCov">      86298 :         for (;;) {</span>
<span class="lineNum">     930 </span><span class="lineCov">      86298 :                 if (!(info = suspend_sync (id, interrupt_kernel))) {</span>
<span class="lineNum">     931 </span><span class="lineCov">         16 :                         mono_hazard_pointer_clear (mono_hazard_pointer_get (), 1);</span>
<span class="lineNum">     932 </span><span class="lineCov">          4 :                         return NULL;</span>
<span class="lineNum">     933 </span>            :                 }
<span class="lineNum">     934 </span>            : 
<span class="lineNum">     935 </span>            :                 /*WARNING: We now are in interrupt context until we resume the thread. */
<span class="lineNum">     936 </span><span class="lineCov">      86294 :                 if (!is_thread_in_critical_region (info))</span>
<span class="lineNum">     937 </span><span class="lineCov">      86294 :                         break;</span>
<span class="lineNum">     938 </span>            : 
<span class="lineNum">     939 </span><span class="lineNoCov">          0 :                 if (!mono_thread_info_core_resume (info)) {</span>
<span class="lineNum">     940 </span><span class="lineNoCov">          0 :                         mono_hazard_pointer_clear (mono_hazard_pointer_get (), 1);</span>
<span class="lineNum">     941 </span><span class="lineNoCov">          0 :                         return NULL;</span>
<span class="lineNum">     942 </span>            :                 }
<span class="lineNum">     943 </span>            :                 THREADS_SUSPEND_DEBUG (&quot;RESTARTED thread tid %p\n&quot;, (void*)id);
<span class="lineNum">     944 </span>            : 
<span class="lineNum">     945 </span>            :                 /* Wait for the pending resume to finish */
<span class="lineNum">     946 </span><span class="lineNoCov">          0 :                 mono_threads_wait_pending_operations ();</span>
<span class="lineNum">     947 </span>            : 
<span class="lineNum">     948 </span><span class="lineNoCov">          0 :                 if (sleep_duration == 0)</span>
<span class="lineNum">     949 </span><span class="lineNoCov">          0 :                         mono_thread_info_yield ();</span>
<span class="lineNum">     950 </span>            :                 else
<span class="lineNum">     951 </span><span class="lineNoCov">          0 :                         g_usleep (sleep_duration);</span>
<span class="lineNum">     952 </span>            : 
<span class="lineNum">     953 </span><span class="lineNoCov">          0 :                 sleep_duration += 10;</span>
<span class="lineNum">     954 </span>            :         }
<span class="lineNum">     955 </span><span class="lineCov">      86294 :         return info;</span>
<span class="lineNum">     956 </span><span class="lineCov">      86298 : }</span>
<a name="957"><span class="lineNum">     957 </span>            : </a>
<span class="lineNum">     958 </span>            : void
<span class="lineNum">     959 </span>            : mono_thread_info_safe_suspend_and_run (MonoNativeThreadId id, gboolean interrupt_kernel, MonoSuspendThreadCallback callback, gpointer user_data)
<span class="lineNum">     960 </span>            : {
<span class="lineNum">     961 </span>            :         int result;
<span class="lineNum">     962 </span><span class="lineCov">      86298 :         MonoThreadInfo *info = NULL;</span>
<span class="lineNum">     963 </span><span class="lineCov">      86298 :         MonoThreadHazardPointers *hp = mono_hazard_pointer_get ();</span>
<span class="lineNum">     964 </span>            : 
<span class="lineNum">     965 </span>            :         THREADS_SUSPEND_DEBUG (&quot;SUSPENDING tid %p\n&quot;, (void*)id);
<span class="lineNum">     966 </span>            :         /*FIXME: unify this with self-suspend*/
<span class="lineNum">     967 </span><span class="lineCov">     258894 :         g_assert (id != mono_native_thread_id_get ());</span>
<span class="lineNum">     968 </span>            : 
<span class="lineNum">     969 </span>            :         /* This can block during stw */
<span class="lineNum">     970 </span><span class="lineCov">      86298 :         mono_thread_info_suspend_lock ();</span>
<span class="lineNum">     971 </span><span class="lineCov">      86298 :         mono_threads_begin_global_suspend ();</span>
<span class="lineNum">     972 </span>            : 
<span class="lineNum">     973 </span><span class="lineCov">      86298 :         info = suspend_sync_nolock (id, interrupt_kernel);</span>
<span class="lineNum">     974 </span><span class="lineCov">      86298 :         if (!info)</span>
<span class="lineNum">     975 </span><span class="lineCov">          4 :                 goto done;</span>
<span class="lineNum">     976 </span>            : 
<span class="lineNum">     977 </span><span class="lineCov">      86294 :         switch (result = callback (info, user_data)) {</span>
<span class="lineNum">     978 </span>            :         case MonoResumeThread:
<span class="lineNum">     979 </span><span class="lineCov">      25376 :                 mono_hazard_pointer_set (hp, 1, info);</span>
<span class="lineNum">     980 </span><span class="lineCov">       6344 :                 mono_thread_info_core_resume (info);</span>
<span class="lineNum">     981 </span><span class="lineCov">       6344 :                 mono_threads_wait_pending_operations ();</span>
<span class="lineNum">     982 </span><span class="lineCov">       6344 :                 break;</span>
<span class="lineNum">     983 </span>            :         case KeepSuspended:
<span class="lineNum">     984 </span><span class="lineCov">     239850 :                 g_assert (!mono_threads_is_coop_enabled ());</span>
<span class="lineNum">     985 </span><span class="lineCov">      79950 :                 break;</span>
<span class="lineNum">     986 </span>            :         default:
<span class="lineNum">     987 </span><span class="lineNoCov">          0 :                 g_error (&quot;Invalid suspend_and_run callback return value %d&quot;, result);</span>
<span class="lineNum">     988 </span><span class="lineCov">      86294 :         }</span>
<span class="lineNum">     989 </span>            : 
<span class="lineNum">     990 </span>            : done:
<span class="lineNum">     991 </span><span class="lineCov">     345192 :         mono_hazard_pointer_clear (hp, 1);</span>
<span class="lineNum">     992 </span><span class="lineCov">      86298 :         mono_threads_end_global_suspend ();</span>
<span class="lineNum">     993 </span><span class="lineCov">      86298 :         mono_thread_info_suspend_unlock ();</span>
<span class="lineNum">     994 </span><span class="lineCov">      86298 : }</span>
<span class="lineNum">     995 </span>            : 
<span class="lineNum">     996 </span>            : /**
<span class="lineNum">     997 </span>            : Inject an assynchronous call into the target thread. The target thread must be suspended and
<span class="lineNum">     998 </span>            : only a single async call can be setup for a given suspend cycle.
<span class="lineNum">     999 </span>            : This async call must cause stack unwinding as the current implementation doesn't save enough state
<span class="lineNum">    1000 </span>            : to resume execution of the top-of-stack function. It's an acceptable limitation since this is
<span class="lineNum">    1001 </span>            : currently used only to deliver exceptions.
<a name="1002"><span class="lineNum">    1002 </span>            : */</a>
<span class="lineNum">    1003 </span>            : void
<span class="lineNum">    1004 </span>            : mono_thread_info_setup_async_call (MonoThreadInfo *info, void (*target_func)(void*), void *user_data)
<span class="lineNum">    1005 </span>            : {
<span class="lineNum">    1006 </span>            :         /* An async call can only be setup on an async suspended thread */
<span class="lineNum">    1007 </span><span class="lineNoCov">          0 :         g_assert (mono_thread_info_run_state (info) == STATE_ASYNC_SUSPENDED);</span>
<span class="lineNum">    1008 </span>            :         /*FIXME this is a bad assert, we probably should do proper locking and fail if one is already set*/
<span class="lineNum">    1009 </span><span class="lineNoCov">          0 :         g_assert (!info-&gt;async_target);</span>
<span class="lineNum">    1010 </span><span class="lineNoCov">          0 :         info-&gt;async_target = target_func;</span>
<span class="lineNum">    1011 </span>            :         /* This is not GC tracked */
<span class="lineNum">    1012 </span><span class="lineNoCov">          0 :         info-&gt;user_data = user_data;</span>
<span class="lineNum">    1013 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1014 </span>            : 
<span class="lineNum">    1015 </span>            : /*
<span class="lineNum">    1016 </span>            : The suspend lock is held during any suspend in progress.
<span class="lineNum">    1017 </span>            : A GC that has safepoints must take this lock as part of its
<span class="lineNum">    1018 </span>            : STW to make sure no unsafe pending suspend is in progress.   
<span class="lineNum">    1019 </span>            : */
<a name="1020"><span class="lineNum">    1020 </span>            : </a>
<span class="lineNum">    1021 </span>            : static void
<span class="lineNum">    1022 </span>            : mono_thread_info_suspend_lock_with_info (MonoThreadInfo *info)
<span class="lineNum">    1023 </span>            : {
<span class="lineNum">    1024 </span><span class="lineCov">    1195361 :         g_assert (info);</span>
<span class="lineNum">    1025 </span><span class="lineCov">    1195351 :         g_assert (mono_thread_info_is_current (info));</span>
<span class="lineNum">    1026 </span><span class="lineCov">    1195310 :         g_assert (mono_thread_info_is_live (info));</span>
<span class="lineNum">    1027 </span>            : 
<span class="lineNum">    1028 </span><span class="lineCov">     796866 :         MONO_ENTER_GC_SAFE_WITH_INFO(info);</span>
<span class="lineNum">    1029 </span>            : 
<span class="lineNum">    1030 </span><span class="lineCov">     398433 :         int res = mono_os_sem_wait (&amp;global_suspend_semaphore, MONO_SEM_FLAGS_NONE);</span>
<span class="lineNum">    1031 </span><span class="lineCov">    1195401 :         g_assert (res != -1);</span>
<span class="lineNum">    1032 </span>            : 
<span class="lineNum">    1033 </span><span class="lineCov">     398484 :         MONO_EXIT_GC_SAFE_WITH_INFO;</span>
<span class="lineNum">    1034 </span><span class="lineCov">     398484 : }</span>
<a name="1035"><span class="lineNum">    1035 </span>            : </a>
<span class="lineNum">    1036 </span>            : void
<span class="lineNum">    1037 </span>            : mono_thread_info_suspend_lock (void)
<span class="lineNum">    1038 </span>            : {
<span class="lineNum">    1039 </span><span class="lineCov">     380623 :         mono_thread_info_suspend_lock_with_info (mono_thread_info_current_unchecked ());</span>
<span class="lineNum">    1040 </span><span class="lineCov">     380623 : }</span>
<a name="1041"><span class="lineNum">    1041 </span>            : </a>
<span class="lineNum">    1042 </span>            : void
<span class="lineNum">    1043 </span>            : mono_thread_info_suspend_unlock (void)
<span class="lineNum">    1044 </span>            : {
<span class="lineNum">    1045 </span><span class="lineCov">     398484 :         mono_os_sem_post (&amp;global_suspend_semaphore);</span>
<span class="lineNum">    1046 </span><span class="lineCov">     398484 : }</span>
<span class="lineNum">    1047 </span>            : 
<span class="lineNum">    1048 </span>            : /*
<span class="lineNum">    1049 </span>            :  * This is a very specific function whose only purpose is to
<span class="lineNum">    1050 </span>            :  * break a given thread from socket syscalls.
<span class="lineNum">    1051 </span>            :  *
<span class="lineNum">    1052 </span>            :  * This only exists because linux won't fail a call to connect
<span class="lineNum">    1053 </span>            :  * if the underlying is closed.
<span class="lineNum">    1054 </span>            :  *
<span class="lineNum">    1055 </span>            :  * TODO We should cleanup and unify this with the other syscall abort
<span class="lineNum">    1056 </span>            :  * facility.
<a name="1057"><span class="lineNum">    1057 </span>            :  */</a>
<span class="lineNum">    1058 </span>            : void
<span class="lineNum">    1059 </span>            : mono_thread_info_abort_socket_syscall_for_close (MonoNativeThreadId tid)
<span class="lineNum">    1060 </span>            : {
<span class="lineNum">    1061 </span>            :         MonoThreadHazardPointers *hp;
<span class="lineNum">    1062 </span>            :         MonoThreadInfo *info;
<span class="lineNum">    1063 </span>            : 
<span class="lineNum">    1064 </span><span class="lineNoCov">          0 :         if (tid == mono_native_thread_id_get () || !mono_threads_suspend_needs_abort_syscall ())</span>
<span class="lineNum">    1065 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">    1066 </span>            : 
<span class="lineNum">    1067 </span><span class="lineNoCov">          0 :         hp = mono_hazard_pointer_get ();</span>
<span class="lineNum">    1068 </span><span class="lineNoCov">          0 :         info = mono_thread_info_lookup (tid);</span>
<span class="lineNum">    1069 </span><span class="lineNoCov">          0 :         if (!info)</span>
<span class="lineNum">    1070 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">    1071 </span>            : 
<span class="lineNum">    1072 </span><span class="lineNoCov">          0 :         if (mono_thread_info_run_state (info) == STATE_DETACHED) {</span>
<span class="lineNum">    1073 </span><span class="lineNoCov">          0 :                 mono_hazard_pointer_clear (hp, 1);</span>
<span class="lineNum">    1074 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">    1075 </span>            :         }
<span class="lineNum">    1076 </span>            : 
<span class="lineNum">    1077 </span><span class="lineNoCov">          0 :         mono_thread_info_suspend_lock ();</span>
<span class="lineNum">    1078 </span><span class="lineNoCov">          0 :         mono_threads_begin_global_suspend ();</span>
<span class="lineNum">    1079 </span>            : 
<span class="lineNum">    1080 </span><span class="lineNoCov">          0 :         mono_threads_suspend_abort_syscall (info);</span>
<span class="lineNum">    1081 </span><span class="lineNoCov">          0 :         mono_threads_wait_pending_operations ();</span>
<span class="lineNum">    1082 </span>            : 
<span class="lineNum">    1083 </span><span class="lineNoCov">          0 :         mono_hazard_pointer_clear (hp, 1);</span>
<span class="lineNum">    1084 </span>            : 
<span class="lineNum">    1085 </span><span class="lineNoCov">          0 :         mono_threads_end_global_suspend ();</span>
<span class="lineNum">    1086 </span><span class="lineNoCov">          0 :         mono_thread_info_suspend_unlock ();</span>
<span class="lineNum">    1087 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1088 </span>            : 
<span class="lineNum">    1089 </span>            : /*
<span class="lineNum">    1090 </span>            :  * mono_thread_info_set_is_async_context:
<span class="lineNum">    1091 </span>            :  *
<span class="lineNum">    1092 </span>            :  *   Set whenever the current thread is in an async context. Some runtime functions might behave
<span class="lineNum">    1093 </span>            :  * differently while in an async context in order to be async safe.
<a name="1094"><span class="lineNum">    1094 </span>            :  */</a>
<span class="lineNum">    1095 </span>            : void
<span class="lineNum">    1096 </span>            : mono_thread_info_set_is_async_context (gboolean async_context)
<span class="lineNum">    1097 </span>            : {
<span class="lineNum">    1098 </span><span class="lineCov">     174403 :         MonoThreadInfo *info = mono_thread_info_current ();</span>
<span class="lineNum">    1099 </span>            : 
<span class="lineNum">    1100 </span><span class="lineCov">     174403 :         if (info)</span>
<span class="lineNum">    1101 </span><span class="lineCov">     174403 :                 info-&gt;is_async_context = async_context;</span>
<span class="lineNum">    1102 </span><span class="lineCov">     174405 : }</span>
<a name="1103"><span class="lineNum">    1103 </span>            : </a>
<span class="lineNum">    1104 </span>            : gboolean
<span class="lineNum">    1105 </span>            : mono_thread_info_is_async_context (void)
<span class="lineNum">    1106 </span>            : {
<span class="lineNum">    1107 </span><span class="lineCov">    7618468 :         MonoThreadInfo *info = mono_thread_info_current ();</span>
<span class="lineNum">    1108 </span>            : 
<span class="lineNum">    1109 </span><span class="lineCov">    7618468 :         if (info)</span>
<span class="lineNum">    1110 </span><span class="lineCov">    7618472 :                 return info-&gt;is_async_context;</span>
<span class="lineNum">    1111 </span>            :         else
<span class="lineNum">    1112 </span><span class="lineNoCov">          0 :                 return FALSE;</span>
<span class="lineNum">    1113 </span><span class="lineCov">    7618501 : }</span>
<span class="lineNum">    1114 </span>            : 
<span class="lineNum">    1115 </span>            : typedef struct {
<span class="lineNum">    1116 </span>            :         MonoRefCount ref;
<span class="lineNum">    1117 </span>            :         MonoThreadStart start_routine;
<span class="lineNum">    1118 </span>            :         gpointer start_routine_arg;
<span class="lineNum">    1119 </span>            :         MonoCoopSem registered;
<span class="lineNum">    1120 </span>            :         MonoThreadHandle *handle;
<span class="lineNum">    1121 </span>            : } CreateThreadData;
<a name="1122"><span class="lineNum">    1122 </span>            : </a>
<span class="lineNum">    1123 </span>            : static void
<span class="lineNum">    1124 </span>            : create_thread_data_destroy (gpointer data)
<span class="lineNum">    1125 </span>            : {
<span class="lineNum">    1126 </span>            :         CreateThreadData *thread_data;
<span class="lineNum">    1127 </span>            : 
<span class="lineNum">    1128 </span><span class="lineCov">      16812 :         thread_data = (CreateThreadData*) data;</span>
<span class="lineNum">    1129 </span>            : 
<span class="lineNum">    1130 </span><span class="lineCov">      16812 :         mono_coop_sem_destroy (&amp;thread_data-&gt;registered);</span>
<span class="lineNum">    1131 </span><span class="lineCov">      16812 :         g_free (thread_data);</span>
<span class="lineNum">    1132 </span><span class="lineCov">      16812 : }</span>
<a name="1133"><span class="lineNum">    1133 </span>            : </a>
<span class="lineNum">    1134 </span>            : static gsize WINAPI
<span class="lineNum">    1135 </span>            : inner_start_thread (gpointer data)
<span class="lineNum">    1136 </span>            : {
<span class="lineNum">    1137 </span>            :         CreateThreadData *thread_data;
<span class="lineNum">    1138 </span>            :         MonoThreadInfo *info;
<span class="lineNum">    1139 </span>            :         MonoThreadStart start_routine;
<span class="lineNum">    1140 </span>            :         gpointer start_routine_arg;
<span class="lineNum">    1141 </span>            :         gsize start_routine_res;
<span class="lineNum">    1142 </span>            :         gsize dummy;
<span class="lineNum">    1143 </span>            : 
<span class="lineNum">    1144 </span><span class="lineCov">      16812 :         thread_data = (CreateThreadData*) data;</span>
<span class="lineNum">    1145 </span><span class="lineCov">      50436 :         g_assert (thread_data);</span>
<span class="lineNum">    1146 </span>            : 
<span class="lineNum">    1147 </span><span class="lineCov">      16812 :         start_routine = thread_data-&gt;start_routine;</span>
<span class="lineNum">    1148 </span><span class="lineCov">      16812 :         start_routine_arg = thread_data-&gt;start_routine_arg;</span>
<span class="lineNum">    1149 </span>            : 
<span class="lineNum">    1150 </span><span class="lineCov">      16812 :         info = mono_thread_info_attach (&amp;dummy);</span>
<span class="lineNum">    1151 </span><span class="lineCov">      16812 :         info-&gt;runtime_thread = TRUE;</span>
<span class="lineNum">    1152 </span>            : 
<span class="lineNum">    1153 </span><span class="lineCov">      16812 :         thread_data-&gt;handle = mono_threads_open_thread_handle (info-&gt;handle);</span>
<span class="lineNum">    1154 </span>            : 
<span class="lineNum">    1155 </span><span class="lineCov">      16812 :         mono_coop_sem_post (&amp;thread_data-&gt;registered);</span>
<span class="lineNum">    1156 </span>            : 
<span class="lineNum">    1157 </span><span class="lineCov">      33624 :         mono_refcount_dec (thread_data);</span>
<span class="lineNum">    1158 </span>            : 
<span class="lineNum">    1159 </span>            :         /* thread_data is not valid anymore */
<span class="lineNum">    1160 </span><span class="lineCov">      16812 :         thread_data = NULL;</span>
<span class="lineNum">    1161 </span>            : 
<span class="lineNum">    1162 </span>            :         /* Run the actual main function of the thread */
<span class="lineNum">    1163 </span><span class="lineCov">      16812 :         start_routine_res = start_routine (start_routine_arg);</span>
<span class="lineNum">    1164 </span>            : 
<span class="lineNum">    1165 </span><span class="lineCov">      16812 :         mono_thread_info_exit (start_routine_res);</span>
<span class="lineNum">    1166 </span>            : 
<span class="lineNum">    1167 </span><span class="lineCov">      33624 :         g_assert_not_reached ();</span>
<span class="lineNum">    1168 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1169 </span>            : 
<span class="lineNum">    1170 </span>            : /*
<span class="lineNum">    1171 </span>            :  * mono_threads_create_thread:
<span class="lineNum">    1172 </span>            :  *
<span class="lineNum">    1173 </span>            :  *   Create a new thread executing START with argument ARG. Store its id into OUT_TID.
<span class="lineNum">    1174 </span>            :  * Returns: a windows or io-layer handle for the thread.
<a name="1175"><span class="lineNum">    1175 </span>            :  */</a>
<span class="lineNum">    1176 </span>            : MonoThreadHandle*
<span class="lineNum">    1177 </span>            : mono_threads_create_thread (MonoThreadStart start, gpointer arg, gsize * const stack_size, MonoNativeThreadId *out_tid)
<span class="lineNum">    1178 </span>            : {
<span class="lineNum">    1179 </span>            :         CreateThreadData *thread_data;
<span class="lineNum">    1180 </span>            :         gint res;
<span class="lineNum">    1181 </span>            :         MonoThreadHandle *ret;
<span class="lineNum">    1182 </span>            : 
<span class="lineNum">    1183 </span><span class="lineCov">      16812 :         thread_data = g_new0 (CreateThreadData, 1);</span>
<span class="lineNum">    1184 </span><span class="lineCov">      33624 :         mono_refcount_init (thread_data, create_thread_data_destroy);</span>
<span class="lineNum">    1185 </span><span class="lineCov">      16812 :         thread_data-&gt;start_routine = start;</span>
<span class="lineNum">    1186 </span><span class="lineCov">      16812 :         thread_data-&gt;start_routine_arg = arg;</span>
<span class="lineNum">    1187 </span><span class="lineCov">      16812 :         mono_coop_sem_init (&amp;thread_data-&gt;registered, 0);</span>
<span class="lineNum">    1188 </span>            : 
<span class="lineNum">    1189 </span><span class="lineCov">      16812 :         res = mono_threads_platform_create_thread (inner_start_thread, (gpointer) mono_refcount_inc (thread_data), stack_size, out_tid);</span>
<span class="lineNum">    1190 </span><span class="lineCov">      16812 :         if (res != 0) {</span>
<span class="lineNum">    1191 </span>            :                 /* ref is not going to be decremented in inner_start_thread */
<span class="lineNum">    1192 </span><span class="lineNoCov">          0 :                 mono_refcount_dec (thread_data);</span>
<span class="lineNum">    1193 </span><span class="lineNoCov">          0 :                 ret = NULL;</span>
<span class="lineNum">    1194 </span><span class="lineNoCov">          0 :                 goto done;</span>
<span class="lineNum">    1195 </span>            :         }
<span class="lineNum">    1196 </span>            : 
<span class="lineNum">    1197 </span><span class="lineCov">      16812 :         res = mono_coop_sem_wait (&amp;thread_data-&gt;registered, MONO_SEM_FLAGS_NONE);</span>
<span class="lineNum">    1198 </span><span class="lineCov">      50436 :         g_assert (res == 0);</span>
<span class="lineNum">    1199 </span>            : 
<span class="lineNum">    1200 </span><span class="lineCov">      16812 :         ret = thread_data-&gt;handle;</span>
<span class="lineNum">    1201 </span><span class="lineCov">      67248 :         g_assert (ret);</span>
<span class="lineNum">    1202 </span>            : 
<span class="lineNum">    1203 </span>            : done:
<span class="lineNum">    1204 </span><span class="lineCov">      33624 :         mono_refcount_dec (thread_data);</span>
<span class="lineNum">    1205 </span>            : 
<span class="lineNum">    1206 </span><span class="lineCov">      16811 :         return ret;</span>
<span class="lineNum">    1207 </span>            : }
<span class="lineNum">    1208 </span>            : 
<span class="lineNum">    1209 </span>            : /*
<span class="lineNum">    1210 </span>            :  * mono_thread_info_get_stack_bounds:
<span class="lineNum">    1211 </span>            :  *
<span class="lineNum">    1212 </span>            :  *   Return the address and size of the current threads stack. Return NULL as the 
<span class="lineNum">    1213 </span>            :  * stack address if the stack address cannot be determined.
<a name="1214"><span class="lineNum">    1214 </span>            :  */</a>
<span class="lineNum">    1215 </span>            : void
<span class="lineNum">    1216 </span>            : mono_thread_info_get_stack_bounds (guint8 **staddr, size_t *stsize)
<span class="lineNum">    1217 </span>            : {
<span class="lineNum">    1218 </span><span class="lineCov">     230968 :         guint8 *current = (guint8 *)&amp;stsize;</span>
<span class="lineNum">    1219 </span><span class="lineCov">     230968 :         mono_threads_platform_get_stack_bounds (staddr, stsize);</span>
<span class="lineNum">    1220 </span><span class="lineCov">     230968 :         if (!*staddr)</span>
<span class="lineNum">    1221 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">    1222 </span>            : 
<span class="lineNum">    1223 </span>            :         /* Sanity check the result */
<span class="lineNum">    1224 </span><span class="lineCov">    1154840 :         g_assert ((current &gt; *staddr) &amp;&amp; (current &lt; *staddr + *stsize));</span>
<span class="lineNum">    1225 </span>            : 
<span class="lineNum">    1226 </span>            :         /* When running under emacs, sometimes staddr is not aligned to a page size */
<span class="lineNum">    1227 </span><span class="lineCov">     230968 :         *staddr = (guint8*)((gssize)*staddr &amp; ~(mono_pagesize () - 1));</span>
<span class="lineNum">    1228 </span><span class="lineCov">     461936 : }</span>
<a name="1229"><span class="lineNum">    1229 </span>            : </a>
<span class="lineNum">    1230 </span>            : gboolean
<span class="lineNum">    1231 </span>            : mono_thread_info_yield (void)
<span class="lineNum">    1232 </span>            : {
<span class="lineNum">    1233 </span><span class="lineCov">     921804 :         return mono_threads_platform_yield ();</span>
<span class="lineNum">    1234 </span>            : }
<span class="lineNum">    1235 </span>            : static mono_lazy_init_t sleep_init = MONO_LAZY_INIT_STATUS_NOT_INITIALIZED;
<span class="lineNum">    1236 </span>            : static MonoCoopMutex sleep_mutex;
<span class="lineNum">    1237 </span>            : static MonoCoopCond sleep_cond;
<a name="1238"><span class="lineNum">    1238 </span>            : </a>
<span class="lineNum">    1239 </span>            : static void
<span class="lineNum">    1240 </span>            : sleep_initialize (void)
<span class="lineNum">    1241 </span>            : {
<span class="lineNum">    1242 </span><span class="lineCov">       1172 :         mono_coop_mutex_init (&amp;sleep_mutex);</span>
<span class="lineNum">    1243 </span><span class="lineCov">       1172 :         mono_coop_cond_init (&amp;sleep_cond);</span>
<span class="lineNum">    1244 </span><span class="lineCov">       1172 : }</span>
<a name="1245"><span class="lineNum">    1245 </span>            : </a>
<span class="lineNum">    1246 </span>            : static void
<span class="lineNum">    1247 </span>            : sleep_interrupt (gpointer data)
<span class="lineNum">    1248 </span>            : {
<span class="lineNum">    1249 </span><span class="lineCov">         36 :         mono_coop_mutex_lock (&amp;sleep_mutex);</span>
<span class="lineNum">    1250 </span><span class="lineCov">         36 :         mono_coop_cond_broadcast (&amp;sleep_cond);</span>
<span class="lineNum">    1251 </span><span class="lineCov">         36 :         mono_coop_mutex_unlock (&amp;sleep_mutex);</span>
<span class="lineNum">    1252 </span><span class="lineCov">         36 : }</span>
<a name="1253"><span class="lineNum">    1253 </span>            : </a>
<span class="lineNum">    1254 </span>            : static inline guint32
<span class="lineNum">    1255 </span>            : sleep_interruptable (guint32 ms, gboolean *alerted)
<span class="lineNum">    1256 </span>            : {
<span class="lineNum">    1257 </span>            :         gint64 now, end;
<span class="lineNum">    1258 </span>            : 
<span class="lineNum">    1259 </span><span class="lineCov">     182920 :         g_assert (MONO_INFINITE_WAIT == G_MAXUINT32);</span>
<span class="lineNum">    1260 </span>            : 
<span class="lineNum">    1261 </span><span class="lineCov">     274381 :         g_assert (alerted);</span>
<span class="lineNum">    1262 </span><span class="lineCov">      91461 :         *alerted = FALSE;</span>
<span class="lineNum">    1263 </span>            : 
<span class="lineNum">    1264 </span><span class="lineCov">      91461 :         if (ms != MONO_INFINITE_WAIT)</span>
<span class="lineNum">    1265 </span><span class="lineCov">      91460 :                 end = mono_msec_ticks() + ms;</span>
<span class="lineNum">    1266 </span>            : 
<span class="lineNum">    1267 </span><span class="lineCov">      91463 :         mono_lazy_initialize (&amp;sleep_init, sleep_initialize);</span>
<span class="lineNum">    1268 </span>            : 
<span class="lineNum">    1269 </span><span class="lineCov">      91463 :         mono_coop_mutex_lock (&amp;sleep_mutex);</span>
<span class="lineNum">    1270 </span>            : 
<span class="lineNum">    1271 </span><span class="lineCov">     182792 :         for (;;) {</span>
<span class="lineNum">    1272 </span><span class="lineCov">     182793 :                 if (ms != MONO_INFINITE_WAIT) {</span>
<span class="lineNum">    1273 </span><span class="lineCov">     182793 :                         now = mono_msec_ticks();</span>
<span class="lineNum">    1274 </span><span class="lineCov">     182793 :                         if (now &gt;= end)</span>
<span class="lineNum">    1275 </span><span class="lineCov">      91413 :                                 break;</span>
<span class="lineNum">    1276 </span><span class="lineCov">      91380 :                 }</span>
<span class="lineNum">    1277 </span>            : 
<span class="lineNum">    1278 </span><span class="lineCov">      91380 :                 mono_thread_info_install_interrupt (sleep_interrupt, NULL, alerted);</span>
<span class="lineNum">    1279 </span><span class="lineCov">      91380 :                 if (*alerted) {</span>
<span class="lineNum">    1280 </span><span class="lineNoCov">          0 :                         mono_coop_mutex_unlock (&amp;sleep_mutex);</span>
<span class="lineNum">    1281 </span><span class="lineNoCov">          0 :                         return WAIT_IO_COMPLETION;</span>
<span class="lineNum">    1282 </span>            :                 }
<span class="lineNum">    1283 </span>            : 
<span class="lineNum">    1284 </span><span class="lineCov">      91380 :                 if (ms != MONO_INFINITE_WAIT)</span>
<span class="lineNum">    1285 </span><span class="lineCov">      91380 :                         mono_coop_cond_timedwait (&amp;sleep_cond, &amp;sleep_mutex, end - now);</span>
<span class="lineNum">    1286 </span>            :                 else
<span class="lineNum">    1287 </span><span class="lineNoCov">          0 :                         mono_coop_cond_wait (&amp;sleep_cond, &amp;sleep_mutex);</span>
<span class="lineNum">    1288 </span>            : 
<span class="lineNum">    1289 </span><span class="lineCov">      91365 :                 mono_thread_info_uninstall_interrupt (alerted);</span>
<span class="lineNum">    1290 </span><span class="lineCov">      91365 :                 if (*alerted) {</span>
<span class="lineNum">    1291 </span><span class="lineCov">         36 :                         mono_coop_mutex_unlock (&amp;sleep_mutex);</span>
<span class="lineNum">    1292 </span><span class="lineCov">         36 :                         return WAIT_IO_COMPLETION;</span>
<span class="lineNum">    1293 </span>            :                 }
<span class="lineNum">    1294 </span>            :         }
<span class="lineNum">    1295 </span>            : 
<span class="lineNum">    1296 </span><span class="lineCov">      91413 :         mono_coop_mutex_unlock (&amp;sleep_mutex);</span>
<span class="lineNum">    1297 </span>            : 
<span class="lineNum">    1298 </span><span class="lineCov">      91413 :         return 0;</span>
<span class="lineNum">    1299 </span><span class="lineCov">      91448 : }</span>
<a name="1300"><span class="lineNum">    1300 </span>            : </a>
<span class="lineNum">    1301 </span>            : gint
<span class="lineNum">    1302 </span>            : mono_thread_info_sleep (guint32 ms, gboolean *alerted)
<span class="lineNum">    1303 </span>            : {
<span class="lineNum">    1304 </span><span class="lineCov">     955217 :         if (ms == 0) {</span>
<span class="lineNum">    1305 </span>            :                 MonoThreadInfo *info;
<span class="lineNum">    1306 </span>            : 
<span class="lineNum">    1307 </span><span class="lineCov">     651733 :                 mono_thread_info_yield ();</span>
<span class="lineNum">    1308 </span>            : 
<span class="lineNum">    1309 </span><span class="lineCov">     651733 :                 info = mono_thread_info_current ();</span>
<span class="lineNum">    1310 </span><span class="lineCov">    1303467 :                 if (info &amp;&amp; mono_thread_info_is_interrupt_state (info))</span>
<span class="lineNum">    1311 </span><span class="lineCov">          5 :                         return WAIT_IO_COMPLETION;</span>
<span class="lineNum">    1312 </span>            : 
<span class="lineNum">    1313 </span><span class="lineCov">     651729 :                 return 0;</span>
<span class="lineNum">    1314 </span>            :         }
<span class="lineNum">    1315 </span>            : 
<span class="lineNum">    1316 </span><span class="lineCov">     303482 :         if (alerted)</span>
<span class="lineNum">    1317 </span><span class="lineCov">      91460 :                 return sleep_interruptable (ms, alerted);</span>
<span class="lineNum">    1318 </span>            : 
<span class="lineNum">    1319 </span><span class="lineCov">     424044 :         MONO_ENTER_GC_SAFE;</span>
<span class="lineNum">    1320 </span>            : 
<span class="lineNum">    1321 </span><span class="lineCov">     212022 :         if (ms == MONO_INFINITE_WAIT) {</span>
<span class="lineNum">    1322 </span><span class="lineNoCov">          0 :                 do {</span>
<span class="lineNum">    1323 </span>            : #ifdef HOST_WIN32
<span class="lineNum">    1324 </span>            :                         Sleep (G_MAXUINT32);
<span class="lineNum">    1325 </span>            : #else
<span class="lineNum">    1326 </span><span class="lineNoCov">          0 :                         sleep (G_MAXUINT32);</span>
<span class="lineNum">    1327 </span>            : #endif
<span class="lineNum">    1328 </span><span class="lineNoCov">          0 :                 } while (1);</span>
<span class="lineNum">    1329 </span><span class="lineNoCov">          0 :         } else {</span>
<span class="lineNum">    1330 </span>            :                 int ret;
<span class="lineNum">    1331 </span>            : #if defined (__linux__) &amp;&amp; !defined(PLATFORM_ANDROID)
<span class="lineNum">    1332 </span>            :                 struct timespec start, target;
<span class="lineNum">    1333 </span>            : 
<span class="lineNum">    1334 </span>            :                 /* Use clock_nanosleep () to prevent time drifting problems when nanosleep () is interrupted by signals */
<span class="lineNum">    1335 </span>            :                 ret = clock_gettime (CLOCK_MONOTONIC, &amp;start);
<span class="lineNum">    1336 </span>            :                 g_assert (ret == 0);
<span class="lineNum">    1337 </span>            : 
<span class="lineNum">    1338 </span>            :                 target = start;
<span class="lineNum">    1339 </span>            :                 target.tv_sec += ms / 1000;
<span class="lineNum">    1340 </span>            :                 target.tv_nsec += (ms % 1000) * 1000000;
<span class="lineNum">    1341 </span>            :                 if (target.tv_nsec &gt; 999999999) {
<span class="lineNum">    1342 </span>            :                         target.tv_nsec -= 999999999;
<span class="lineNum">    1343 </span>            :                         target.tv_sec ++;
<span class="lineNum">    1344 </span>            :                 }
<span class="lineNum">    1345 </span>            : 
<span class="lineNum">    1346 </span>            :                 do {
<span class="lineNum">    1347 </span>            :                         ret = clock_nanosleep (CLOCK_MONOTONIC, TIMER_ABSTIME, &amp;target, NULL);
<span class="lineNum">    1348 </span>            :                 } while (ret != 0);
<span class="lineNum">    1349 </span>            : #elif HOST_WIN32
<span class="lineNum">    1350 </span>            :                 Sleep (ms);
<span class="lineNum">    1351 </span>            : #else
<span class="lineNum">    1352 </span>            :                 struct timespec req, rem;
<span class="lineNum">    1353 </span>            : 
<span class="lineNum">    1354 </span><span class="lineCov">     212022 :                 req.tv_sec = ms / 1000;</span>
<span class="lineNum">    1355 </span><span class="lineCov">     212022 :                 req.tv_nsec = (ms % 1000) * 1000000;</span>
<span class="lineNum">    1356 </span>            : 
<span class="lineNum">    1357 </span><span class="lineCov">     212022 :                 do {</span>
<span class="lineNum">    1358 </span><span class="lineCov">     212022 :                         memset (&amp;rem, 0, sizeof (rem));</span>
<span class="lineNum">    1359 </span><span class="lineCov">     212022 :                         ret = nanosleep (&amp;req, &amp;rem);</span>
<span class="lineNum">    1360 </span><span class="lineCov">     424044 :                 } while (ret != 0);</span>
<span class="lineNum">    1361 </span>            : #endif /* __linux__ */
<span class="lineNum">    1362 </span>            :         }
<span class="lineNum">    1363 </span>            : 
<span class="lineNum">    1364 </span><span class="lineCov">     212022 :         MONO_EXIT_GC_SAFE;</span>
<span class="lineNum">    1365 </span>            : 
<span class="lineNum">    1366 </span><span class="lineCov">     212022 :         return 0;</span>
<span class="lineNum">    1367 </span><span class="lineCov">     955192 : }</span>
<a name="1368"><span class="lineNum">    1368 </span>            : </a>
<span class="lineNum">    1369 </span>            : gint
<span class="lineNum">    1370 </span>            : mono_thread_info_usleep (guint64 us)
<span class="lineNum">    1371 </span>            : {
<span class="lineNum">    1372 </span><span class="lineCov">       9416 :         MONO_ENTER_GC_SAFE;</span>
<span class="lineNum">    1373 </span><span class="lineCov">       4708 :         g_usleep (us);</span>
<span class="lineNum">    1374 </span><span class="lineCov">       4708 :         MONO_EXIT_GC_SAFE;</span>
<span class="lineNum">    1375 </span><span class="lineCov">       4659 :         return 0;</span>
<span class="lineNum">    1376 </span>            : }
<a name="1377"><span class="lineNum">    1377 </span>            : </a>
<span class="lineNum">    1378 </span>            : gpointer
<span class="lineNum">    1379 </span>            : mono_thread_info_tls_get (THREAD_INFO_TYPE *info, MonoTlsKey key)
<span class="lineNum">    1380 </span>            : {
<span class="lineNum">    1381 </span><span class="lineCov">    1405887 :         return ((MonoThreadInfo*)info)-&gt;tls [key];</span>
<span class="lineNum">    1382 </span>            : }
<span class="lineNum">    1383 </span>            : 
<span class="lineNum">    1384 </span>            : /*
<span class="lineNum">    1385 </span>            :  * mono_threads_info_tls_set:
<span class="lineNum">    1386 </span>            :  *
<span class="lineNum">    1387 </span>            :  *   Set the TLS key to VALUE in the info structure. This can be used to obtain
<span class="lineNum">    1388 </span>            :  * values of TLS variables for threads other than the current thread.
<span class="lineNum">    1389 </span>            :  * This should only be used for infrequently changing TLS variables, and it should
<span class="lineNum">    1390 </span>            :  * be paired with setting the real TLS variable since this provides no GC tracking.
<a name="1391"><span class="lineNum">    1391 </span>            :  */</a>
<span class="lineNum">    1392 </span>            : void
<span class="lineNum">    1393 </span>            : mono_thread_info_tls_set (THREAD_INFO_TYPE *info, MonoTlsKey key, gpointer value)
<span class="lineNum">    1394 </span>            : {
<span class="lineNum">    1395 </span><span class="lineCov">     138682 :         ((MonoThreadInfo*)info)-&gt;tls [key] = value;</span>
<span class="lineNum">    1396 </span><span class="lineCov">     138682 : }</span>
<span class="lineNum">    1397 </span>            : 
<span class="lineNum">    1398 </span>            : #if defined(__native_client__)
<span class="lineNum">    1399 </span>            : void nacl_shutdown_gc_thread(void);
<span class="lineNum">    1400 </span>            : #endif
<span class="lineNum">    1401 </span>            : 
<span class="lineNum">    1402 </span>            : /*
<span class="lineNum">    1403 </span>            :  * mono_thread_info_exit:
<span class="lineNum">    1404 </span>            :  *
<span class="lineNum">    1405 </span>            :  *   Exit the current thread.
<span class="lineNum">    1406 </span>            :  * This function doesn't return.
<a name="1407"><span class="lineNum">    1407 </span>            :  */</a>
<span class="lineNum">    1408 </span>            : void
<span class="lineNum">    1409 </span>            : mono_thread_info_exit (gsize exit_code)
<span class="lineNum">    1410 </span>            : {
<span class="lineNum">    1411 </span>            : #if defined(__native_client__)
<span class="lineNum">    1412 </span>            :         nacl_shutdown_gc_thread();
<span class="lineNum">    1413 </span>            : #endif
<span class="lineNum">    1414 </span>            : 
<span class="lineNum">    1415 </span><span class="lineCov">      16744 :         mono_thread_info_detach ();</span>
<span class="lineNum">    1416 </span>            : 
<span class="lineNum">    1417 </span><span class="lineCov">      16744 :         mono_threads_platform_exit (0);</span>
<span class="lineNum">    1418 </span><span class="lineCov">      16744 : }</span>
<span class="lineNum">    1419 </span>            : 
<span class="lineNum">    1420 </span>            : /*
<span class="lineNum">    1421 </span>            :  * mono_threads_open_thread_handle:
<span class="lineNum">    1422 </span>            :  *
<span class="lineNum">    1423 </span>            :  *  Duplicate the handle. The handle needs to be closed by calling
<span class="lineNum">    1424 </span>            :  *  mono_threads_close_thread_handle () when it is no longer needed.
<a name="1425"><span class="lineNum">    1425 </span>            :  */</a>
<span class="lineNum">    1426 </span>            : MonoThreadHandle*
<span class="lineNum">    1427 </span>            : mono_threads_open_thread_handle (MonoThreadHandle *thread_handle)
<span class="lineNum">    1428 </span>            : {
<span class="lineNum">    1429 </span><span class="lineCov">      68000 :         return mono_refcount_inc (thread_handle);</span>
<span class="lineNum">    1430 </span>            : }
<a name="1431"><span class="lineNum">    1431 </span>            : </a>
<span class="lineNum">    1432 </span>            : void
<span class="lineNum">    1433 </span>            : mono_threads_close_thread_handle (MonoThreadHandle *thread_handle)
<span class="lineNum">    1434 </span>            : {
<span class="lineNum">    1435 </span><span class="lineCov">     164996 :         mono_refcount_dec (thread_handle);</span>
<span class="lineNum">    1436 </span><span class="lineCov">      82502 : }</span>
<a name="1437"><span class="lineNum">    1437 </span>            : </a>
<span class="lineNum">    1438 </span>            : static void
<span class="lineNum">    1439 </span>            : mono_threads_signal_thread_handle (MonoThreadHandle* thread_handle)
<span class="lineNum">    1440 </span>            : {
<span class="lineNum">    1441 </span><span class="lineCov">      17842 :         mono_os_event_set (&amp;thread_handle-&gt;event);</span>
<span class="lineNum">    1442 </span><span class="lineCov">      17842 : }</span>
<span class="lineNum">    1443 </span>            : 
<span class="lineNum">    1444 </span>            : #define INTERRUPT_STATE ((MonoThreadInfoInterruptToken*) (size_t) -1)
<span class="lineNum">    1445 </span>            : 
<span class="lineNum">    1446 </span>            : struct _MonoThreadInfoInterruptToken {
<span class="lineNum">    1447 </span>            :         void (*callback) (gpointer data);
<span class="lineNum">    1448 </span>            :         gpointer data;
<span class="lineNum">    1449 </span>            : };
<span class="lineNum">    1450 </span>            : 
<span class="lineNum">    1451 </span>            : /*
<span class="lineNum">    1452 </span>            :  * mono_thread_info_install_interrupt: install an interruption token for the current thread.
<span class="lineNum">    1453 </span>            :  *
<span class="lineNum">    1454 </span>            :  *  - @callback: must be able to be called from another thread and always cancel the wait
<span class="lineNum">    1455 </span>            :  *  - @data: passed to the callback
<span class="lineNum">    1456 </span>            :  *  - @interrupted: will be set to TRUE if a token is already installed, FALSE otherwise
<span class="lineNum">    1457 </span>            :  *     if set to TRUE, it must mean that the thread is in interrupted state
<a name="1458"><span class="lineNum">    1458 </span>            :  */</a>
<span class="lineNum">    1459 </span>            : void
<span class="lineNum">    1460 </span>            : mono_thread_info_install_interrupt (void (*callback) (gpointer data), gpointer data, gboolean *interrupted)
<span class="lineNum">    1461 </span>            : {
<span class="lineNum">    1462 </span>            :         MonoThreadInfo *info;
<span class="lineNum">    1463 </span>            :         MonoThreadInfoInterruptToken *previous_token, *token;
<span class="lineNum">    1464 </span>            : 
<span class="lineNum">    1465 </span><span class="lineCov">    4335048 :         g_assert (callback);</span>
<span class="lineNum">    1466 </span>            : 
<span class="lineNum">    1467 </span><span class="lineCov">    4335050 :         g_assert (interrupted);</span>
<span class="lineNum">    1468 </span><span class="lineCov">    1445017 :         *interrupted = FALSE;</span>
<span class="lineNum">    1469 </span>            : 
<span class="lineNum">    1470 </span><span class="lineCov">    1445017 :         info = mono_thread_info_current ();</span>
<span class="lineNum">    1471 </span><span class="lineCov">    4335047 :         g_assert (info);</span>
<span class="lineNum">    1472 </span>            : 
<span class="lineNum">    1473 </span>            :         /* The memory of this token can be freed at 2 places:
<span class="lineNum">    1474 </span>            :          *  - if the token is not interrupted: it will be freed in uninstall, as info-&gt;interrupt_token has not been replaced
<span class="lineNum">    1475 </span>            :          *     by the INTERRUPT_STATE flag value, and it still contains the pointer to the memory location
<span class="lineNum">    1476 </span>            :          *  - if the token is interrupted: it will be freed in finish, as the token is now owned by the prepare/finish
<span class="lineNum">    1477 </span>            :          *     functions, and info-&gt;interrupt_token does not contains a pointer to the memory anymore */
<span class="lineNum">    1478 </span><span class="lineCov">    1445042 :         token = g_new0 (MonoThreadInfoInterruptToken, 1);</span>
<span class="lineNum">    1479 </span><span class="lineCov">    1445042 :         token-&gt;callback = callback;</span>
<span class="lineNum">    1480 </span><span class="lineCov">    1445042 :         token-&gt;data = data;</span>
<span class="lineNum">    1481 </span>            : 
<span class="lineNum">    1482 </span><span class="lineCov">    1445042 :         previous_token = (MonoThreadInfoInterruptToken *)InterlockedCompareExchangePointer ((gpointer*) &amp;info-&gt;interrupt_token, token, NULL);</span>
<span class="lineNum">    1483 </span>            : 
<span class="lineNum">    1484 </span><span class="lineCov">    1445042 :         if (previous_token) {</span>
<span class="lineNum">    1485 </span><span class="lineCov">          1 :                 if (previous_token != INTERRUPT_STATE)</span>
<span class="lineNum">    1486 </span><span class="lineNoCov">          0 :                         g_error (&quot;mono_thread_info_install_interrupt: previous_token should be INTERRUPT_STATE (%p), but it was %p&quot;, INTERRUPT_STATE, previous_token);</span>
<span class="lineNum">    1487 </span>            : 
<span class="lineNum">    1488 </span><span class="lineCov">          1 :                 g_free (token);</span>
<span class="lineNum">    1489 </span>            : 
<span class="lineNum">    1490 </span><span class="lineCov">          1 :                 *interrupted = TRUE;</span>
<span class="lineNum">    1491 </span><span class="lineCov">          1 :         }</span>
<span class="lineNum">    1492 </span>            : 
<span class="lineNum">    1493 </span>            :         THREADS_INTERRUPT_DEBUG (&quot;interrupt install    tid %p token %p previous_token %p interrupted %s\n&quot;,
<span class="lineNum">    1494 </span>            :                 mono_thread_info_get_tid (info), token, previous_token, *interrupted ? &quot;TRUE&quot; : &quot;FALSE&quot;);
<span class="lineNum">    1495 </span><span class="lineCov">    1445043 : }</span>
<a name="1496"><span class="lineNum">    1496 </span>            : </a>
<span class="lineNum">    1497 </span>            : void
<span class="lineNum">    1498 </span>            : mono_thread_info_uninstall_interrupt (gboolean *interrupted)
<span class="lineNum">    1499 </span>            : {
<span class="lineNum">    1500 </span>            :         MonoThreadInfo *info;
<span class="lineNum">    1501 </span>            :         MonoThreadInfoInterruptToken *previous_token;
<span class="lineNum">    1502 </span>            : 
<span class="lineNum">    1503 </span><span class="lineCov">    4334913 :         g_assert (interrupted);</span>
<span class="lineNum">    1504 </span><span class="lineCov">    1444970 :         *interrupted = FALSE;</span>
<span class="lineNum">    1505 </span>            : 
<span class="lineNum">    1506 </span><span class="lineCov">    1444970 :         info = mono_thread_info_current ();</span>
<span class="lineNum">    1507 </span><span class="lineCov">    4334902 :         g_assert (info);</span>
<span class="lineNum">    1508 </span>            : 
<span class="lineNum">    1509 </span><span class="lineCov">    1444967 :         previous_token = (MonoThreadInfoInterruptToken *)InterlockedExchangePointer ((gpointer*) &amp;info-&gt;interrupt_token, NULL);</span>
<span class="lineNum">    1510 </span>            : 
<span class="lineNum">    1511 </span>            :         /* only the installer can uninstall the token */
<span class="lineNum">    1512 </span><span class="lineCov">    4334949 :         g_assert (previous_token);</span>
<span class="lineNum">    1513 </span>            : 
<span class="lineNum">    1514 </span><span class="lineCov">    1444991 :         if (previous_token == INTERRUPT_STATE) {</span>
<span class="lineNum">    1515 </span>            :                 /* if it is interrupted, then it is going to be freed in finish interrupt */
<span class="lineNum">    1516 </span><span class="lineCov">        416 :                 *interrupted = TRUE;</span>
<span class="lineNum">    1517 </span><span class="lineCov">        416 :         } else {</span>
<span class="lineNum">    1518 </span><span class="lineCov">    1444574 :                 g_free (previous_token);</span>
<span class="lineNum">    1519 </span>            :         }
<span class="lineNum">    1520 </span>            : 
<span class="lineNum">    1521 </span>            :         THREADS_INTERRUPT_DEBUG (&quot;interrupt uninstall  tid %p previous_token %p interrupted %s\n&quot;,
<span class="lineNum">    1522 </span>            :                 mono_thread_info_get_tid (info), previous_token, *interrupted ? &quot;TRUE&quot; : &quot;FALSE&quot;);
<span class="lineNum">    1523 </span><span class="lineCov">    1444971 : }</span>
<a name="1524"><span class="lineNum">    1524 </span>            : </a>
<span class="lineNum">    1525 </span>            : static MonoThreadInfoInterruptToken*
<span class="lineNum">    1526 </span>            : set_interrupt_state (MonoThreadInfo *info)
<span class="lineNum">    1527 </span>            : {
<span class="lineNum">    1528 </span>            :         MonoThreadInfoInterruptToken *token, *previous_token;
<span class="lineNum">    1529 </span>            : 
<span class="lineNum">    1530 </span><span class="lineCov">     629838 :         g_assert (info);</span>
<span class="lineNum">    1531 </span>            : 
<span class="lineNum">    1532 </span>            :         /* Atomically obtain the token the thread is
<span class="lineNum">    1533 </span>            :         * waiting on, and change it to a flag value. */
<span class="lineNum">    1534 </span>            : 
<span class="lineNum">    1535 </span><span class="lineCov">     209946 :         do {</span>
<span class="lineNum">    1536 </span><span class="lineCov">     209946 :                 previous_token = info-&gt;interrupt_token;</span>
<span class="lineNum">    1537 </span>            : 
<span class="lineNum">    1538 </span>            :                 /* Already interrupted */
<span class="lineNum">    1539 </span><span class="lineCov">     209946 :                 if (previous_token == INTERRUPT_STATE) {</span>
<span class="lineNum">    1540 </span><span class="lineCov">       5794 :                         token = NULL;</span>
<span class="lineNum">    1541 </span><span class="lineCov">       5794 :                         break;</span>
<span class="lineNum">    1542 </span>            :                 }
<span class="lineNum">    1543 </span>            : 
<span class="lineNum">    1544 </span><span class="lineCov">     204152 :                 token = previous_token;</span>
<span class="lineNum">    1545 </span><span class="lineCov">     408304 :         } while (InterlockedCompareExchangePointer ((gpointer*) &amp;info-&gt;interrupt_token, INTERRUPT_STATE, previous_token) != previous_token);</span>
<span class="lineNum">    1546 </span>            : 
<span class="lineNum">    1547 </span><span class="lineCov">     209946 :         return token;</span>
<span class="lineNum">    1548 </span>            : }
<span class="lineNum">    1549 </span>            : 
<span class="lineNum">    1550 </span>            : /*
<span class="lineNum">    1551 </span>            :  * mono_thread_info_prepare_interrupt:
<span class="lineNum">    1552 </span>            :  *
<span class="lineNum">    1553 </span>            :  * The state of the thread info interrupt token is set to 'interrupted' which means that :
<span class="lineNum">    1554 </span>            :  *  - if the thread calls one of the WaitFor functions, the function will return with
<span class="lineNum">    1555 </span>            :  *     WAIT_IO_COMPLETION instead of waiting
<span class="lineNum">    1556 </span>            :  *  - if the thread was waiting when this function was called, the wait will be broken
<span class="lineNum">    1557 </span>            :  *
<span class="lineNum">    1558 </span>            :  * It is possible that the wait functions return WAIT_IO_COMPLETION, but the target thread
<span class="lineNum">    1559 </span>            :  * didn't receive the interrupt signal yet, in this case it should call the wait function
<span class="lineNum">    1560 </span>            :  * again. This essentially means that the target thread will busy wait until it is ready to
<span class="lineNum">    1561 </span>            :  * process the interruption.
<a name="1562"><span class="lineNum">    1562 </span>            :  */</a>
<span class="lineNum">    1563 </span>            : MonoThreadInfoInterruptToken*
<span class="lineNum">    1564 </span>            : mono_thread_info_prepare_interrupt (MonoThreadInfo *info)
<span class="lineNum">    1565 </span>            : {
<span class="lineNum">    1566 </span>            :         MonoThreadInfoInterruptToken *token;
<span class="lineNum">    1567 </span>            : 
<span class="lineNum">    1568 </span><span class="lineCov">       6282 :         token = set_interrupt_state (info);</span>
<span class="lineNum">    1569 </span>            : 
<span class="lineNum">    1570 </span>            :         THREADS_INTERRUPT_DEBUG (&quot;interrupt prepare    tid %p token %p\n&quot;,
<span class="lineNum">    1571 </span>            :                 mono_thread_info_get_tid (info), token);
<span class="lineNum">    1572 </span>            : 
<span class="lineNum">    1573 </span><span class="lineCov">       6282 :         return token;</span>
<span class="lineNum">    1574 </span>            : }
<a name="1575"><span class="lineNum">    1575 </span>            : </a>
<span class="lineNum">    1576 </span>            : void
<span class="lineNum">    1577 </span>            : mono_thread_info_finish_interrupt (MonoThreadInfoInterruptToken *token)
<span class="lineNum">    1578 </span>            : {
<span class="lineNum">    1579 </span>            :         THREADS_INTERRUPT_DEBUG (&quot;interrupt finish     token %p\n&quot;, token);
<span class="lineNum">    1580 </span>            : 
<span class="lineNum">    1581 </span><span class="lineCov">        416 :         if (token == NULL)</span>
<span class="lineNum">    1582 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">    1583 </span>            : 
<span class="lineNum">    1584 </span><span class="lineCov">       1248 :         g_assert (token-&gt;callback);</span>
<span class="lineNum">    1585 </span>            : 
<span class="lineNum">    1586 </span><span class="lineCov">        416 :         token-&gt;callback (token-&gt;data);</span>
<span class="lineNum">    1587 </span>            : 
<span class="lineNum">    1588 </span><span class="lineCov">        416 :         g_free (token);</span>
<span class="lineNum">    1589 </span><span class="lineCov">        832 : }</span>
<a name="1590"><span class="lineNum">    1590 </span>            : </a>
<span class="lineNum">    1591 </span>            : void
<span class="lineNum">    1592 </span>            : mono_thread_info_self_interrupt (void)
<span class="lineNum">    1593 </span>            : {
<span class="lineNum">    1594 </span>            :         MonoThreadInfo *info;
<span class="lineNum">    1595 </span>            :         MonoThreadInfoInterruptToken *token;
<span class="lineNum">    1596 </span>            : 
<span class="lineNum">    1597 </span><span class="lineCov">     203664 :         info = mono_thread_info_current ();</span>
<span class="lineNum">    1598 </span><span class="lineCov">     610992 :         g_assert (info);</span>
<span class="lineNum">    1599 </span>            : 
<span class="lineNum">    1600 </span><span class="lineCov">     203664 :         token = set_interrupt_state (info);</span>
<span class="lineNum">    1601 </span><span class="lineCov">     610992 :         g_assert (!token);</span>
<span class="lineNum">    1602 </span>            : 
<span class="lineNum">    1603 </span>            :         THREADS_INTERRUPT_DEBUG (&quot;interrupt self       tid %p\n&quot;,
<span class="lineNum">    1604 </span>            :                 mono_thread_info_get_tid (info));
<span class="lineNum">    1605 </span><span class="lineCov">     203664 : }</span>
<span class="lineNum">    1606 </span>            : 
<span class="lineNum">    1607 </span>            : /* Clear the interrupted flag of the current thread, set with
<a name="1608"><span class="lineNum">    1608 </span>            :  * mono_thread_info_self_interrupt, so it can wait again */</a>
<span class="lineNum">    1609 </span>            : void
<span class="lineNum">    1610 </span>            : mono_thread_info_clear_self_interrupt ()
<span class="lineNum">    1611 </span>            : {
<span class="lineNum">    1612 </span>            :         MonoThreadInfo *info;
<span class="lineNum">    1613 </span>            :         MonoThreadInfoInterruptToken *previous_token;
<span class="lineNum">    1614 </span>            : 
<span class="lineNum">    1615 </span><span class="lineCov">     204173 :         info = mono_thread_info_current ();</span>
<span class="lineNum">    1616 </span><span class="lineCov">     612519 :         g_assert (info);</span>
<span class="lineNum">    1617 </span>            : 
<span class="lineNum">    1618 </span><span class="lineCov">     204173 :         previous_token = (MonoThreadInfoInterruptToken *)InterlockedCompareExchangePointer ((gpointer*) &amp;info-&gt;interrupt_token, NULL, INTERRUPT_STATE);</span>
<span class="lineNum">    1619 </span><span class="lineCov">    1020427 :         g_assert (previous_token == NULL || previous_token == INTERRUPT_STATE);</span>
<span class="lineNum">    1620 </span>            : 
<span class="lineNum">    1621 </span>            :         THREADS_INTERRUPT_DEBUG (&quot;interrupt clear self tid %p previous_token %p\n&quot;, mono_thread_info_get_tid (info), previous_token);
<span class="lineNum">    1622 </span><span class="lineCov">     204173 : }</span>
<a name="1623"><span class="lineNum">    1623 </span>            : </a>
<span class="lineNum">    1624 </span>            : gboolean
<span class="lineNum">    1625 </span>            : mono_thread_info_is_interrupt_state (MonoThreadInfo *info)
<span class="lineNum">    1626 </span>            : {
<span class="lineNum">    1627 </span><span class="lineCov">    1955199 :         g_assert (info);</span>
<span class="lineNum">    1628 </span><span class="lineCov">     651733 :         return InterlockedReadPointer ((gpointer*) &amp;info-&gt;interrupt_token) == INTERRUPT_STATE;</span>
<span class="lineNum">    1629 </span>            : }
<a name="1630"><span class="lineNum">    1630 </span>            : </a>
<span class="lineNum">    1631 </span>            : void
<span class="lineNum">    1632 </span>            : mono_thread_info_describe_interrupt_token (MonoThreadInfo *info, GString *text)
<span class="lineNum">    1633 </span>            : {
<span class="lineNum">    1634 </span><span class="lineNoCov">          0 :         g_assert (info);</span>
<span class="lineNum">    1635 </span>            : 
<span class="lineNum">    1636 </span><span class="lineNoCov">          0 :         if (!InterlockedReadPointer ((gpointer*) &amp;info-&gt;interrupt_token))</span>
<span class="lineNum">    1637 </span><span class="lineNoCov">          0 :                 g_string_append_printf (text, &quot;not waiting&quot;);</span>
<span class="lineNum">    1638 </span><span class="lineNoCov">          0 :         else if (InterlockedReadPointer ((gpointer*) &amp;info-&gt;interrupt_token) == INTERRUPT_STATE)</span>
<span class="lineNum">    1639 </span><span class="lineNoCov">          0 :                 g_string_append_printf (text, &quot;interrupted state&quot;);</span>
<span class="lineNum">    1640 </span>            :         else
<span class="lineNum">    1641 </span><span class="lineNoCov">          0 :                 g_string_append_printf (text, &quot;waiting&quot;);</span>
<span class="lineNum">    1642 </span><span class="lineNoCov">          0 : }</span>
<a name="1643"><span class="lineNum">    1643 </span>            : </a>
<span class="lineNum">    1644 </span>            : gboolean
<span class="lineNum">    1645 </span>            : mono_thread_info_is_current (MonoThreadInfo *info)
<span class="lineNum">    1646 </span>            : {
<span class="lineNum">    1647 </span><span class="lineCov">     416292 :         return mono_thread_info_get_tid (info) == mono_native_thread_id_get ();</span>
<span class="lineNum">    1648 </span>            : }
<a name="1649"><span class="lineNum">    1649 </span>            : </a>
<span class="lineNum">    1650 </span>            : MonoThreadInfoWaitRet
<span class="lineNum">    1651 </span>            : mono_thread_info_wait_one_handle (MonoThreadHandle *thread_handle, guint32 timeout, gboolean alertable)
<span class="lineNum">    1652 </span>            : {
<span class="lineNum">    1653 </span>            :         MonoOSEventWaitRet res;
<span class="lineNum">    1654 </span>            : 
<span class="lineNum">    1655 </span><span class="lineCov">     279390 :         res = mono_os_event_wait_one (&amp;thread_handle-&gt;event, timeout);</span>
<span class="lineNum">    1656 </span><span class="lineCov">     279390 :         if (res == MONO_OS_EVENT_WAIT_RET_SUCCESS_0)</span>
<span class="lineNum">    1657 </span><span class="lineCov">       6250 :                 return MONO_THREAD_INFO_WAIT_RET_SUCCESS_0;</span>
<span class="lineNum">    1658 </span><span class="lineCov">     273140 :         else if (res == MONO_OS_EVENT_WAIT_RET_ALERTED)</span>
<span class="lineNum">    1659 </span><span class="lineCov">          1 :                 return MONO_THREAD_INFO_WAIT_RET_ALERTED;</span>
<span class="lineNum">    1660 </span><span class="lineCov">     273139 :         else if (res == MONO_OS_EVENT_WAIT_RET_TIMEOUT)</span>
<span class="lineNum">    1661 </span><span class="lineCov">     273139 :                 return MONO_THREAD_INFO_WAIT_RET_TIMEOUT;</span>
<span class="lineNum">    1662 </span>            :         else
<span class="lineNum">    1663 </span><span class="lineNoCov">          0 :                 g_error (&quot;%s: unknown res value %d&quot;, __func__, res);</span>
<span class="lineNum">    1664 </span><span class="lineCov">     279390 : }</span>
<a name="1665"><span class="lineNum">    1665 </span>            : </a>
<span class="lineNum">    1666 </span>            : MonoThreadInfoWaitRet
<span class="lineNum">    1667 </span>            : mono_thread_info_wait_multiple_handle (MonoThreadHandle **thread_handles, gsize nhandles, MonoOSEvent *background_change_event, gboolean waitall, guint32 timeout, gboolean alertable)
<span class="lineNum">    1668 </span>            : {
<span class="lineNum">    1669 </span>            :         MonoOSEventWaitRet res;
<span class="lineNum">    1670 </span>            :         MonoOSEvent *thread_events [MONO_OS_EVENT_WAIT_MAXIMUM_OBJECTS];
<span class="lineNum">    1671 </span>            :         gint i;
<span class="lineNum">    1672 </span>            : 
<span class="lineNum">    1673 </span><span class="lineCov">        570 :         g_assert (nhandles &lt;= MONO_OS_EVENT_WAIT_MAXIMUM_OBJECTS);</span>
<span class="lineNum">    1674 </span><span class="lineCov">        190 :         if (background_change_event)</span>
<span class="lineNum">    1675 </span><span class="lineCov">         80 :                 g_assert (nhandles &lt;= MONO_OS_EVENT_WAIT_MAXIMUM_OBJECTS - 1);</span>
<span class="lineNum">    1676 </span>            : 
<span class="lineNum">    1677 </span><span class="lineCov">        860 :         for (i = 0; i &lt; nhandles; ++i)</span>
<span class="lineNum">    1678 </span><span class="lineCov">        240 :                 thread_events [i] = &amp;thread_handles [i]-&gt;event;</span>
<span class="lineNum">    1679 </span>            : 
<span class="lineNum">    1680 </span><span class="lineCov">        190 :         if (background_change_event)</span>
<span class="lineNum">    1681 </span><span class="lineCov">         20 :                 thread_events [nhandles ++] = background_change_event;</span>
<span class="lineNum">    1682 </span>            : 
<span class="lineNum">    1683 </span><span class="lineCov">        190 :         res = mono_os_event_wait_multiple (thread_events, nhandles, waitall, timeout);</span>
<span class="lineNum">    1684 </span><span class="lineCov">        371 :         if (res &gt;= MONO_OS_EVENT_WAIT_RET_SUCCESS_0 &amp;&amp; res &lt;= MONO_OS_EVENT_WAIT_RET_SUCCESS_0 + nhandles - 1)</span>
<span class="lineNum">    1685 </span><span class="lineCov">        181 :                 return MONO_THREAD_INFO_WAIT_RET_SUCCESS_0 + (res - MONO_OS_EVENT_WAIT_RET_SUCCESS_0);</span>
<span class="lineNum">    1686 </span><span class="lineCov">          9 :         else if (res == MONO_OS_EVENT_WAIT_RET_ALERTED)</span>
<span class="lineNum">    1687 </span><span class="lineCov">          1 :                 return MONO_THREAD_INFO_WAIT_RET_ALERTED;</span>
<span class="lineNum">    1688 </span><span class="lineCov">          8 :         else if (res == MONO_OS_EVENT_WAIT_RET_TIMEOUT)</span>
<span class="lineNum">    1689 </span><span class="lineCov">          8 :                 return MONO_THREAD_INFO_WAIT_RET_TIMEOUT;</span>
<span class="lineNum">    1690 </span>            :         else
<span class="lineNum">    1691 </span><span class="lineNoCov">          0 :                 g_error (&quot;%s: unknown res value %d&quot;, __func__, res);</span>
<span class="lineNum">    1692 </span><span class="lineCov">        190 : }</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
